<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Freeman]]></title>
  <subtitle><![CDATA[This world is a playground.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-12-18T01:58:31.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Freeman]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[开源操作系统技术年会会后杂谈]]></title>
    <link href="http://yoursite.com/2016/12/18/open-source-operating-system-annual-technical-conference/"/>
    <id>http://yoursite.com/2016/12/18/open-source-operating-system-annual-technical-conference/</id>
    <published>2016-12-18T01:48:08.000Z</published>
    <updated>2016-12-18T01:58:31.000Z</updated>
    <content type="html"><![CDATA[<p>虽然是技术年会，我却跑去听了教育专题研讨论分会场。意外的是，这个分会给了我很多启发。</p>
<a id="more"></a>
<p>首先超级感动：国内高校有这么多有责任心的老师，认认真真思考教育、了解学生，热情洋溢地交流教学方法。他们是上海交大软院院长臧斌宇（2002年就开始的系统化教学改革）、北京大学陈向群（主持人）、北航王雷（利用数据分析学生实验行为）、复旦的张亮／高建（AIM教学内核,github: davidgao）。</p>
<p>听完报告，我果然很遗憾自己的操作系统课程水水就过去了。悲哉！难得自己对操作系统那么感兴趣，去没有最大程度地被引导利用。好想回本科系统地学习、实验一遍。另外一个听会感受是：写内核对本科生的要求算很高，就算是北大、上交这类层次的学校，每年也只有二三十人的“拔尖班”学生有能力进行内核开发（开发自己的玩具内核或修改教学内核），然而工业界对系统知识人才目前有求贤若渴之感。那缺失的这部分人才在哪里呢？好在研究生和几年工作经验的人稍稍补上了这类缺口。</p>
<p>我从大一下学期开始，就对计算机底层运行机制非常感兴趣。没记错的话，把注意力真正转移到内核设计实现是在大二上邂逅了日本人的那本《30天》，大二下选修了操作系统概念这门课。然而课如其名，真的只是教“概念”，颇有学习文科课程之感。当时这门课的小实验是unix/linux环境系统编程，就是使用一些API进行多进程、多线程编程。一开始我觉得莫名其妙、浅尝辄止（我想知道fork怎么实现，而不是学习如何利用fork！），不过今天听了上交臧斌宇老师的观点，他认为通过这些系统调用，了解操作系统内核暴露给用户的接口，是学习操作系统一个比较好的切入点。除了小实验，这门课的课程设计是漫无目的地自个儿琢磨uCOS，老师除了布置这个实验外其它一句话没说。听说南信大另外一个教授操作系统的王进老师的实验是在用户态模拟一些内核行为，如内存分配——虽然和上交拔尖班直接真实内核环境编程还差很远，但是上交臧斌宇老师自己也说了，内核编程不能强迫每个同学去做。大学里水完了操作系统这门课，有幸从恩师王金伟那得到一个课题，注意力转移到了Linux内核编程。课题为期一年，这个过程让我深刻体会到操作系统概念教程这门课和实际内核开发之间的鸿沟。在磕磕绊绊完成课题后，也就是大四上学期的尾巴到寒假这两个多月，我参照《Orange’s》设计自己的内核，实现了bootloader、系统调用框架、多进程轮转切换。和复旦高建同学（新偶像！）自己编写的特性丰富的AIM教学内核比起来，我的非常原始。</p>
<p>悔恨的我一度想捧起教科书重新学习操作系统，一度想掏出两年前自己写的内核好好完善完善。可是错过了就是错过了，从另外一个角度看，也没有必要。现在反思操作系统这门课，我觉得课程的目的是理解操作系统，再通过操作系统在系统结构整个领域中至关重要的位置，发散着去理解整个计算机结构，让学生成为一个对“系统知识”有“知识系统”的人，从而能在这个基础上做出自己的工作。而不是，把重新造轮子当作工作，抑或是为了理解操作系统而去理解操作系统，那顶多是解解好奇之渴，作为一个研究生我不能满足于此。操作系统考了多高的分数，实验做得多么精妙绝伦，本身都不是目的，对系统结构整体观念的把握能力是我们该好好培养的。</p>
<center><br><img src="/img/open-source-operating-system-annual-technical-conference.jpg" alt=""><br></center>]]></content>
    <summary type="html">
    <![CDATA[<p>虽然是技术年会，我却跑去听了教育专题研讨论分会场。意外的是，这个分会给了我很多启发。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[2016年计算机体系结构领域研究热点调研报告]]></title>
    <link href="http://yoursite.com/2016/12/16/2016-architecture-research-hotspot/"/>
    <id>http://yoursite.com/2016/12/16/2016-architecture-research-hotspot/</id>
    <published>2016-12-16T01:08:23.000Z</published>
    <updated>2016-12-16T01:21:02.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>2016年计算机体系结构领域研究热点有哪些？为回答这个问题，本文分析了2016年CCF推荐会议中124篇关于计算机体系结构的前沿论文，对其研究主题进行分类和统计，归纳出了“新领域－老问题矩阵”。本文记录了这个矩阵的构成，以及通过这个矩阵得到的一些有意思的发现。</p>
</blockquote>
<a id="more"></a>
<h3 id="1-_研究方法和原始数据">1. 研究方法和原始数据</h3><p>调研遍历了2016年CCF(中国计算机学会)推荐国际学术会议列表(以下简称列表)124篇计算机体系结构领域的论文，通过分析论文标题、关键词、摘要、引言等内容，提取研究主题。这些论文，来自列表A类会议中的前三个：ASPLOS (Architectural Support for Programming Languages and Operating Systems)、FAST (Conference on File and Storage Technologies)和 HPCA(High-Performance Computer Architecture)。</p>
<p>按照这个方法，我们获得一张包含134个项目的表格，作为研究分析的原始数据。在分析论文研究主题的过程中，我发现部分论文的描述自己的研究主题采取一定格式：首先介绍大领域，接着介绍具体的问题，最后提出自己的解决方法。例如，一篇文章的研究内容可能是NVM (大领域)的功耗 (具体问题)，然后以”in this paper”引出自己的解决方案。在满足这个特征的论文中我还发现两个特性：大领域往往是一些热门技术，如NVM、事务内存等。而那些大领域下的具体问题，往往是一些共性的、经典的问题，如：功耗、可靠性等。基于这些特征，我把原始数据根据论文研究主题整理出一个表格，称之为“新领域－老问题矩阵”。矩阵剔除了部分与体系结构关系不密切的文章。</p>
<center><br><img src="/img/new_tech_old_problem.png" alt=""><br></center>

<p>下面具体描述新领域－老问题矩阵的构成。矩阵深灰色区域每一格代表一个“新领域”，浅灰色每一格代表一个“老问题”，浅色区域每个格子中的每个数值为一篇论文在本研究中的序号，多篇论文用逗号分开。格子的行列表示这篇论文研究的主题是行代表的“新领域”和列代表的“老问题”相结合。需要注意的是，不是所有的论文都满足上文中提到的三项特征，它们被列举在other一栏。”新领域“的other（行）表示主题为未列出的其它领域技术但是具有对应”老问题“的文章，问题的other（列）表示主题为未列出的其它问题可被归为对应”新领域“的文章。而落入“other领域-other问题”中的文章，是讨论其它技术领域的其它问题的文章，或者是完全不符合上述特征的、极具想象力的文章。</p>
<h3 id="2-_结论">2. 结论</h3><p><strong>结论一：热门领域有这些</strong></p>
<p>上面给出的“新领域－老问题矩阵”中，深色和浅灰色部分分别给出了热门研究领域和热门研究问题。其中热门领域包括：flash、GPU/GPGPU、NVM、并行／分布式／云计算、多核／众核、事务内存、CPU和微体系结构、数据中心、文件系统／存储系统、异构计算、新的存储技术、加速器、互连网络／片上网络、模糊计算、可重构硬件、虚拟化、移动计算、物联网。热门研究问题包括：安全性、可靠性、功耗、缓存、并发一致性、QoS／资源分配、性能、内存管理、I/O、反冗余、冷却。当然，“other领域-other问题”一格中还有一些讨论其它主题的论文，由于在本调研中这些论文研究的主题出现仅一次，暂时认为其不具备“热门”特征的。</p>
<p>如果把“新领域－老问题矩阵”中每一格内容由原来的论文编号替换成格子中包含的论文数量，那么可以得到“新技术－老问题计数矩阵”。</p>
<center><br><img src="/img/new_tech_old_problem_count.png" alt=""><br></center>

<p>计数矩阵的最右列是以该“新领域”为研究主题论文数量的总计。同样，最后一行是以每个“老问题”为讨论主题论文数量的总计。我们很容易发现，讨论激烈的新领域集中在Flash、GPU/GPGPU、NVM、并行／分布式／云计算、事务内存、CPU／微体系结构。研究问题集中在安全／可靠性、功耗方面。</p>
<p><strong>结论二：以“新技术－老问题”为主题的研究较普遍</strong></p>
<p>根据新技术－老问题计数矩阵，我绘制了下图：</p>
<center><br><img src="/img/surface.png" alt=""><br></center>

<p>图中，横轴、纵轴与矩阵的行、列对应，分别表示新技术／热门领域和共性问题。锥形的高度表示相应“新领域－老问题”论文的数量。从图中可以看出，靠近坐标轴的other部分相对突出（对应矩阵的深色和浅灰色部分），但中间部分也占据相当分量（对应矩阵白色部分）。这表明“新技术－老问题”为主题的研究较普遍。研究者会在新兴的技术被提出后，联系之前自己的研究经历，使用一些经典评价指标和通用分析方法去评价新技术，如果存在问题，那么着手研究解决方案。我们看到研究相对集中的几个热门领域，如：Flash、GPU/GPGPU、NVM、并行／分布式／云计算、事务内存、CPU／微体系结构，与相对集中的几个热门研究问题，如：安全／可靠性、功耗，两者交织情况十分显著。</p>
<h3 id="3-_启发">3. 启发</h3><p><strong>启发一：围绕矩阵发掘研究主题</strong></p>
<p>研究过程得到的新领域－老问题矩阵，不仅仅定位了2016年体系结构领域的的研究前沿热点，还提供了一些启发：这个矩阵作为一种文献主题归类方式和分析方法，可以被用来分类、理解其它论文的研究内容。更重要的是，它可以被用来挖掘潜在的研究主题。</p>
<p><strong>启发二：基准 -&gt; 新设计， 特征 -&gt; 新设计</strong></p>
<p>在分析文章的过程中，我发现部分文章的工作集中在提出了一种新的基准 (benchmark)，并利用自己的基准去评价现有系统，发现系统不足，接着提出改进方案或是新的设计。这意味着，提出一种新的基准，可以作为研究的一个可能的起点。另一个起点可能是特征分析。调研过程中浏览的一些文章开始于系统、应用场景特征的分析。得到特征分析结果后，再针对性地提出改进或新的设计。</p>
<p><strong>启发三：合作</strong></p>
<p>被分析的论文中，有大量工作是由多个研究机构共同完成的，体现出科研领域合作的重要性。值得一提的是，大量的合作来自大学和工业界共同建立。如Google和德州大学奥斯汀分校、耶鲁大学和多伦多大学有良好的合作。在它们合作的文章中，Google不仅积极参与研究，同时提供了真实应用环境。这样的结合，提升了学术成果实用价值，加速了技术到市场的转换效率。国内，华为公司跟一些学术机构也保持同样的合作关系。</p>
<h3 id="4-_未来工作">4. 未来工作</h3><p>由于时间有限，本工作调研的文章数量极为有限，通过增加会议数量会使得热门领域的判断更加准确且完备。如果能扩展调研论文的发表年份，会为结论增加时间维度，得到热门领域的变迁关系。</p>
<p>本文是按照CCF推荐列表展开调研的，而从实验室角度展开调查或许是另一个增强结论、发现新结论的方法。具体说，可以从国际上影响力较大实验室的项目和发表论文中获取一些信息，分析研究主题，有可能得到一些有意思的结论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>2016年计算机体系结构领域研究热点有哪些？为回答这个问题，本文分析了2016年CCF推荐会议中124篇关于计算机体系结构的前沿论文，对其研究主题进行分类和统计，归纳出了“新领域－老问题矩阵”。本文记录了这个矩阵的构成，以及通过这个矩阵得到的一些有意思的发现。</p>
</blockquote>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[听说你是搞计算机的，你会修电脑吗]]></title>
    <link href="http://yoursite.com/2016/10/30/you-are-it-guy-so-can-you-fix-this/"/>
    <id>http://yoursite.com/2016/10/30/you-are-it-guy-so-can-you-fix-this/</id>
    <published>2016-10-30T05:53:32.000Z</published>
    <updated>2016-10-30T06:18:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/xiaoguotu.jpg" alt=""></p>
<a id="more"></a>
<p>今天早上来到实验室，坐下看了半小时书。大表姐突然发来微信，问我会不会做室内效果图。奇怪，我的微信不是退出后台了吗？</p>
<p>“好搞笑啊，我会计算机就能上天啊！”</p>
<p>我知道我不能这样说，因为别人会反问：那你计算机都是学得啥东西，怎么这也不会那也不会！这时我就要跟他们解释什么是<del>面向E级高性能计算机的新型互联网络和</del>计算机编程，解释计算机学科的目标和使命，解释为什么PHP是世界上最好的语言。</p>
<p>所以我当机立断地回答表姐：让我学习着做一下！</p>
<p>之前看到网上很多自称程序员的人在嘲笑“听说你搞计算机的，你会修电脑吗”这个问题:搞计算机和修电脑有关系吗。其实我觉得这个问题真是问对人了——搞计算机的人应该都会修电脑吧。你在debug的过程中俨然成为了训练有素的问题解决专家：解决问题的基本思路、读文档的耐性、查log的敏锐、驾驭搜索引擎的能力等等已经融在了血液里。</p>
<blockquote>
<p>“所以我不会修电脑还能不能当程序员了？”</p>
</blockquote>
<p>就算修硬件你无能为力，就算PS、Pr、3Ds Max跟你在做的项目和研究半毛钱关系都没有，但你可能也是他们身边距离这些技术最近、最有“背景”的人了，是他们唯一可以依靠的人（还是又是我想太多:p）。你做一件这样的事可能需要耗费半个小时，对于他们可能就得花一个星期。</p>
<p>害怕没有成为大神就先学会了高冷，希望能凭借自己的能力给身边人些许安全感，不过也请大家像我尊重我的时间那样尊重我的时间。</p>
<p>意外发现，做效果图还是蛮好玩的！很开心又增加新业务！</p>
<center><img src="/img/xiaoguotu_end.jpg" alt=""></center>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/xiaoguotu.jpg" alt=""></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[理解mmap]]></title>
    <link href="http://yoursite.com/2016/10/20/understanding-mmap/"/>
    <id>http://yoursite.com/2016/10/20/understanding-mmap/</id>
    <published>2016-10-20T10:38:30.000Z</published>
    <updated>2016-10-20T10:59:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="mmap普通文件">mmap普通文件</h2><p>小时候，我以为mmap就是用来把磁盘上的文件加载到内存中，是除了read/write系统调用外，读写文件的另一种方式。使用read/write系统调用读写文件时，我们需要提供一个指针，表明我们需要读写文件的位置。同时需要指明内存缓冲区的地址及其大小，来让read把文件的某一部分存进缓冲区，或是让write把缓冲区的数据写进文件的指定位置。如果使用mmap，系统会把整个文件一次性读取到内存中（对用户来说是一次性，但实现时可以使用缺页异常的方法按需读取，该操作对用户透明）。这段内存就成了磁盘中文件的映像，操作系统会把我们对这片内存的操作，同步到磁盘上。对于用户来说，操作这片内存就是在操作文件。</p>
<a id="more"></a>
<h2 id="mmap设备文件">mmap设备文件</h2><p>后来，当我看到设备文件也能被mmap到内存中，我开始尝试理解mmap这个称谓的由来—— 原来 memory map，就是把一段memory映射到其它memory空间的过程！设备驱动的作者通过书写自己的mmap回调函数，就可以引导操作系统把设备上的存储空间映射到进程虚拟地址空间上。对于用户来说，操作这片内存，就是在操作设备（上的存储器）。</p>
<h2 id="“统一”的混乱">“统一”的混乱</h2><h3 id="回头再看mmap普通文件错误但深刻的理解">回头再看mmap普通文件错误但深刻的理解</h3><p>回想mmap把磁盘上的文件加载到内存的过程，和mmap设备文件的过程竟是完美统一的—— 感谢“一切皆设备”的unix理念！其实不仅设备文件本身也是文件，而且存储文件的磁盘也是设备。这样一来，mmap普通文件，是不是就是在mmap磁盘上某个文件占用的设备memory呢？当设备是可直接访存(如NVDIMM盘)的情况下也许想法是正确，但多数情况下不是这样的。为什么呢？</p>
<p>因为mmap的目的就是想把对设备memory的操作抽象成对内存的操作。如果CPU没有办法直接寻址设备的memory，那么mmap本身是没有意义的。</p>
<p>不幸的是，我们常见的机械硬盘、SSD啥的都没有把存储单元暴露给CPU，所以文件就得先读到内存中，再对内存进行操作，最后同步回设备。相比于直接操作SSD上的存储颗粒，这种做法是不是有一种“缓冲”的意思呢？</p>
<h3 id="mmap块设备自身">mmap块设备自身</h3><p>一切皆设备的unix设计的大一统理念虽然完美，不过可能会造成一点混乱…… 除了上面说的：错误地认为mmap普通文件就是mmap磁盘上某个文件占用的设备memory，下面谈谈另一个疑虑——mmap一个磁盘块设备自己（块设备文件）会出现什么情况，跟我mmap这个磁盘块设备上的普通文件，有什么不同？</p>
<p>我们可以尝试写一个简单的例子看看mmap块设备文件会发生啥情况：</p>
<pre><code>filp = fopen(“/dev/sda”, “r")<span class="comment">;</span>
fd = fileno(filp)<span class="comment">;</span>
buf = mmap(NULL, SIZE, PROT_READ, MAP_PRIVATE, fd, 0)<span class="comment">;</span>
for (i=0<span class="comment">; i&lt;SIZE; i++)</span>
     printf(“%x”, buf[i])<span class="comment">;</span>
munmap(buf, SIZE)<span class="comment">;</span>
fclose(filp)<span class="comment">;</span>
</code></pre><p>输出结果（部分）：</p>
<pre><code><span class="number">63</span>eb1090ffffd08ebcffffb8b00ffffd88effffc08effffbefb7c00bfffffb906200ffffa4f321ea6ffffbe00
<span class="number">7</span>be438b75ffffc683ffff8110fffffefe7507ffffebf3ffffb416ffffb002ffffbb017c00ffff80b2748affff
...
</code></pre><p>再看看磁盘头一个扇区的数据（部分）：</p>
<pre><code>eb63 <span class="number">9010</span> <span class="number">8</span>ed0 bc00 b0b8 <span class="number">0000</span> <span class="number">8</span>ed8 <span class="number">8</span>ec0
fbbe <span class="number">007</span>c bf00 <span class="number">06</span>b9 <span class="number">0002</span> f3a4 ea21 <span class="number">0600</span>
...
</code></pre><p>忽略读数据时大小端的影响，是不是同一个东西？实验说明，mmap一个块设备文件，就相当于把整块磁盘给mmap了（而不是胡思乱想的什么mmap磁盘控制器页面啦、什么设备上的缓冲区啦等等高级的东西！）。这个mmap跟磁盘上的具体文件系统无关（所谓绕过文件系统），而是把磁盘作为一个超级大的、数据块都是连续的文件给mmap进虚拟内存了。相反看mmap磁盘块设备上的一个普通文件，是跟磁盘上的文件系统息息相关的——这个mmap操作本身就是在这个文件系统提供的。mmap普通文件的数据块在磁盘上不一定是连续的，需要文件系统给出了索引数据块的方法。</p>
<p>扩展阅读：</p>
<p><a href="http://hemming.blog.hexun.com/15094457_d.html" target="_blank" rel="external">malloc背后的故事</a>mmap在进程内存分配中扮演的角色及其它一些与文件相关的系统调用。</p>
<p><a href="http://alanwu.blog.51cto.com/3652632/1288838" target="_blank" rel="external">一个IO的传奇一生</a> 介绍了mmap块设备文件和普通文件的区别。不止于此，这个系列对文件系统和块设备IO有总结性的讲解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="mmap普通文件">mmap普通文件</h2><p>小时候，我以为mmap就是用来把磁盘上的文件加载到内存中，是除了read/write系统调用外，读写文件的另一种方式。使用read/write系统调用读写文件时，我们需要提供一个指针，表明我们需要读写文件的位置。同时需要指明内存缓冲区的地址及其大小，来让read把文件的某一部分存进缓冲区，或是让write把缓冲区的数据写进文件的指定位置。如果使用mmap，系统会把整个文件一次性读取到内存中（对用户来说是一次性，但实现时可以使用缺页异常的方法按需读取，该操作对用户透明）。这段内存就成了磁盘中文件的映像，操作系统会把我们对这片内存的操作，同步到磁盘上。对于用户来说，操作这片内存就是在操作文件。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux如何操作设备中的存储器？]]></title>
    <link href="http://yoursite.com/2016/10/07/io-memory/"/>
    <id>http://yoursite.com/2016/10/07/io-memory/</id>
    <published>2016-10-07T10:52:35.000Z</published>
    <updated>2016-10-11T02:00:04.000Z</updated>
    <content type="html"><![CDATA[<p>对设备的操作实际上是通过读写设备中的memory或者register来完成的。操作方式有两种：I/O ports操作方式和I/O memory操作方式。前者存在于部分体系结构中，通过专门的IO指令(in/out)来实现。后者不需要特殊指令，允许我们像操作内存那样操作设备memory或者register，并可以封装前者，更为简单也更流行。这里我们讨论I/O memory的操作方式。在I/O memory操作方式下，设备中的memory或register被称作I/O memory[1]。那么Linux是如何操作I/O memory的呢？</p>
<a id="more"></a>
<p><img src="/img/io_memory_mapping.png" alt=""></p>
<p>如图所示，这个映射分为两部分。I/O memory首先要从设备视角下的局部内存地址空间映射到物理内存地址空间，主要由硬件完成。因为Linux工作在保护模式下，该模式下的CPU识别的是虚拟地址，物理内存地址并不能被直接使用，因此需要进一步地将物理地址空间映射到虚拟地址空间中去。</p>
<h2 id="地址空间的概念">地址空间的概念</h2><p>有必要解释“地址空间(address space)”这一概念：地址空间就是能看到的存储器范围。地址空间的大小不由具体存储器的容量决定，而是指CPU或其它控制器能访问到的存储器单元的范围，由电路的“位“来决定。例如32位的CPU的地址空间（不论虚拟的地址空间或是物理的地址空间）通常情况下就是0~4G(2^32)，即使内存只有1G。如果为32位CPU配上8G的内存条，超出了地址空间的4G存储单元就无法被CPU直接访问。</p>
<p>通过读取/proc/iomem可以查看物理地址空间的映射情况。</p>
<pre><code><span class="number">00000000</span>-<span class="number">00000f</span>ff : reserved
<span class="number">00001000</span>-<span class="number">0009</span>d7ff : System RAM
<span class="number">0009</span>d800-<span class="number">0009f</span>fff : reserved
<span class="number">000</span>a0000-<span class="number">000</span>bffff : PCI Bus <span class="number">0000</span>:<span class="number">00</span>  &lt;- PCI设备内存
<span class="number">000</span>c0000-<span class="number">000</span>cefff : Video ROM          &lt;- 显存
<span class="number">000e0000</span>-<span class="number">000f</span>ffff : reserved
  <span class="number">000f</span>0000-<span class="number">000f</span>ffff : System ROM       &lt;- BIOS
<span class="number">00100000</span>-bac8efff : System RAM
  <span class="number">01000000</span>-<span class="number">0173</span>ebc8 : Kernel code
  <span class="number">0173</span>ebc9-<span class="number">01</span>d1e9ff : Kernel data
  <span class="number">01e77000</span>-<span class="number">01f</span>e0fff : Kernel bss
bac8f000-bacacfff : reserved
bacad000-bacb8fff : ACPI Non-<span class="keyword">volatile</span> Storage
......
</code></pre><p>这个列表把物理地址空间的分布暴露得一丝不挂，以至于让Linus失去了安全感。但是鉴于部分应用(如kdump组件)依赖这些信息，所以这些信息目前依旧保留着。炫耀一下我是如何从Linus手中拯救出kernel code/data/bass段信息的 :P</p>
<p><img src="/img/save_iomem.png" alt=""></p>
<h2 id="从设备局部内存地址空间到物理地址空间的映射">从设备局部内存地址空间到物理地址空间的映射</h2><p>再次观察上面/proc/iomem文件的内容，我们发现物理地址空间对应的真实存储器不仅仅内存条上的存储单元，还有很多其它设备上的存储器（例如BIOS、显存等）。这些设备存储器是怎么“拼接”上去的呢？这就是从设备局部内存地址空间到物理地址空间的映射。</p>
<p><img src="/img/address_space.png" alt=""></p>
<p>这个映射主要是硬件完成的：在计算机早期时代，连接到计算机上后就只能映射到某一位置。这个位置是硬件设计时固定下来的。由于地址空间有限，而设备种类繁多，要使设备占用的地址空间不发生冲突就得为每种设备分配固定位置。这种做法显然不合适。后来，人们为了解决这个问题，把一些类型的设备映射到物理地址空间的位置设计成可以配置的，如PCI设备。为了做到可配置，PCI设备引入了配置空间。配置空间实际上是一系列的寄存器硬件。想要查看设备配置空间的状态，可以使用下面的命令查看导出到用户空间的映像[2]：</p>
<pre><code>zhangzy@huawei17:~$ lspci | grep VGA
<span class="number">07</span>:<span class="number">00.0</span> VGA compatible controller: Device <span class="number">19e5</span>:<span class="number">1711</span> (rev <span class="number">01</span>)
zhangzy@huawei17:~$ xxd /sys/bus/pci/devices/<span class="number">0000</span>\:<span class="number">07</span>\:<span class="number">00.0</span>/config
<span class="number">0000000</span>: e519 <span class="number">1117</span> <span class="number">0700</span> <span class="number">1000</span> <span class="number">0100</span> <span class="number">0003</span> <span class="number">0000</span> <span class="number">0000</span>  ................
<span class="number">0000010</span>: <span class="number">0800</span> <span class="number">0094</span> <span class="number">0000</span> <span class="number">6096</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  ......`.........
<span class="number">0000020</span>: <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span>  ................
<span class="number">0000030</span>: <span class="number">0000</span> <span class="number">0000</span> <span class="number">4000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0701</span> <span class="number">0000</span>  ....@...........
</code></pre><p>下面我们验证config文件里的这些内容就是配置空间的映像。我们知道/proc/iomem里面存放了内存布局（物理地址空间布局），而配置空间的第0x10个字节往后都是基地址，也即映射到物理地址空间后的首地址。以第一个基址0x94000000为例，我们可以在iomem里找到对应的条目——它正是0000:07:00.0VGA设备！</p>
<pre><code>zhangzy@huawei17:~$ cat /proc/iomem | grep <span class="number">9400</span>
  <span class="number">94000000</span>-<span class="number">95f</span>fffff : PCI Bus <span class="number">0000</span>:<span class="number">07</span>
    <span class="number">94000000</span>-<span class="number">95f</span>fffff : <span class="number">0000</span>:<span class="number">07</span>:<span class="number">00.0</span>
      <span class="number">94000000</span>-<span class="number">9412f</span>fff : vesafb
</code></pre><p>配置空间本质上是一组寄存器，可以在CPU发送的命令（x86的IO指令）控制下进行读写。相反，真正的 I/O memory一开始并不能被访问——直到配置完成。完成整个配置动作的是BIOS，准确说是BIOS中的固件中的代码。BIOS固件代码基本是不开源的；不过好消息是，由于不是所有架构平台都有BIOS，所以跨平台的Linux也支持亲力亲为的配置方式（本质上没差别，因为配置指令由CPU发出，而CPU并不关心这条指令来自固件还是内存中的内核代码）。所以好奇的读者可以阅读Linux内核相关源代码学习配置的具体过程，这部分内容Linux称之为resource(地址空间也是有限的资源！它的大小受总线位数限制)的管理。现在我们恍然大悟，原来/proc/iomem里的内容的来源就是这些resource呀！</p>
<h2 id="物理内存到虚拟地址空间的映射">物理内存到虚拟地址空间的映射</h2><p>因为Linux工作在保护模式下，该模式下的CPU识别的是虚拟地址，因此物理内存地址并不能被直接使用。将物理地址映射到虚拟地址的机制就是大名鼎鼎的页表机制。我们需要在页表中建立新的表项，让MMU把某些个虚拟地址和物理地址的某些个单元挂上钩完成第二级映射。我们刚刚了解到，到物理地址空间的映射由BIOS或内核完成，而这里利用页表完成的映射是由谁完成呢？当然是驱动啦，因为只有它对硬件的详细信息一清二楚，也只有它需要知道这个映射得到的虚拟地址。</p>
<p>修改个页表机制并没有那么简单，好在内核提供了一个高层次的API函数可以帮助我们建立映射：</p>
<pre><code><span class="keyword">void</span> __<span class="function">iomem * <span class="title">ioremap</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> offset, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span>
</code></pre><p>参数offset是需要映射的物理地址，size是这段物理地址的大小。返回值是映射到的虚拟地址。这样，整个映射过程全部完成，内核可以使用ioremap返回的地址对I/O memory进行读写了。</p>
<pre><code>(<span class="keyword">char</span> *) addr = <span class="number">0x00</span>;
</code></pre><p>注意上面的访存方式可以在x86平台上使用。但考虑到跨平台，linux内核建议使用：</p>
<pre><code>writeb(<span class="number">0x00</span>, addr);
</code></pre><p>是不是封装得很好呢？用起来是不是很爽快呢？不过，上述代码只能在内核中使用，如果在用户空间使用上述代码访存，你得到的可能就是错误哦！</p>
<h2 id="用户空间直接读写I/O_memory">用户空间直接读写I/O memory</h2><p>ioremap是将物理地址映射到了虚拟地址空间，但虚拟地址空间又分为进程虚拟地址空间和内核虚拟地址空间…… 因为特权级保护的原因，用户进程是不能读写后者哒。不幸的是，ioremap映射到的正是内核虚拟地址空间。</p>
<p>我们知道操作系统内核是计算机软硬件资源的管理者。我们自己写的一些用户空间程序一般需要借助内核提供的接口(系统调用 or IOCTL)去访问设备，而不是自作主张去直接操作硬件。但有时候，为了提高性能，我们可能需要绕过操作系统这个管家亲自操作硬件。</p>
<p>那么我们要怎么做才对呢？答案：mmap[3]。我们需要在驱动程序中提供mmap方法，并在方法的实现中调用下面的函数帮助应用程序完成第二级映射——把I/O memory映射到的物理内存映射到自己的进程虚拟地址空间：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, \
                            <span class="keyword">unsigned</span> <span class="keyword">long</span> addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn, \
                            <span class="keyword">unsigned</span> <span class="keyword">long</span> size, pgprot_t prot)</span></span>
</code></pre><p>其中vma参数表示进程虚拟地址空间的一个段，是映射的目的地。addr参数是这个段的首地址（虚拟地址）。参数pfn是page frame number，用来索引待映射的物理内存的页。在本文所描述的情况下，这段物理页其实就是上面把I/O memory从设备局部内存地址空间映射出来得到的物理页。size表示映射区域的大小，prot是一些内存保护标志。</p>
<p>这样，用户空间程序mmap完与设备相关的设备文件，就可以在I/O memory上为所欲为了。</p>
<h2 id="小结">小结</h2><p>为了访存设备memory或register，即I/O memory，我们需要建立两级映射：</p>
<pre><code><span class="comment">设备局部内存地址空间</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">kernel/BIOS</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">物理地址空间</span> <span class="comment">—</span><span class="literal">-</span><span class="comment">ioremap</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">内核虚拟地址空间</span>
</code></pre><p>如果想要用户空间程序直接具备访存I/O memory的能力，我们需要完成如下映射：</p>
<pre><code><span class="comment">设备局部内存地址空间</span> <span class="literal">-</span><span class="comment">—kernel/BIOS</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">物理地址空间</span> <span class="comment">—</span><span class="literal">-</span><span class="comment">mmap</span><span class="literal">-</span><span class="literal">-</span>&gt; <span class="comment">进程虚拟地址空间</span>
</code></pre><h2 id="参考">参考</h2><p>J. Corbet, A. Rubini, Greg K.H.. Linux Device Driver, 3rd Edition. O’Reilly Media, Inc., 2005. 其中的三章：</p>
<p>[1] <a href="http://www.oreilly.com/openbook/linuxdrive3/book/ch09.pdf" target="_blank" rel="external">http://www.oreilly.com/openbook/linuxdrive3/book/ch09.pdf</a></p>
<p>[2] <a href="http://www.oreilly.com/openbook/linuxdrive3/book/ch12.pdf" target="_blank" rel="external">http://www.oreilly.com/openbook/linuxdrive3/book/ch12.pdf</a></p>
<p>[3] <a href="http://www.oreilly.com/openbook/linuxdrive3/book/ch15.pdf" target="_blank" rel="external">http://www.oreilly.com/openbook/linuxdrive3/book/ch15.pdf</a></p>
<blockquote>
<p>致谢：感谢刘洪亮、郝天舒两位同学在国庆期间将工位借我让我舒舒服服地写完此文。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>对设备的操作实际上是通过读写设备中的memory或者register来完成的。操作方式有两种：I/O ports操作方式和I/O memory操作方式。前者存在于部分体系结构中，通过专门的IO指令(in/out)来实现。后者不需要特殊指令，允许我们像操作内存那样操作设备memory或者register，并可以封装前者，更为简单也更流行。这里我们讨论I/O memory的操作方式。在I/O memory操作方式下，设备中的memory或register被称作I/O memory[1]。那么Linux是如何操作I/O memory的呢？</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/categories/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设备驱动 - Linux Device Driver Model]]></title>
    <link href="http://yoursite.com/2016/09/01/device-driver-linux-device-driver/"/>
    <id>http://yoursite.com/2016/09/01/device-driver-linux-device-driver/</id>
    <published>2016-09-01T03:28:54.000Z</published>
    <updated>2016-09-01T05:27:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>理解device driver model，我觉得最难的就是“忘掉自己曾经知道的”。学习内核很多情况下都需要这项技能：忘掉自己知道的，我们才不至于望文生义想当然，才能去接纳新知识，才能够耐着性子去阅读思考，才会更关注“为什么要这样呢”。所以如果刚接触Linux内核的你对设备驱动存在些许认识或者幻想，现在都请忘了吧。文中出现的术语如device、driver等，为了避免想当然，一开始都请把它当成一个名字而已，不要试图猜测其语义，也最好不要翻译成中文（所以请原谅文中的中英文混杂）。当我们理解了以后再看这些术语，我们就会恍然大悟它们为什么叫这个名字了。</p>
<a id="more"></a>
<h2 id="Device_Driver_Model的组成部分">Device Driver Model的组成部分</h2><p>这一节我们介绍Device Driver Model的组件：device、driver、bus和class。为什么要使用这些组件（本质上是数据结构）乃至为什么要使用Device Driver Model？网上有人总结得很精辟：统一了编写设备驱动的格式，使驱动开发从论述题变为填空体，从而简化了设备驱动的开发[1]。</p>
<h3 id="kobject——骨架">kobject——骨架</h3><p>我阅读的关于Device Driver Model的资料一般都会在一开始介绍kobject，然而并没有告诉我们为什么要了解kobject。对熟悉面向对象编程概念的读者来说，一言以蔽之：kobject是device driver model中所有组件的基类，是模型的骨架，因此非常重要。如果对面向对象的概念不熟悉也不要紧，下面具体介绍为何我们需要kobject。</p>
<p>Device Driver Model是一种”类树状”的模型——本质上它是一张网，但大体上是树的形态。它把所有组件对象组织成树，然后又用符号链接在树上构建一些新的关系。一个简单的示意图如下：</p>
<p><img src="/img/device_model_tree_1.png" alt="device_model_tree_1"></p>
<p>为了表示这个关系，内核使用了kobject数据结构，利用kobject包含的parent、children、sibling等域对关系进行描述。</p>
<p>kobject的另外一个重要作用就是对各组件对象的引用进行计数。计数的好处在于可以保证资源会在合适的时候被释放。</p>
<p>不过kobject自身功能有限，仅仅能构建出一个关系骨架。事实上内核里通常并不直接使用这个数据结构，而是选择将kobject嵌入到真正完成动作的、更复杂的数据结构里，例如下面即将讨论的Device Driver Mode组件——device、driver、bus和class。Device Driver Model中的树形结构更精确的示意图如下：</p>
<p><img src="/img/device_model_tree_2.png" alt="device_model_tree_2"></p>
<p>后面我们会专门介绍所谓的“kobject嵌入到真正完成动作的、更复杂的数据结构”：device、driver等。现在我们介绍与kobject相关的另外两个数据结构：kset和ktype。</p>
<p>简言之，kset是盛放kobject的容器。从sysfs文件系统角度解释就是：一个kobject对应sysfs的一个目录（kobject属性对应其中的文件）。为了使sysfs结构层次化，需要建立高层次的目录去容纳kobject对应的目录，这些高层次的目录就是kset对应的目录。</p>
<p>ktype数据结构表示kobject的类型。它事实上是一组数据结构：kobj_set、kset_ktype等等。光看名字也不知道到底是什么，但我们还是尝试解释一下问什么起这个名字:ktype主要是定义一些针对kobject对象的操作。一类对象共享一组操作，取名ktype可能就是出于这个考虑吧。</p>
<h3 id="driver——描述驱动的数据结构">driver——描述驱动的数据结构</h3><p>注意的是driver本身不是驱动，它只是描述驱动的结构。下面我们用英文driver代表描述驱动的数据结构，中文“驱动”或“设备驱动”代表真正控制设备的驱动程序逻辑。后续的“device－设备”、”bus－总线“等也基本满足这个规则。</p>
<p>另外需要了解，驱动程序逻辑并不一定要有driver这一套东西。驱动逻辑本质上就是内核空间的一系列的回调函数（熟悉内核的读者已经知道这些回调函数具体是文件系统的fops函数指针），实现方法不一而足。但还记得吗？我们的device driver model就是为了统一驱动开发设计的，所以要使自己开发的驱动符合规范，就尽可能使用device driver model，所以还是为自己的驱动加上driver这一套吧！</p>
<h3 id="device——描述设备的数据结构">device——描述设备的数据结构</h3><h3 id="bus——描述总线的数据结构">bus——描述总线的数据结构</h3><p>仔细观察这些数据结构我们会发现，driver和device都有一个域指向bus，bus中也有两个链表保存所有与之相关的driver和device。所以它们三者关系是这样的: 每个device都隶属于一个bus，表示连接在这个bus上的设备。每个driver也隶属于一个bus，表示它是可以驱动这个bus上某一设备的驱动。bus保存着这些device和driver，这样就可以在插入新driver模块时匹配那些没有被驱动的device，也可以在加入新device时匹配相应的driver。这里的匹配就是遍历这两个链表。具体过程见下文。</p>
<h3 id="class——描述应用层视图的数据结构">class——描述应用层视图的数据结构</h3><h2 id="设备文件">设备文件</h2><p>让我们离开水深火热的内核来到应用层：我们作为用户在使用设备时并没有考虑到上文中描述的种种，而是通过“设备文件”这一简单接口轻松使用各类设备。在linux设计理念中，“一切皆文件”。设备也往往被抽象成一种特殊文件——“设备文件”。关于这个理念的理解，请参考拙作<a href="http://freemandealer.github.io/2016/06/04/device-driver-in-a-nutshell/" target="_blank" rel="external">设备驱动 in a nutshell</a>。</p>
<p>在这里，我们解释设备文件是如何关联上对应设备的。首先介绍系统调用mknod：</p>
<pre><code>mknod -- <span class="keyword">make</span> device special <span class="keyword">file</span>
</code></pre><p>mknod应用程序的mannul中如是说。它的功能就是用来创建设备文件——再详细一些，就是在目标文件系统树中创建一个表示设备文件的节点。一般我们将设备文件保存在/dev/目录下，但在其它目录中创建设备文件也是允许的。作为应用程序，或是系统调用，mknod的主要参数有两个：主设备号和次设备号。例如我们可以在当前目录创建设备文件freeman:</p>
<pre><code>&gt; mknod freeman c <span class="number">12</span> <span class="number">21</span>
&gt; ls
&gt; crw-r--r--  <span class="number">1</span> root     wheel   <span class="number">12</span>,  <span class="number">21</span>  <span class="number">8</span> <span class="number">22</span> <span class="number">15</span>:<span class="number">36</span> freeman
</code></pre><p>这就创建了一个主设备号为12，次设备号21的字符设备（’c’表示字符设备）。我们可以尝试对该设备文件进行读写，发现操作总是不成功，提示“没有写权限”或是“设备尚未配置”——当然，我们的设备文件目前只是一个空壳，还没有关联上正真的设备。如何将两者关联上呢？</p>
<p>一个设备的设备号分为两类：主设备号和次设备号。前者表示设备的型号：如果两台设备型号相同，那么它们就有相同的主设备号，相同的设备当然可以使用同一驱动。那么如何分清两台型号相同的设备呢？这就需要用到次设备号。</p>
<p>既然驱动是和主设备号一一对应的，那么内核就可以根据mknod创建设备文件中的主设备号关联上设备驱动程序，从而关联上设备。具体过程如下：同操作普通文件一样，操作设备文件前需要open设备文件。这个open运行过程中了解到需要打开的文件是设备文件，那么它会去拿着设备号去搜索驱动。如果有幸对应驱动曾经被注册过，那么搜索过程必将成功结束。一旦找到对应驱动，就会将设备文件的fops赋值为驱动提供的fops。这个fops是个文件操作集合(file operations)的缩写，其中定义了包括read、write在内的各种文件操作在内核中的实现。例如我们读设备文件，最终就会调用对应驱动程序中定义的read操作——设备文件知道了自己该如何处理各种文件操作。这样从用户角度看，通过操作设备文件就可以为所欲为地操作底层设备了。</p>
<p>从2.6内核之后，设备节点就可以通过udev－uevent机制自动创建了。原理实际上并没有什么不同：原来需要手动输入的主次设备号现在由sysfs自动提供，通过class_create和device_create函数往sys文件系统中添加设备，udev检测到/sys目录的变动会根据变化在/dev目录下创建对应的设备节点[2]。</p>
<h2 id="Put_Them_Together">Put Them Together</h2><p>这一节我们尝试回答一个问题：从设备接入计算机到一切就绪，中间到底发生了什么？在回答这个问题之前，我们先来看一看LDD3的问题。LDD3是专门讲解Linux设备驱动程序设计的经典书籍，LDD3的读者应该还记得书中的第一个例子——简单字符设备scull<a href="https://github.com/martinezjavier/ldd3/tree/master/scull" target="_blank" rel="external">(代码在此)</a>。仔细研究scull的代码我们发现上文中提到的知识几乎一个也没体现——scull注册了一个cdev结构就结束了！（可能有人怀疑cdev会嵌入一个device结构体，事实上并没有！）这正是linux设计的巧妙之处：如果一个驱动开发者想做快速开发，他完全可以使用一组上层API来完成工作而不用清楚了解底下到底发生了什么。cdev就是一个高层次的封装，可以认为它是VFS(Virtual Filesystem)层面的结构，并不是device driver model的组件。所以从scull中，以及LDD3前面的其它几个例子中，看不到device driver model的影子，读者也不必惊慌，LDD3在后面有整整一章介绍了device driver model。</p>
<p>LDD3的问题不仅在于层次高，还在于它使用了“虚拟设备”做例子。LDD3为了不让准备实验材料的过程给读者造成障碍，并没有以实际硬件设备为例，而是选择把一段内存虚拟成设备进行操作（感谢LDD3的良苦用心）。这个方法在大部分情况下工作得非常好，但是在体会设备模型时却成了阻碍。我们分析阻碍的成因：用内存虚拟出的设备和真实设备的区别在于，内存是一直存在于系统中，没有一个“插在电脑上”的过程。所以LDD3例子的逻辑就是：</p>
<pre><code>模块初始化中初始化设备
</code></pre><p>而知道真相后，我们看到真实的故事远比这个复杂：</p>
<pre><code>模块初始化中注册driver
新driver加入系统后，<span class="keyword">bus开始为之匹配它可以驱动的device </span>(<span class="keyword">bus的match操作)
</span>新device加入到系统后，<span class="keyword">bus开始为之匹配driver </span>(<span class="keyword">bus的match操作)
</span><span class="label">driver</span>开始probe device，probe被认为是驱动程序的入口，会完成初始化设备的任务
</code></pre><p>我们看到，不管driver还是device加入系统，都会引起相关bus的match操作。这样可以保证不论driver先加入系统还是device先加入系统，device driver model都能很好地工作。如果device先加入系统，那就像买了一台超级复杂的机器(device)，翻箱倒柜找不到配套的说明书(driver)，需要等对方把说明书邮过来。如果XXX的说明书先到，那就把家里的机器都翻出来对一遍，发现没有名叫XXX的机器，那么就等着京东把XXX机器发过来。</p>
<p>新driver加入到系统，一般是在用户手动加载驱动模块时（也可以由udev自动加载，请看下文），在模块初始化代码中完成的。新device什么时候加入呢？一种情况是开机初始化系统时bus枚举设备时发生的。除此之外，系统运行过程中也可以加入device：热插拔。不是所有bus都无条件地支持热插拔。常用的支持热插拔 bus有著名的USB。USB总线可以侦测新插入的设备，并由USB子系统核心向系统注册对应新的device。如果没有合适的driver去匹配这个新device，系统会借助uevent机制结合应用空间的udev组件，去加载驱动模块(有兴趣可以翻阅一下拙作：<a href="http://freemandealer.github.io/2015/05/24/hotplug/" target="_blank" rel="external">《Linux热插拔机制的介绍和应用》</a>，该文介绍了udev的应用)。小结一下：udev在device driver model中至少做两件事——自动创建设备文件节点和自动按需加载驱动模块。</p>
<p>不是说“虚拟设备”就不能体现device driver model，下面是github上的一个例子sparrow——“麻雀虽小，五脏具全”。它的device注册过程硬编码在一个模块初始化代码中，手动加载模块就可以注册device（可以认为是模拟热插拔）。</p>
<p><a href="https://github.com/wowotech/sparrow" target="_blank" rel="external">https://github.com/wowotech/sparrow</a></p>
<p>这一节的剩余部分解释一个新的问题：上述的这些动作（“注册”、“匹配”等）是谁来完成的？一个简单的回答是：总线。因为设备被连接在总线上，所以总线来完成这个任务逻辑上理所应当。</p>
<p>总线也可以被当作设备进行注册。和一般设备不同，它还有一些特殊的属性要注册，包括：match和event。这是与总线相关的driver或device被注册时需要调用的动作。为了方便和自己相关的device和driver结构的注册，总线一般会提供一些自己的注册函数封装通用的device_register/driver_register。下面是platform总线提供的两个注册函数:</p>
<pre><code>platform_device_register
     |<span class="string">-device_initialize(&amp;pdev-&gt;dev);
     </span>|<span class="string">     </span>|<span class="string">-kobject_init
     </span>|<span class="string">-platform_device_add(pdev)
          </span>|<span class="string">-device_add
               </span>|<span class="string">-kobject_add
               </span>|<span class="string">-device_create_file
               </span>|<span class="string">-device_create_file(uevent)
               </span>|<span class="string">-device_add_class_symlinks
               </span>|<span class="string">-device_add_attrs
               </span>|<span class="string">-bus_add_device
                    </span>|<span class="string">-Add device's bus attributes
                    </span>|<span class="string">-Create links to device's bus
                    </span>|<span class="string">-Add the device to its bus's list of devices
               </span>|<span class="string">-device_create_file(dev)
               </span>|<span class="string">-device_create_sys_dev_entry
               </span>|<span class="string">-kobject_uevent
               </span>|<span class="string">-bus_probe_device - probe drivers for a new device   &lt;—— 看这里
               </span>|<span class="string">-有关class的处理

platform_driver_register(xxx_drv)
     </span>|<span class="string">-drv-&gt;driver.bus/probe/remove…
     </span>|<span class="string">-bus_add_driver
               </span>|<span class="string">-loop to search and bind driver to devices     &lt;——这里
                        </span>|<span class="string">-driver_match_device                  &lt;——这里
                                </span>|<span class="string">-bus-&gt;match                   &lt;——这里
                        </span>|<span class="string">-driver_probe_device                  &lt;——这里
                                </span>|<span class="string">-driver-&gt;probe                &lt;——这里
                </span>|<span class="string">-module stuff
                </span>|<span class="string">-driver_create_file(uevent)
                </span>|<span class="string">-driver_add_groups
                </span>|<span class="string">-add_bind_files
       </span>|<span class="string">-driver_add_groups
       </span>|<span class="string">-kobject_uevent</span>
</code></pre><p>可以看到注册过程中均有上文中描述的“匹配”操作发生，以及uevent对应用层udev的通知。</p>
<h2 id="参考">参考</h2><p>[1] 蜗窝科技. Linux设备模型(1)_基本概念. <a href="http://www.wowotech.net/device_model/13.html" target="_blank" rel="external">http://www.wowotech.net/device_model/13.html</a></p>
<p>[2] 在驱动模块初始化函数中实现设备节点的自动创建. <a href="http://blog.csdn.net/zhenwenxian/article/details/5424434" target="_blank" rel="external">http://blog.csdn.net/zhenwenxian/article/details/5424434</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="写在前面">写在前面</h2><p>理解device driver model，我觉得最难的就是“忘掉自己曾经知道的”。学习内核很多情况下都需要这项技能：忘掉自己知道的，我们才不至于望文生义想当然，才能去接纳新知识，才能够耐着性子去阅读思考，才会更关注“为什么要这样呢”。所以如果刚接触Linux内核的你对设备驱动存在些许认识或者幻想，现在都请忘了吧。文中出现的术语如device、driver等，为了避免想当然，一开始都请把它当成一个名字而已，不要试图猜测其语义，也最好不要翻译成中文（所以请原谅文中的中英文混杂）。当我们理解了以后再看这些术语，我们就会恍然大悟它们为什么叫这个名字了。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[设备驱动 - in a nutshell]]></title>
    <link href="http://yoursite.com/2016/06/04/device-driver-in-a-nutshell/"/>
    <id>http://yoursite.com/2016/06/04/device-driver-in-a-nutshell/</id>
    <published>2016-06-04T11:55:55.000Z</published>
    <updated>2016-09-01T03:30:03.000Z</updated>
    <content type="html"><![CDATA[<center><br><img src="/img/device_driver_monkey.jpg" alt=""><br></center>

<a id="more"></a>
<h2 id="“一切皆文件”">“一切皆文件”</h2><p>熟悉unix的人都知道有这么一种思想：一切皆文件。设备也被抽象成文件，并有个专有名称叫“设备文件”。计算机设备种类数也数不清，每个设备都需要在操作系统中定义自己的接口，这样整个系统就混乱的不成样子了：</p>
<p>“我是硬盘，我能接收指令，也能发送数据，给我留两个系统调用hard_disk_cmd和hard_disk_data”<br>“我是串口，我能发送和接收数据，也给我留两个serial_send和serial_recv”<br>“我是一个灯泡，我能接受亮度调整的指令，给我留个light_adjust”<br>“我是个咖啡机，我能接受命令make_coffee，你可以使用ready_coffee查询咖啡是不是做好了”<br>……</p>
<p>人们想到将设备的差异封装在底层，向上层提供一个统一的接口。什么接口比较好使呢？文件系统！文件系统提供的操作十分丰富，文件读和写和IO设备的输入输出刚好对应，一些非IO的控制类操作，文件系统也提供ioctl操作与之对应。特别是linux系统提供的VFS(Virtual File System,虚拟文件系统)这一抽象，使得一切皆文件的实现更加优雅。</p>
<p>“嘿硬盘，当用户朝你对应的设备文件写数据的时候，你就自己把这些数据写到你的介质上吧”<br>“嘿串口，你也是，当用户朝你对应的设备文件读／写数据的时候，你也自己把缓冲里的内容递给系统／发出去”<br>“灯泡，如果用户往你对应的设备文件里写了一个值，你就自己根据这个值调整亮度吧”<br>“咖啡机，如果你看见我在你对应的设备文件里写了一个make，那你就开始做咖啡吧。做好了把文件内容改成ready。”</p>
<p>linux的这个框架似乎非常完美！用户不用知道设备的详细信息，就可以为所欲为地操作自己的设备。因为在用户看来，所有插在计算机上的设备都是桌面上的一个文件。可以用记事本打开查看里面的值以获取设备目前的状态。也可以往文件里写点东西，就能改变设备的状态。对设备的编程也很容易，比如我们写一个定时煮咖啡的程序（假设咖啡机的设备文件为/dev/coffee_maker）：</p>
<pre><code> #!/bin/bash
<span class="keyword">sleep</span>(<span class="number">3600</span>);
<span class="keyword">echo</span> “<span class="keyword">make</span>” &gt; coffee_maker
</code></pre><p>好了，我们编写了一个三行的咖啡机程序，它会在一个小时以后自动煮咖啡。感受到设备文件使用的方便了吗？当我们往咖啡机的设备文件coffee_maker里写”make”的时候，实际是调用了系统调用sys_write，sys_write当时是蒙圈的，它不知道自己写的文件是个咖啡机。还好sys_write不负责主要的事情，它只是跑到内核里求助VFS。VFS知道coffee_maker这个文件的底细——它不是一个普通文件，而是一个设备文件。这时，VFS就执行专属于这台咖啡机的动作——煮咖啡！那么问题来了，VFS怎么知道如何煮咖啡？</p>
<h2 id="驱动的本质：一系列的回调函数">驱动的本质：一系列的回调函数</h2><center><br><img src="/img/device_driver_hierarchy.png" alt=""><br></center>

<p>谁教会VFS煮咖啡的？答案是：驱动程序！我们都有经历，插上一个设备，但计算机似乎不知道怎么使用它。有人提醒我们：“你装驱动了吗？”</p>
<p>联系上面我们说的驱动程序，我们不难发现驱动的本质：驱动程序就是一系列的回调函数，插在操作系统上，等着VFS不知道拿设备怎么办时调用。</p>
<h2 id="“这是一个USB接口的咖啡机”">“这是一个USB接口的咖啡机”</h2><p>紧接着又一个问题：系统如何为一个插入的设备匹配对应的驱动？你端着一杯正在发光的咖啡问出这个问题，因为你怀疑系统用控制灯泡的驱动去控制咖啡机。</p>
<p>生厂商号和设备号架起了设备和驱动的桥梁。先说设备这一边：每个生产商都被赋予了一个全球唯一的生产商号，如Intel生厂商号为8086。生厂商在自己内部，又会对自己生产的设备赋予一个设备号。一般来说，生厂商号和设备号就能唯一确定一种设备。设备通过总线连接在计算机上，例如我们平常使用的U盘，使用USB(Universal Serial Bus)总线。当一个设备插上总线后，会向系统主动报上自己的名号：生厂商号和设备号。</p>
<p>再说驱动这一边：驱动在安装进系统的时候，会向系统提交一张表，报告自己的工作范围：它能管理哪些硬件。表的内容是啥呢？聪明的你已经想到了，就是驱动能够管理的硬件的生厂商号和设备号。系统把这些表汇总起来，一旦有新硬件插进来，就去查查看看哪个驱动愿意管这个设备。一旦找到了并测试通过，驱动程序就开始初始化。初始化工作最重要的一步，就是创建上文中我们大谈特谈的设备文件。至此，设备文件、驱动、设备至上而下的通道已经贯通了，用户可以为所欲为了！</p>
<blockquote>
<h2 id="一点补充">一点补充</h2><h3 id="用户态驱动">用户态驱动</h3><p>硬件资源一般是由操作系统保护起来的，只有在内核态（高特权级状态）下才能被访问，用户态的程序是没有办法直接访问的。驱动程序作为直接控制设备的软件，可想而知是工作在内核态。可是有些同学可能听说过一种叫做“用户态驱动”的东西，这是个啥呢？</p>
<p>为什么要使用用户态驱动？首先用户态态编程容易呀：编程环境我们都熟悉，又有丰富的库，还可以使用自己喜欢的语言进行编写。另外，据说用户态驱动因为没有用户态－内核态切换的开销，有时候效率会比内核态驱动高一些。</p>
<p>用户态驱动是怎么实现的呢？对硬件的直接访问一般是不能再用户态进行的（在Intel x86体系下，我曾经听说过有个叫IOPL的标志位，可以控制IO端口是不是可以被用户态程序直接访问）。所以，应该是有一段功能简单的驱动把基本的操作通过设备文件暴露给用户态，然后再在用户态进行编程，扩展它的功能并提供更高层次的功能抽象。用户态驱动最终表现形式是一个软件库，供其它程序调用，或者是以服务器的形式，与应用程序进行交互，如X server。而内核态的驱动，往往作为内核的一个模块。</p>
<h3 id="动态加载">动态加载</h3><p>之前的文章<a href="http://freemandealer.github.io/2015/05/24/hotplug/" target="_blank" rel="external">《Linux热插拔机制的介绍和应用》</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<center><br><img src="/img/device_driver_monkey.jpg" alt=""><br></center>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[开源中的企业]]></title>
    <link href="http://yoursite.com/2016/06/03/open-source-and-enterprise/"/>
    <id>http://yoursite.com/2016/06/03/open-source-and-enterprise/</id>
    <published>2016-06-03T06:46:48.000Z</published>
    <updated>2016-08-17T01:08:23.000Z</updated>
    <content type="html"><![CDATA[<p>之前接触开源纯粹是没项目做时找乐子以及被免费开放的源代码吸引，出于个人角度。通过近期与开源软件行业较为深入的合作，以及阅读的一些科普小文章，在这里谈谈我对开源和企业的理解。<br><a id="more"></a></p>
<p>提到开源，我想大家都会有至少这三个问题：</p>
<ul>
<li><p>为什么要使用开源软件？</p>
</li>
<li><p>为什么要投人力、财力给开源？</p>
</li>
<li><p>开源如何盈利？</p>
</li>
</ul>
<p>我发现站在不同的角度看这个问题，会有不同的答案。所以我将会以IT技术型企业、非IT技术型企业和开源技术方案提供商这三个企业的观点看这个问题。</p>
<p>作为互联网时代的企业，时不时地会用到信息技术解决方案，搭个数据分析平台、架设个站点啥的。如果他们使用商业解决方案，那似乎就踏上了一条不归路。商业解决方案很多都是黑盒子，一旦出了问题只能叫人来修，自己一边瞅着干插不了手干着急。对于那些分分钟交易上亿的企业，这个问题修复的周期是难以忍受的。另外，商业的方案坑比较多，想想最近的Win10强制升级吧…… 对于底层系统的完全掌控会给后期的系统维护、升级带来极大的便利。所以，企业想健康发展有两条路：自主研发，或者求助开源（当然也有自主研发再开源出去，暂且算在开源里了）。</p>
<p>作为一个IT技术型企业，例如互联网公司，他们应该是有能力进行资助研发的。但是如果有现成的，考虑到人力、财力和时间成本，当然会使用现成的。到这里，回答了第一个问题：为什么要使用开源？（不然呢……）</p>
<p>一般企业会对开源方案进行一圈调研，觉得合适的就用，差功能的就补上，渐渐地走上了投人力、财力给开源的路子。当然问了一圈没有适合的，那就自己开发呗。可是发现自身能力有限，又或是为了省成本，干脆把自己开发半拉子的方案开源出去，让其它人参与进来一起开发和维护，又不用给他们钱，何乐而不为呢？</p>
<p>企业参与开源当然是为了赚钱，毕竟企业一词的定义里明确说明“以盈利为目的”。企业求助开源方案，是在省成本没错。可是投精力狠搞开源似乎有些不靠谱？把自己的自主研发开源听起来简直是在为竞争对手做嫁衣！其实企业在投入开源时，也是在社区中树立威信。如果一个开源项目的80%代码都是你贡献的，你就有很大可能主导这个项目向着有利于自己的方向发展。站在长远角度看这个问题，企业绝对是从中获益的。那么把自己自主研发的项目开源是不是在扮演农夫与蛇呢？这得看企业对开源的“度”的把控。一般情况下，没人傻到把自己的赚钱核心公布出来。而且像现在80／20不平衡法则支配的互联网产业，相比用户和数据积累，想纯粹凭借技术力挽狂澜真的是非常难了。所以，开源自己的技术还是蛮安全的。</p>
<p>说完IT技术企业，开始说说非IT技术企业在开源里扮演什么样的角色。和IT技术企业一样，非IT们用相似的眼光考量着开源这块烙饼。它们的区别在于，非IT技术企业往往没有能力去自主研发或是参与开源。这种情况下，开源的优势就不能掩盖它的劣势了：首先很多开源软件不怎么易用，个人认为商业公司为用户考虑得还是挺周到的，说到底人家至少还有售后服务呢。例如OpenStack部署和架构的实施和维护成本较比VMware有了陡然提高。另外，一旦方案出问题，因为企业内部缺乏IT技术人员，所以只能求助社区。这种情况下，问题恢复周期远远长于商业方案。</p>
<p>所以怎么才能解决这些弊端呢？除了花钱自己维护一个开源团队（这样就类似IT技术企业了），还有个办法就是把维护外包给第三方——这就是我们要提到的第三类企业——专业的开源技术方案提供商。它们就像商业软件的客服，完成对开源软件使用培训、功能部署、稳定性维护。通过这个来获取利润，听起来有些不靠谱啊…… 可是开源技术方案提供商的龙头企业红帽(RedHat)2015年收入20.5亿美元（我对这些以亿为单位的钱没什么概念，反正他们自己很激动）不知道能不能说明一丢丢问题。</p>
<p>专业的开源技术方案提供商本身也是会投入人力、财力进开源项目的，原因和第一类企业不一样——第一类企业做出软件就是为了服务自己的商业目的。开源技术方案提供商真的只是一心想把软件做好，这样就会有更多的人使用这个软件，它就可以获得更多客户，通过卖出更多的服务赚钱，走“曲线赚钱”的路线。</p>
<p>以上就是我对开源的些许理解。这些理解可能很浅显，但已经使我相信，开源真的在改变世界。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前接触开源纯粹是没项目做时找乐子以及被免费开放的源代码吸引，出于个人角度。通过近期与开源软件行业较为深入的合作，以及阅读的一些科普小文章，在这里谈谈我对开源和企业的理解。<br>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在任何地方控制宿舍的电脑]]></title>
    <link href="http://yoursite.com/2016/04/04/remote-control/"/>
    <id>http://yoursite.com/2016/04/04/remote-control/</id>
    <published>2016-04-04T09:41:09.000Z</published>
    <updated>2016-04-04T11:01:35.000Z</updated>
    <content type="html"><![CDATA[<p>三天假期出去浪，妈妈问我的代码是在哪里写的？</p>
<p><img src="/img/remote-control-wild.jpg" alt=""></p>
<a id="more"></a>
<p>这是我一直的梦想，在哪里都能用上电脑！当然绝不是指购买十台八台电脑放在生活圈的各个角落，而是指随时随地访问宿舍里的电脑。</p>
<h2 id="解决方案">解决方案</h2><p>问题就出在宿舍里的Dell处在内网，除了在一个子网的机器，别的任何机器都没法连接上它。</p>
<p><img src="/img/remote-control-false.jpg" alt=""></p>
<p>解决的方法就是在互联网上找一台大家都能访问的机器做中转，把对宿舍电脑的操作命令先传递到中转机器上，然后由它发送到宿舍电脑上执行。这个中转的一种实现就是ssh的端口转发。这可不是一个新鲜的玩意儿。</p>
<p><img src="/img/remote-control-true.jpg" alt=""></p>
<h2 id="那具体怎么操作？">那具体怎么操作？</h2><h3 id="第一步，寻找一台中转Relay">第一步，寻找一台中转Relay</h3><p>对于中转的机器要满足要求是：拥有公网IP，换句话说，必须能在因特网上找到。</p>
<h3 id="第二步，在宿舍的Dell上做反向端口转发:">第二步，在宿舍的Dell上做反向端口转发:</h3><pre><code><span class="tag">ssh</span> <span class="tag">-R</span> 34345<span class="pseudo">:localhost</span><span class="pseudo">:22</span> &lt;<span class="tag">relay-usr</span>&gt;<span class="at_rule">@<span class="keyword">&lt;relay-address&gt;</span></span>
</code></pre><p>这行命令会将localhost(Dell)的22号端口映射到Relay的34345端口上。这样，我们对于Relay的34345的操作都会被Relay投射到Dell的22号端口上，例如：我们对Relay的34345号端口发出ssh连接请求，连接请求将会被转发到Dell的22端口上，所以我们实际在连接Dell，而这正是我们想要的！</p>
<h3 id="第三步，修改中转机器配置">第三步，修改中转机器配置</h3><p>我们登陆Relay，检验转发是否成功:</p>
<pre><code>ssh <span class="tag">&lt;<span class="title">relay-usr</span>&gt;</span>@<span class="tag">&lt;<span class="title">relay-addr</span>&gt;</span>
</code></pre><p>根据提示输入密码，登陆Relay后，执行下面的命令：</p>
<pre><code>ssh  <span class="tag">&lt;<span class="title">dell-usr</span>&gt;</span>@<span class="tag">&lt;<span class="title">relay-address</span>&gt;</span> -p 34345
</code></pre><p>输入密码后我们登陆到Dell上。但操作还没有完全成功。这个端口转发只在relay机器上生效，还不能实现其它内网机器连接Dell。所以我们需要修改Relay上的ssh配置文件/etc/ssh/sshd_confg，打开GateawayPorts开关：</p>
<pre><code><span class="comment"># GatewayPorts no</span>
<span class="title">GatewayPorts</span> <span class="built_in">yes</span>
</code></pre><p>这样我们就可以在任意能连上因特网的机器上访问Dell了。</p>
<p>我们还可以尝试不同的ssh参数，获得一些功能。例如-f参数可以让转发在后台进行，不会因为当前会话的关闭而失效。</p>
<p>到这里文章就可以结束了。看我们的Dell，完美连接，流畅操作！……额，有一个问题，Dell得一直处在开机待命状态，这多浪费电呀、要排放多少CO2、多少小动物会因此丧生？为了避免Maxwellxly追来北京教导我保护环境，我决定加上一个远程电源控制。</p>
<h2 id="远程电源管理">远程电源管理</h2><ul>
<li>IPMI</li>
<li>phidgets</li>
<li><a href="http://www.digital-loggers.com/lpc.html" target="_blank" rel="external">http://www.digital-loggers.com/lpc.html</a></li>
</ul>
<p>上面这些都是远程电源控制的解决方案，涉及到各种硬件设备。作为我，为了节约成本，我会时常想起那句话：</p>
<blockquote>
<p>幸福来源于对已有物品的满足。</p>
</blockquote>
<p>我有啥？一块cubieboard（一款卡片电脑，和树莓派是一类），我已经打它主意很久了。cubieboard功耗极低，待机一个月才一度电。我想用cubieboard一直处于在线状态，通过连接它去启动功耗较大的Dell。于是整个系统就成这样子了：</p>
<p><img src="/img/remote-control-power.jpg" alt=""></p>
<p>那么cubieboard怎么去启动Dell呢？远程关机谁都会，问题出在把一台关着的电脑打开。想想半夜你床头的笔记本突然自己启动了……</p>
<p>好在现在的显卡都是支持wol（wake on lan, 网络唤醒）。虽然电脑是关着的，但是网卡还处在半死不活的状态，睁一只眼闭一只眼注意着网线上的信号。一旦它收到一串特定的字节，它就会把整台电脑唤醒。另外，wake on lan这个名字告诉我们，唤醒过程只存在于一个lan（局域网）里。很多路由器是不支持路由唤醒信号的。另外，最好使用有线局域网。</p>
<p>有了硬件的支持，我们看看怎么给网卡释放这个唤醒信号。Linux下有一个应用就叫wakeonlan。</p>
<p>安装</p>
<pre><code>apt-<span class="keyword">get</span> install wakeonlan
</code></pre><p>使用</p>
<pre><code>wakeonlan <span class="tag">&lt;<span class="title">target-MAC</span>&gt;</span>
</code></pre><p>哟嗬！电脑突然亮了，吓老子一跳！</p>
<p>好了，集齐了硬件、软件，剩下的就是把cubieboard也用第一部分介绍的方法暴露在因特网上，我们先连接它，让它唤醒Dell，接着再连接唤醒后的Dell。我打算再写一些脚本自动化一些过程，写一段<a href="http://www.cyberciti.biz/tips/linux-write-sys-v-init-script-to-start-stop-service.html" target="_blank" rel="external">SystemV服务脚本</a>开机启动……</p>
<p>但是我得停一下！写代码之前搜一遍Github是个好喜欢。运气不错，找到一款:Remote Wake/Sleep on LAN Server。它用web界面封装了wakeonlan和ping工具，可以实现唤醒和休眠(休眠只对windows机器有用)和机器状态查询，功能简洁干净！<a href="https://github.com/sciguy14/Remote-Wake-Sleep-On-LAN-Server/wiki/Installation" target="_blank" rel="external">使用说明点这里</a></p>
<center><br><br><img src="/img/remote-control-power-app1.jpg" alt="">  <img src="/img/remote-control-power-app2.jpg" alt=""><br><br></center>


<h2 id="等一下，你这个有点折腾！">等一下，你这个有点折腾！</h2><p>简短的回答：因为我能！</p>
<p>其实实现移动办公有很多很方便、廉价的方法，例如直接使用云主机或者使用teamviewer软件即可。我迂回一大圈的原因很简单：因为我能折腾。除此之外还有一些个人原因：</p>
<p>公共租赁的云主机可是大大满足了我的需求，除了一点：尽管我可以按喜好配置它使用它，它的所有权不是我的。对于我这种控制欲很强的人来说，我是不会把重要资料和会常久使用的系统部署在一台听别人摆布的机器上的。</p>
<p>Teamviewer这类软件为我们提供了因特网范围内的远程桌面服务，但图形化的远程操控是卡顿的、耗费流量的。更关键的是，很多情况下远程桌面本身就是冗余的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>三天假期出去浪，妈妈问我的代码是在哪里写的？</p>
<p><img src="/img/remote-control-wild.jpg" alt=""></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[从socket应用到网卡驱动：Linux网络子系统分析概述]]></title>
    <link href="http://yoursite.com/2016/03/08/tcp-ip-internal/"/>
    <id>http://yoursite.com/2016/03/08/tcp-ip-internal/</id>
    <published>2016-03-08T01:45:15.000Z</published>
    <updated>2016-03-08T07:33:52.000Z</updated>
    <content type="html"><![CDATA[<p>socket是互联网的基础，我们所熟知的互联网应用大部分是基于socket及其变种，如：浏览器、即时通信软件等。socket这个术语最早出现在TCP规范RFC793中。后来它也作为伯克利编程接口。它的定义为如下二元组：</p>
<center><em>socket:=(IP:port)</em></center>

<p>由此，TCP连接可以定义为：</p>
<center><em>TCP Connection := {socket1, socket2}</em></center>

<p>本文将从socket应用出发，分层深入Linux网络模块内部，去分析内部运行原理。</p>
<a id="more"></a>
<h2 id="一个简单的socket应用">一个简单的socket应用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Server</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="keyword">int</span> sockfd, session_sockfd;	<span class="keyword">struct</span> sockaddr_in addr, client_addr;	<span class="keyword">socklen_t</span> socklen;	<span class="keyword">int</span> recv_size;	<span class="keyword">char</span> buf[<span class="number">200</span>];	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);	<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));	addr.sin_family = AF_INET;	addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);	addr.sin_port = htons(<span class="number">8000</span>);	bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));	<span class="built_in">printf</span>(<span class="string">"Listening . . .\n"</span>);	listen(sockfd, <span class="number">1</span>);	<span class="built_in">printf</span>(<span class="string">"Connected\n"</span>);	socklen = <span class="keyword">sizeof</span>(client_addr);	session_sockfd = accept(sockfd, 	(<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;socklen);	recv_size = recv(session_sockfd, buf, <span class="number">200</span>, <span class="number">0</span>);	<span class="built_in">printf</span>(<span class="string">"Received %d bytes: %s\n"</span>, recv_size,  buf);	close(session_sockfd);	close(sockfd);	<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Client</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;	<span class="keyword">int</span> sockfd;	<span class="keyword">struct</span> sockaddr_in addr;	sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);	<span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));	addr.sin_family = AF_INET;	addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);	addr.sin_port = htons(<span class="number">8000</span>);	connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr,</span><br><span class="line">				<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr));	send(sockfd, <span class="string">"Hello, Server!"</span>, <span class="number">15</span>, <span class="number">0</span>);	close(sockfd);		<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个最简单的可以编译运行的socket应用，简单到省略了出错处理。程序的逻辑为：客户端连接服务器，并发送一个字符串，服务器接收这个字符串并显示。</p>
<p>编程中的要点就是一些库函数的调用。我们把这些函数按顺序排列成下图所示形式。这张图正反映了socket的工作流程。</p>
<p><img src="/img/socket-workflow.png" alt="Socket Workflow"></p>
<p>为了完成一次会话，服务器需要预先进入等待连接的状态，即图中的listen调用。为此，服务器首先调用socket创建一个socket文件。至于为什么需要这个文件，是由unix/linux“一切皆是文件”的设计原则决定的。unix/linux中把对网络的操作(配置网络、发送数据包、接收数据包等)都抽象成对socket文件的操作。换句话说，在TCP中，一个socket文件就代表一个socket，一个socket就代表一个网络连接。UDP没有连接的概念，但任然需要一个socket文件作为网络操作的实体。</p>
<p>接着服务器调用bind，为socket绑定本机IP地址和一个没被占用的端口号。计算机网络课程告诉我们，端口号的目的是为了实现复用。通俗一些说，端口号就是为了区分不同进程设置的标识。这些进程都使用网络层收发数据包（复用），端口号就是用来确定正在发送/收到的数据包属于哪个进程。随后，服务器调用listen等待客户端的连接。</p>
<p>下面看图左客户端这边的流程。相比于服务器端，客户端的操作特别简单。依然先调用socket创建一个socket文件作为连接的实体，随后发出connect请求连接。这个请求包含着明确的服务器IP地址和端口号。</p>
<p>服务器收到connect请求后调用accept接受请求。接受请求操作会返回一个新的socket文件。这个文件才是真正与客户端通信的连接所对应的socket文件。accept函数同时会获得客户端的IP地址和端口信息。</p>
<p>至此，双方已经建立连接。此时客户端调用send向服务器发送数据。服务器调用recv接受数据。需要说明的是这个通信是双向的。服务器也可以调用send主动向客户端发送数据。</p>
<p>通信完成后，双方关闭socket文件，释放资源。如果服务器仅仅关闭accept返回的文件，保留最开始的socket文件，那么服务器还有能力接受下一个来自客户端的connect请求（需要一个额外的循环配合listen的调用或者使用多线程）。</p>
<h2 id="内部的故事">内部的故事</h2><p>如果对于应用程序的编写，上述的知识已经足够了。但是如果想要深入了解Linux内核网络协议栈的实现，我们需要站在较低的层次，仔细观察上述流程发生时内核中的处理和变化。</p>
<p>下图展示了整个网络子系统的层次。为了讨论方便，我们按发送数据包的方向，逐层向下描述各个层次的功能特征。接收数据包的方向是相反的。</p>
<p><img src="/img/network-structure.png" alt="Network Structure"></p>
<p>如图所示，系统调用是操作系统内核空间与用户空间的界面。strace工具的结果表明，回溯上述的各个glibc库函数的调用，最终都是系统调用——socket对应sys_socket系统调用，bind对应sys_bind系统调用，send对应sys_sendto系统调用等。</p>
<p>这些系统调用是我们进入内核的入口。进入内核后，VFS(虚拟文件系统)将会进行一些处理。上文说明过，一个socket对应一个socket文件作为操作的实体。本文讨论的这些网络相关的系统调用，都把socket文件作为重要参数，如sys_socket系统就是用来新建并初始化这个socket文件的。sys_bind系统将地址、端口等信息绑定在这个文件上。</p>
<p>离开VFS层，我们下到INET层。这一层的核心数据结构，就是struct socket。每一个socket文件都有一个socket控制实体(数据结构struct socket的实例)与之对应。这个socket控制实体自身以及其成员包含了socket的所有信息，包括状态、标志、操作、数据缓冲区信息等。</p>
<p>有必要说明的是INET这一名称的来历：回顾之前socket应用的例子，可以看到我们调用socket()时曾经传递过一个参数AF_INET。计算机网络课程中我们学习过“细腰结构”——IP over Everything &amp; Everything over IP。但实际上第三层还是有很多不同于IP协议的存在，如IPv6、IPX、DNNET等。Linux称它们为不同的地址簇(Address Families, AF)，或叫协议簇(Protocal Families, PF)。INET就是一个地址簇。从另一个角度看，内核代码的net目录下有很多子目录都是一个个独立的地址簇，其中包含一个命名为af_XXX.c的文件用于初始化该地址簇以及提供一些重要的操作。例如在net/ipv4目录中，我们可以看到af_inet.c文件。原来INET就是使用IP(第四版)协议的地址簇!更佳准确的说法是INET封装了TCP/IP。我们在这里只关注TCP/IP协议，只研究INET。</p>
<p>IP和INET有着紧密的联系，但IP层和INET层并不是等价的概念。INET仅仅是使用了IPv4的协议的地址簇，在TCP/IP参考模型中，它不是单独的一层。INET是Linux网络子系统的一个抽象层次，向上提供了操作的接口，但实际还需要调用下层的功能才能完成数据发收、监听等任务。具体调用下层的什么功能，要根据通信类别来选择。TCP/IP协议栈中，通讯有三种类别：TCP、UDP和RAW方式。前两种方式在计算机网络课程中有较多的讨论，大家比较熟悉。最后一种RAW，从某种意义上说，并不是额外的应用层通信方式——它只是告诉应用层不用理会，直接把数据传递到下一层即可，由网络层直接处理。ICMP是基于RAW方式的一个重要协议，只不过它有一些特殊的性质，所以单独列在这里。</p>
<p>如果是发送数据包，数据通过TCP、UDP操作的处理，或是直接通过RAW方式，最终将来到IP层。这一层中出现了重要的数据结构sk_buff(socket buffer的缩写)，存储着数据和连接信息，后面操作的中心从之前的socket、sock数据结构转移到sk_buff上来，sock被释放。IP层对数据进行处理后需要对其进行发送。考虑到IP层的一项重要任务是路由，这里的发送不是直接将数据包传递给下面的层次，而是需要在路由系统中进行游历。在Linux中，路由表被称作转发表(Forward Information Base, FIB)。为了提升查找性能，转发表有一个cache叫做rtable(字面意为“路由表”)。为了避免混淆，我们称rtable为转发表的cache。查找路由表的方式同一般的cache机制：首先查找转发表cache，若命中即使用该路由，否则查找转发表，并将路由信息添加进转发表cache。转发表cache是用带桶的hash表实现的，其key是流标识flowi(Flow Identifier)，用来唯一确定一条业务流。如果找到合适的路由后，我们就便把发送的数据传递给下层。但也可能发生找不到路由的情况，例如第一次向一台远程主机发送数据。这时，内核将会暂停发送数据的工作，转而完成邻居发现/地址解析(ARP)。</p>
<p>完成这一工作的是图中倒数第二层的ARP和邻居子系统。它们之间类似于包含关系。ARP的功能是将IP地址映射成MAC地址。邻居子系统的功能是将IP地址映射成链路层硬件地址。MAC地址是硬件地址的一种。对于非以太网设备，其硬件地址不一定是MAC地址。所以ARP可以看成是邻居子系统的一个特殊情况。当然地址解析不是每次都能成功的，特别是第一次向某个主机发送数据时。这时邻居系统将会暂停数据发送流程，转而进行邻居发现的流程。这一层次的功能实质是衔接IP层和链路层，开始使用硬件地址，并有了设备的概念。</p>
<p>真正与设备紧密联系的是图中的最后一层：设备驱动层。它位于参考模型中的链路层。正是它控制硬件，将数据包发送出去。虽然内核编程使用的C语言是面相过程的程序设计语言，但Linux的驱动模型具有鲜明的面相对象特征。驱动这一“抽象类”定义了很多虚”方法”，由具体的驱动程序去实现这些”方法“。这些”方法“对应着网卡硬件功能的抽象，由操作系统内核回调，以完成数据收发、网卡配置等任务。</p>
<p>上述讨论部分按照发送数据的流程进行，接收数据与之有很大差别，但任然可以参考反方向进行分析。</p>
<h2 id="附：结合网络模拟器学习计算机网络">附：结合网络模拟器学习计算机网络</h2><p>本学期刚好选修了一门TCP/IP协议分析与编程的课程，所以想到把篇文章po上博客。文章起草于2016春节，当时的动机是：刚刚修完计算机网络这门课，学到很多很多的概念和协议，但总觉得很虚、不实在。当时认为，学习一个具体系统的网络实现会让这些模糊的概念生动起来，所以选择对开源的Linux内核代码的网络模块进行了调研。</p>
<p>而现在，我找到了更好的一条学习路径。在开学前几天，我回了一趟实验室。就在实验室的这两天，我接触到了一个叫做OMNET++的网络模拟软件。利用OMNET++可以开发自己的网络模拟器，但就学习、验证计算机网络课程学习的知识而言，我们直接运行OMNET++自带的一些实例就可以得到极大的满足。OMNET++编写的模拟器可以用动画的形式展示网络的行为。同时，我们也可以任意停止时间，观察网络中的数据包和各个层次、各个组件的状态。最近我就单步运行了一个DHCP的实例，对照书本中说明的流程，学习了DHCP。只要愿意，我们甚至可以修改代码，改造某一协议，并通过模拟验证修改对整个网络的影响。</p>
<p>从本科学习计算机网络这门课以来到现在，我总结了一个自我认为很爽快的学习路径：</p>
<p>从计算机网络课程学习基本概念 －&gt; 借助模拟器观察实际网络行为 -&gt; 分析开源系统的代码获得具体技术细节实现</p>
<p>之前直接跳过第二环节去分析源代码，现在看来傻乎乎的。缺少一个直觉、系统的认识，那么学习曲线会十分陡峭，常常摸不着头脑。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li>Linux内核源代码 www.kernel.org</li>
<li>CSDN专栏Linux内核网络栈源代码分析 <a href="http://blog.csdn.net/column/details/linux-kernel-net.html" target="_blank" rel="external">http://blog.csdn.net/column/details/linux-kernel-net.html</a></li>
<li>PDF Linux-Net 和它的读书笔记  <a href="http://www.cnblogs.com/better-zyy/archive/2012/03/16/2400811.html" target="_blank" rel="external">http://www.cnblogs.com/better-zyy/archive/2012/03/16/2400811.html</a></li>
<li>PDF Linux TCP/IP协议栈分析(二到五章)</li>
<li>Linux Manual Page</li>
<li><a href="http://blog.csdn.net/wearenoth/article/category/1131669" target="_blank" rel="external">http://blog.csdn.net/wearenoth/article/category/1131669</a></li>
<li><a href="http://blog.csdn.net/minghe_uestc/article/details/7819925" target="_blank" rel="external">http://blog.csdn.net/minghe_uestc/article/details/7819925</a></li>
<li><a href="http://www.omnetpp.org" target="_blank" rel="external">http://www.omnetpp.org</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>socket是互联网的基础，我们所熟知的互联网应用大部分是基于socket及其变种，如：浏览器、即时通信软件等。socket这个术语最早出现在TCP规范RFC793中。后来它也作为伯克利编程接口。它的定义为如下二元组：</p>
<center><em>socket:=(IP:port)</em></center>

<p>由此，TCP连接可以定义为：</p>
<center><em>TCP Connection := {socket1, socket2}</em></center>

<p>本文将从socket应用出发，分层深入Linux网络模块内部，去分析内部运行原理。</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读理解：理解不理解当是自己说的算]]></title>
    <link href="http://yoursite.com/2016/02/19/reading-comprehension/"/>
    <id>http://yoursite.com/2016/02/19/reading-comprehension/</id>
    <published>2016-02-19T14:18:10.000Z</published>
    <updated>2016-02-19T14:28:15.000Z</updated>
    <content type="html"><![CDATA[<p>事情是这样的，最近有很多书要读，所以想在寒假里训练一下阅读速度。我认为买一本专门的训练材料还是必要的，那种可以算出我的每分钟阅读字数和理解程度的材料——没错，最后我使用了一本英语考试阅读理解、快速阅读那种形式的书。看到这里有人可能已经觉得我脑残了，可是当时我并不自知。</p>
<a id="more"></a>
<p>拿到书我迫不及待地做了一个测试：打开计时器，尽最大努力快速地读完一篇文章，感觉理解得差不多了，关掉计时器，做题目。一看题目傻眼了：都是一些人名、时间、地点、数量这些我根本不care的东西。结果当然是差劲得要命。</p>
<p>完了开始读第二篇、第三篇测试，我长心眼地留神关注这些外国人名、时间，果然分数高了很多。心想着一上午我的理解力就训练地突飞猛进，顿时心里<del>像喝了蜜一样甜</del>很慌张，赶紧进入反思状态。</p>
<p>真的是理解力提升了吗？依我看，更正确的提法是“应试能力得到提升”。我的理解还是之前的状态，只是多花了时间记住可能要被问到的一些要素。是的，考试这么多年，预测题意和考点当然炉火纯青。</p>
<p>阅读时需要仔细理解的，无非是我们感兴趣的内容。什么是感兴趣呢？“感兴趣”的英文是interest，原意是“吸引注意”，包含着比中文“兴趣爱好”或“有意思”更广泛同时更具体的含义。在阅读时能吸引我们注意的内容，不仅仅是“有趣的”，不仅仅是兴趣爱好，还可能是满足我们好奇心的，能带给我们利益的，解决我们当前问题的。</p>
<p>相比以上这些，潜在的考点更能吸引我们学生的注意力。每当阅读，看到who/what/why/when/where/how/how many/much我们就暗自窃喜，感觉悟到了考点，赶紧多看几眼。理解了潜在考点相关的内容，我们真的理解“感兴趣的内容”了吗？是的，我们理解了，但那是出题老师感兴趣的，或者出题老师以为我们感兴趣的。我们想了解一个精妙的实验过程，我们真的需要知道那位科学家长长的名字吗？甚至有时，为了节约珍贵的考试时间，我们往往忍痛忽略了自己真正好奇的内容。</p>
<p>英语听力也是这样。我知道美国采取了新政策，但我并不关心是国防部发布的还是卫生署发布的。我知道日本地震死了很多人，但我不在意具体300还是400。甚至有些消息全部我都不关心。但为了出成一张试卷，较为公平地筛选人才，只能问一些普遍的问题。这些问题我感兴趣自然会理解得很清楚，不感兴趣的很遗憾，为了分数，只能假装自己感兴趣。最后，也不知道自己对什么感兴趣了。</p>
<p>这是应试的悲哀，而我却在逃离应试进入自由学习环境后，放弃追求真正感兴趣的内容，重新回到了囚笼。其实我不用费尽心思找专门的训练材料，看任何想看的书本身就是训练。其实我当完成第一篇测试时，分数虽然低，但是我相信自己理解了自己感兴趣的内容。理解不理解，这是不能由分数评判的，而是只有自己清楚。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>事情是这样的，最近有很多书要读，所以想在寒假里训练一下阅读速度。我认为买一本专门的训练材料还是必要的，那种可以算出我的每分钟阅读字数和理解程度的材料——没错，最后我使用了一本英语考试阅读理解、快速阅读那种形式的书。看到这里有人可能已经觉得我脑残了，可是当时我并不自知。</p>]]>
    
    </summary>
    
      <category term="Meta" scheme="http://yoursite.com/tags/Meta/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[拖延症]]></title>
    <link href="http://yoursite.com/2016/02/04/procrastination/"/>
    <id>http://yoursite.com/2016/02/04/procrastination/</id>
    <published>2016-02-04T09:30:31.000Z</published>
    <updated>2016-02-19T14:22:46.000Z</updated>
    <content type="html"><![CDATA[<p><center><br><img src="http://www.hyyxw.net/upload/image/20151110134245t1jo.jpg" alt=""><br></center><br><a id="more"></a></p>
<p>我知道会点开看这篇文章的都是什么人，所以开头就不用“您是否曾感到XXX”的排比句式激起共鸣、揭你们伤疤啦。本文整理我在战拖生涯里的所听所闻所想。</p>
<p>首先有必要简单定义一下拖延症。说到它，很多人的直观感受就是做事慢，因而怀疑自己或他人是拖延症患者。做事慢的原因其实有很多，常见的有完美主义者：考个试检查几十遍不敢交，下盘棋思来想去不落子，写个稿子一直改到deadline，画幅画一笔一刷直到死…… 想想就可怕，还好我们在这里不讨论他们。我们讨论的拖延症是：<strong>把应该马上去做的事拖着不做，而改做一些无关紧要的事，同时产生巨大的心理压力进一步阻止自己去做事的情况。</strong></p>
<p>我应该马上分享我的战拖策略，但我还是想做一些无关紧要的事。看别人写文章How之前总要Why一下，所以我们来强行说一说为什么会有拖延症呢？开脑洞一分钟…… 尤里卡！之前听加州大学的公开课《Learning How to Learn》时教授提到，做不情愿做的事，大脑负责“疼痛”的区域会兴奋。原来拖延症就跟打针一样，明知道那一针可以治病却还是忍不住躲着它。进化给予生物一大特征就是：趋利避害。如果哪个生物总是在给自己制造疼痛（简称作死），那也不会繁衍至今对不对？所以我们逃避疼痛，逃避不情愿做的事，拖延症状就产生了。总结一句话，我拖延我有理，这是进化决定的！</p>
<p>不知道你有没有觉得：好像拖延症在我们这一代人身上特别明显？父辈祖辈在我们心中可都是劳模形象！解释这点，我们需要反思我们跟先辈有什么差别：除了我们被更多诱惑包围外，有个重要区别是我们的工作种类不同。这不是废话：我们的祖先很多都是面朝黄土背朝天的农民，甚至追溯到农耕文明之前，都是原始人。他们的工作是和生存紧密联系的。他们不及时耕作、不努力狩猎，就会饿死。回头看现代人的工作——真的太抽象了！我真的没法从面前的文稿和电脑屏幕里嗅出食物的芬芳。我们“体面”的工作远离了生存刚需。拖一天写完文档并不会影响我们的生存。这时大脑里趋利避害的原始本能说：你还有什么理由不拖呢？</p>
<p>终于到了分享战拖策略的环节。其实我想说，战拖的方法就藏在它的定义里——你不需要做什么，你只要知道什么是拖延症，就完成一半了。我们复习一下定义,着重注意最后半句话：把应该马上去做的事拖着不做，而改做一些无关紧要的事，<strong>同时产生巨大的心理压力进一步阻止自己去做事</strong>。我们想办法不产生心理压力不就成了吗？方法是：投降！我们是无法战胜拖延滴，但是我们可以调节心态：拖延症不是病！它是本能！我拖我有理！天底下几十亿人陪着我们拖拖拖！不用自卑！不过如果你非要说拖延症是病的话，医学上似乎也是承认的，但这个“拖延症”是指那种心理压力大到奔溃出现幻觉自杀那种可怕晚期，你不至于吧？</p>
<p>除了向拖延症屈服以外，还有一些方法能让我们感觉更舒服：想想啊，既然成因是由于我们做不情愿做的事，那我们就做自己情愿做的事呗，做自己喜欢的事！虽然带有强烈的理想主义色彩，但是这是我能想到的最好的方法了。我自己就很幸运，选对了大学专业，一直可以做自己喜欢做的事。有一天我甚至发现困扰我整个中学备考时期的拖延症完美自愈了！正当我忙着和别人分享胜利成果时，突然发现做一些乏味的事务时，又开始进入老状态。这证明了兴趣的力量吧，千万不能小觑兴趣，跟随你的心往往能让你事半功倍。</p>
<p>推演兴趣疗法，我们还能得到另外的启示。我们对每一件事的喜欢程度（或讨厌程度）不同。相比于考试，我更喜欢上课，相比于上课，我更喜欢敲代码，相比于敲代码，我更喜欢睡觉，相比于睡觉，我更喜欢看电影。这样就形成了一条喜欢链条：</p>
<pre><code>考试 &lt; 上课 &lt; 敲代码 &lt; 睡觉 &lt; 看电影
</code></pre><p>我们面对着链条某一环节时，更愿意做这个环节后面的事(不一定是最后)。要上课了，让我看电影是相当不错，但让我睡觉，我也会很开心，让我不去上课敲代码的话我也愿意。这就是为什么到了考试复习月，很多同学觉得自己对除考试外的很多其它事物充满了兴趣，但到了放假（到了链条尾端），又开始嫌弃那些爱好。有意思的是，看着这个链条，斯坦福某位教授竟突发奇想，发明了“结构化战拖”法，思想就是多件事相互拖延，构成了一条合理的拖延链，帮助自己完成其中的某些事务，并因此荣获了“搞笑诺贝尔奖”。听起来确实有那么点不靠谱，但还是很有启发意义的不是吗？</p>
<p>下面分享一个比较正经的、让我受益颇多的方法：下一步行动。这个方法来自于哪里我已经记不得了，感觉我是把很多人提的建议归纳起来得到了这个方法(这个名字似乎来自于GTD?)。下一步行动的大致思想就是把一项复杂任务拆解成明确的任务，对于每个明确任务我们再确定一个容易上手的下一步行动。比如对于我们经常提及的“锻炼身体”这个复杂工程，我们可以分解成“跑步”、“肌肉训练”和“心肺功能训练”三项较为具体的任务。对于“跑步“我们的下一步行动就可以是”穿上跑鞋“。大家可以看到这是一个抽象活动具体化的过程，因为活动越具体、越短、越接近自己的身体的基本技能，我们就越不容易”痛苦“，就越不容易拖延。如果说”跑十公里“会勾起你痛苦的回忆导致你在门口犹豫，那么”穿上跑鞋“就是一个容易完成的下一步行动。穿上跑鞋后面我们该干什么呢？后面是不是还要有“开门”、“下楼”、“压腿”等等一系列操作？答案是：一般不用考虑。我们通常只关注第一个下一步行动，因为后面的事都是自然而然发生的。就像穿衣服，我们只需要把一只胳膊插进袖管，后面的活动便会行云流水般完成了。</p>
<p>当然有些事并不会因为我们做了一个下一步行动之后就会“自然而然发生”。这是因为我们划分不够细腻：我们把刷牙当作一件事去做，第一步行动是挤牙膏，然后就会自然而然地刷牙；如果我们把整个早起准备的过程当做一件事去做，希望自己下床之后，洗漱、做早餐、吃早餐、化妆整理等一系列流程自然而然地发成，那就太困难了。</p>
<p>但办法还是有的。我们不能自然而然是因为没有那个习惯，或者说没有那么大尺度的习惯。但习惯是可以养成的。上个月看指导员的时间管理视频，提到“晨起仪式”，就是一种习惯养成的好方法。核心思想就是固定早起准备的每一个步骤和消耗的时间（所以我猜测这里的“仪式”就是”雷打不动的例程”）。在使用了这个方法后，我体会到一些好处：因为每个步骤都是之前确定的，所以减少了选择和犹豫的时间。每次选择和犹豫其实都在挑战自己的意志力，所以固定步骤可以释放意志力，这点对我这种意志力薄弱的人特别有用——我相信系统，不相信自己，系统是稳定的、科学的，自己是情绪化的、容易松懈的。</p>
<p>当然晨起仪式还有更明显的好处：从起床到出门的时间变短了，而且对这段时间的长短有了概念！我们往往对时间没有概念，总感觉时间还长，可以懒一会儿。如果我知道早起准备需要的时间，我就可以根据出门时间精确地设定我的起床时间。到了这个点，我就知道自己不能再懒床了，不然就一定会迟到——就像祖先们知道自己不及时播种、狩猎就一定会饿死一样，根本没有胆量拖延。</p>
<p>类似“时间还多”、“这事好办”，我们很多乐观的错觉会成为我们做计划时的陷阱，所以对自己的了解很重要。我一般在清晨用崭新的状态尽量科学地做一天的计划，选择几个重要的任务，估计最坏情况下的时间开销，并排列起来。然后在大脑中将今天的流程过一遍。过完了有时就会感叹：原来一天这么短。有时会觉得今天的任务特别多，又没法做减法，只好把这一天过得小心翼翼。我觉得这个在大脑中提前“过”一天的方法，很大程度上减轻了晚上睡觉前突然发现自己一天没做什么事的惊悚感。</p>
<p>最重要的事情最先做。老生常谈之言，往往就是改变的关键。就这一条，能让工作变得更加舒心。有时我们拼命工作了很久，成就感是有，就是觉得不踏实。随着时间流逝，我们开始怀疑：手头的这件事真的重要吗？在真正埋头苦干之前，战略性地提取最重要的事去做，可以让我们工作过程中心态更加健康。我们知道自己每走一步都是在靠近更好的自己，所以充满动力。如果不把最重要的事最先做，我们不仅会怀疑自己的努力，有时甚至让我们一事无成。因为我们最应该做的事往往是具有挑战性的，我们如果不能在自己精力最充沛的时候抢先爬上这座高山，可能以后就再也没有信心想去征服它了。就像之前我看书有个习惯，一本书的核心内容普遍很难理解，我会先把前言、背景看了，直到有个地方卡住了，我就会翻过去，提前把后面一些轻松一点的总结、展望内容看掉，把核心部分留着最后集中精力啃，幻想着能农村包围城市。可事与愿违，大部分的精力耗在非核心的部分，在没有力气去啃核心了。同时，跳过核心去看后面的内容有时就像搭建空中楼阁，一本书翻下来，收获甚微。</p>
<p>另外再记录一点我在《巧学助我上清华》这本书里看到的内容和网上的解读。怎么会看这个？还不是为了我两个正在上中学的侄子:(</p>
<ul>
<li>理论一:今天的作业 明天做比较枯燥;明天的作业 今天做很有动力,也趣味十足.</li>
<li>理论二:延迟奖励</li>
</ul>
<p>解读:理论一是说今天就开始做明天的事情,轻松且正能量方面(自信心)加成,这是好学生不断滚雪球一样滚得自信心越来越强大的学习技巧; 理论二是说,当可以休息时(奖励),你却不松懈继续努力,这是不断超越的王道理论.</p>
<p>关于战拖差不多记录完了。最后我想说拖延有时也是优势。一方面，我们可以借助deadline强大的推动力，将一些不太重要的事临门一脚。另一方面，我们有时真的需要等等看：等着天时地利人和，等着积淀。特别是对于一些不靠谱的事，你一定不想看到自己提前做了一半，突然老板说不做了这种情况发生吧。什么时候该等待，这真的需要智慧，甚至自制。</p>
<p>拖延症不是病，是我们的原始本能被这个时代的工作类型放大了。我们不应该为此懊恼，压抑本性，而应顺水推舟。这就是我对拖延症的理解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><center><br><img src="http://www.hyyxw.net/upload/image/20151110134245t1jo.jpg" alt=""><br></center><br>]]>
    
    </summary>
    
      <category term="Meta" scheme="http://yoursite.com/tags/Meta/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[内核之于我]]></title>
    <link href="http://yoursite.com/2016/02/02/kernel-to-me/"/>
    <id>http://yoursite.com/2016/02/02/kernel-to-me/</id>
    <published>2016-02-02T14:29:20.000Z</published>
    <updated>2016-02-19T14:27:31.000Z</updated>
    <content type="html"><![CDATA[<p>今天导师发来邮件说让我去做无人汽车的人工智能，涉及深度学习、人工神经网络等一系列时髦词汇。很多人都觉得着实刺激，称赞是一个不错的课题。但我心里咯噔了一下——我亲爱的内核怎么办？</p>
<a id="more"></a>
<p>这个突然出现的深度学习课题，一旦参与，很大可能研究生未来的日子里都是跟它一起过日子了。进行了三年的内核研究似乎不得不停止，摆弄操作系统沦为不务正业。回想大二下学期稚气的我偶遇稚气的《30天自制操作系统》，想想大三冬夜熄灯后坐在楼道里啃《一个操作系统的实现》，想想每逢寒假暑假在金陵图书馆死磕内核代码，想想那本走到哪带到哪的大部头《深入理解Linux内核》…… 有时侯室友张刚都评价我的做事方式：你都把操作系统的思想带入生活了。真是分手时才想起她的好！</p>
<p>煽情部分到此结束，我们下面来看看内核的经历到底给予了我什么（喂～）</p>
<p>当然首先是钱途！在刚上大学时，就和一位名校毕业的在职驱动工程师交流过。驱动也是内核编程的一种。真的不能小看前辈（好吧，其实是名校毕业生）话语的力量，我的很多选择追根溯源也许就是受这次简单交流的影响。他让我感觉内核编程是复杂的，如果我能搞定这个，其它的编程不是问题。另外就是驱动程序猿的工资会高出很多。反正搞内核就是很高端的样子，不管是想证明自己，还是为了虚荣心，我渐渐不屑曾经执着过的酷炫前端和手机应用开发。</p>
<p>不过坑爹的是，后来他告诉我，国内的驱动开发其实也是写事务性的代码，重复度很高，工资也并不乐观。而我现在也混进名校了好嘛！除了做驱动开发，那就是真正的内核开发了。具体内核开发是什么，这正是我<strong>正在</strong>探索的。</p>
<p>除此之外，内核还给予了我什么？满足好奇！是一个十分有重量的理由。我很好奇计算机系统（广义的系统，包含硬件和软件）的如何工作，为什么这样设计。内核是软硬件的交界面，是理解整个计算机系统的切入点。况且，内核的学习资源很丰富，有很多著名书籍讨论其理论，又有像Linux内核开放源代码。这些来之不易的资源让我们相信：只要愿意下功夫，内核毫无秘密。</p>
<p>遗憾的是，随着我对内核的理解，这股好奇的力量逐渐减弱，这时内核之于我的其它意义凸显出来：内核赋予了我把握复杂软件系统的能力。Linux是开源的，是伟大的。Robert Love说：“请不要认为这理所应当。”而我还要加上一句：“请不要认为有了代码就没有了秘密。”沉浸在上亿行代码中，可不是一种愉悦的感受，而是分分钟溺亡的窒息感。当学会了拆分系统，学会了观察目录组织，学会了猜测函数功能，培养了寻找主干的嗅觉，培养了抽丝拨茧的侦探精神等等一系列特意功能后(好吧，其实只是耐心被逼出新境界了），再看各种大型工程，不会觉得心里烦躁了。</p>
<p>内核编程本身就是一项实用技术。很多应用层编程完成不了的功能，放到内核层实现就能成为可能并且会很自然很优雅。计算机网络课程大作业，我也看到很多小组不约而同地使用了netfilter框架，这也是内核级的编程。从这点来看，内核编程和和IOS开发一样，都是在一定平台下，实现了一些功能。不过内核编程的平台直接是硬件，在这个混沌的世界编程更加复杂。有了内核基础的我面对这些任务当然是毫不畏惧，相反，游刃有余。</p>
<p>Linux作为世界上最大开源项目，应该是没有之一的。作为内核开发轻度参与者，或多或少也受大胡子理念熏陶，学着用起来Git和GPL神器，和大牛们发起了邮件，感受到了“社区的力量”。</p>
<p>研究内核训练了我解决问题的能力。还记得大三做内核相关的项目，及其艰深，学校老师没有人懂，身边也没有经验的同学，完全就是一个人在那看时光荏苒思前想后。然而结果证明这个孤立无援的环境成为了我的成长的茂盛丛林。从开始学习，尝试读不同的书，最后理清书本间的关系找到一条斜率适度的学习曲线。从项目思路到设计到编码到debug，凡事出现问题，都是一个人使出浑身解数，丧心病狂。值得一提的是最终我结识了散落在各地的小伙伴、找到了组织(找到组织本身就是一个人死磕出的结果呀！)，又开始学习通过交流和他人的经验解决问题。想想内核debug的悲惨遭遇，还有什么算问题呢？</p>
<p>说到这里，让我们回到开头时的困惑：选择参与了实验室项目，很可能就得放弃内核。实验室课题、就业和个人兴趣这个三角很难被平衡。有人就说了：干嘛平衡？搞得像以后工作内容和你现在弄的东西相关似的。听完我虎躯一震：潇洒！</p>
<p>上次同样的一震还是谢高岗老师的复习课上，我们满心期待划重点，结果PPT上画着一个扫地僧，伴有旁白：手中无剑心中有剑，无剑亦为有剑。如果一个人把自己学到的具体知识忘光，那么剩下的就是理解和能力。如果我以后没有和内核走在一起，忘记了她，那么剩下的，就是文章中的这些沉淀吧。</p>
<p><img src="http://i13.tietuku.com/8acb1f0185975269.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天导师发来邮件说让我去做无人汽车的人工智能，涉及深度学习、人工神经网络等一系列时髦词汇。很多人都觉得着实刺激，称赞是一个不错的课题。但我心里咯噔了一下——我亲爱的内核怎么办？</p>]]>
    
    </summary>
    
      <category term="Notes" scheme="http://yoursite.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[科学的杜鹃蛋 —— 自然辩证法课堂演讲]]></title>
    <link href="http://yoursite.com/2015/11/27/the-eggs-of-science/"/>
    <id>http://yoursite.com/2015/11/27/the-eggs-of-science/</id>
    <published>2015-11-27T10:00:10.000Z</published>
    <updated>2015-11-27T10:42:42.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/the-eggs-of-science-cover.png" alt=""></p>
<a id="more"></a>
<p>大家好，我是张正宇。下面我将代表第23组，来自计算所的6位小伙伴，给大家展示我们对于“科技与社会”这个问题的讨论成果。</p>
<p>同学们认识Daniel Pink吗？他是全球最具影响力的50位思想家之一。他在他的书中写过：在不远的未来，那些需要左脑工作的职业将会被聪明的计算机程序取代。这都是他观点。你们相信吗？我不信！我自己的观点是：需要右脑工作的职业也可能被取代［观众笑］——比如说绘画。</p>
<p>今年8月底，德国一个研究所的科学家公布了一项研究结果，他们让人工智能系统学习梵高，莫奈等世界著名画家的画风绘制新的“人工智能世界名画”。我不懂艺术，但我觉得还不错，你们觉得呢？</p>
<p><img src="/img/the-eggs-of-science-1.png" alt=""></p>
<p>如果好奇这是怎么做到的，我这里给大家提供一个搜索关键词叫“机器学习”。当然，有了“机器学习”，我们还有“机器考试”。就在上个星期，日本一个研究所研发的人工智能已经能在日本高考中考取511分的成绩。511分是多少分呢？511分已经达到了80%的日本国内大学录取分数线。而同一套试题人类学生的平均分为416分［观众哇塞唏嘘］。</p>
<p>你看人工智能可以学习，也可以考试，分数还这么高，找工作估计也不用太担心。三百六十行，行行都可以人工智能。造成失业，可能是人工智能对于未来社会最直接的负面影响。大家知道，工业革命把工人从工厂撵走，不过我们因此有幸腾出时间，参加更加高级的智力活动。而现在人工智能的出现，分明是要把我们从事知识工作的权利也剥夺啊。</p>
<p>那在座各位就都只能回家生孩子去了对不对？［观众笑］当然机器也可能生小孩，现在的3D打印技术已经让机器复制成为了可能。有了机器能学习、能考试，说不定未来还能科研。这样我们也不要什么科研了，就每天早上喂完孩子去问电脑一个问题，比如怎么证明哥德巴赫猜想？让它自动去给我们找答案。这让我想到一部电影里的情节，电影叫做《银河系漫游指南》。其中有一段说科学家制造了一台人工智能，让它去求解“生命和宇宙的终极答案”。经过漫长的等待，这个人工智能回答道：生命和宇宙的终极答案是——42。科学家很难过，质问人工智能42是什么鬼。人工智能也很委屈，说答案真的是42［观众笑］，你们要理解这个答案那就必须首先找到“生命、宇宙以及一切的终极答案”对应的终极问题到底是什么。</p>
<p>［这里观众竟然没有笑……］这个片段很有意思，你们怎么不笑呢？［观众笑，掌声］没关系没关系……不笑也无所谓，这是一种英式幽默，笑点需要仔细品味。其实我想说的是这个片段的后面一段：那个人工智能看到人类忧郁的表情，决定去帮助人类寻找终极问题。不过它太累了，它得看电视，得休息，它又制造了另外一台计算机去算问题 —— 我们看到这个人工智能就像一个正常人类一样，有了需求，而且开始维护自己的利益。这是有可能的啊。随着人工智能的发展，社会对人工智能的期待越来越高，我们发现高智商还不够，同时还要求它有情商。等到发展到它产生自我意识，机器再也不是我们熟悉的那个没日没夜不知疲倦的工具了，那么问题就来了：要不要给人工智能看电视呢，当它们抱怨自己压力大的时候？我们要不要承认这个人工大脑里面是存在意识的呢？我们是不是要将人工智能视作生命呢？这是人工智能抛给社会伦理的挑战。</p>
<p>然而这个挑战比我们想象的深远很多，甚至可能会危及人类文明。这里我不是想说科幻电影里的那些邪恶机器杀手，即使是那些人畜无害、环境友好的人工智能，也可能充满人文关怀地杀死人类。我特别想和大家讨论人工智能灭绝人类的10000种方式。但时间原因，我只能给大家看一副图片。</p>
<p><img src="/img/the-eggs-of-science-2.png" alt=""></p>
<p>这幅图片是科学家预言在不久的未来，人工智能将达到人类的水平、并成几何级数迅速增长超越人类。这副图并没有直接描绘人工智能是如何灭绝人类的，但智商被碾压本身就很可怕。创造出比我们聪明的人工智能，实际上就是把我们祖先奋斗了几百万年才获得的万物灵长的地位拱手让人。研究人工智能的学者们，在惊喜于自己的科学创新之余，也会忐忑一下。昨天来我们学校报告的南洋理工人工智能学者黄广斌教授，讲座结束之际还补充了一句：不能无限制地发展人工智能。霍金、比尔盖茨也都不断提醒人们：注意人工智能！但是社会上也有反面的声音，认为应当无限制地发展人工智能。我听到最极端的是科学中心论和宇宙中心论主义者对人工智能的支持。在他们看来，人类利益微不足道，人类只是服务于科学发展的一个载体，是宇宙演化的一个齿轮。只要人工智能对科学进步和宇宙演化有好处，哪怕因此人类自己灭亡了也无所谓——至少我们可以夸赞自己是大义灭亲！</p>
<p>话说回来，今天我们自然辩证法课的主题是科技与社会。总结一下，人工智能与社会的关系：第一，在未来，人工智能会在就业问题上直接影响社会；第二，在未来，人工智能可能会给社会伦理带来新的挑战；第三，在未来，人工智能也可能会危及人类文明。不知道大家注意到没有，这些时态都是未来的。到目前为止，我是在YY一个未来形态的人工智能，在猜测它在未来的时间里对社会的影响。而未来是混顿的，没人可以精确预测，我这样挖穿脑洞真的好吗？我为什么刻意面相未来说科技对社会的影响？</p>
<p>先跟大家分享一个冷知识：你们知道杜鹃鸟不会筑巢吗？［观众们知道］它们会把自己的蛋下在麻雀的巢里，可是麻雀妈妈不知道，一个劲地孵啊孵，直到小杜鹃破壳而出。小杜鹃生来就有一个本能——把身边其它鸟蛋踢下去，把麻雀搞得家破人亡。</p>
<p>我想说的是，科学发现、技术创新就是一颗一颗的鸟蛋，在孵化出来之前，我们很少能知道它是什么，能怎么样。幸运的是目前为止，我们发展的科技，无一例外地丰富了我们的生活，或多或少。值得一提的是那个蛋，叫核弹，差点就成了这颗杜鹃蛋，现在人工智也成了嫌疑蛋，会不会是人类最后一项发明创造。当然也可能不是。如果不是我们也不用庆幸，因为你们各位研二所在的实验室里，可能就在孵化着这一颗蛋。所以，祝大家科研顺利，早日毁灭人类！谢谢！［观众笑，掌声］</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/the-eggs-of-science-cover.png" alt=""></p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录一次破冰演讲]]></title>
    <link href="http://yoursite.com/2015/11/07/english-speech/"/>
    <id>http://yoursite.com/2015/11/07/english-speech/</id>
    <published>2015-11-07T14:47:32.000Z</published>
    <updated>2015-11-08T11:56:49.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/img/english-speech.jpg" alt=""></p>
<p>今天英语沙龙，给大家演讲的主题是《Program Your Life》，主要是想让英语角非计算机专业的小伙伴转变“编程很苦逼”的看法——程序员还是可以很性感很萌的。同时告诉他们一些实用的编程技巧对解放生产力、自动化生活体验很有帮助。</p>
<a id="more"></a>
<p>这个主题对于我来说非常适合。我一直是一个愉快编程的布道师，从点点滴滴中讲述编程在生活中的运用。而且我也是一个实践者，开发过一些简单（几百来行）但意义重大的小工具。同时在网上、社区、会议上也见识过一些人，听闻过一些事。所以演讲内容信手拈来——我花了2个小时时间做好了PPT，花了2个小时，准备script，练习了三四次，就开讲了。</p>
<p>这次我准备了稿件但并没有背诵稿件。通过雅思的训练和Mina相处的日子，我相信自己即兴组织言语的能力。我觉得唯一需要注意，就是如何清晰地传达故事和理念。所以我还是写了一份script，当作一次对自己的录音，敲定了一些表达，理顺了一些长难句。</p>
<p>如何清晰的表达？除了写好script并进行分析，还需要在讲演时把持住节奏。平常我总是火急火燎地把出现在自己脑子里的意念全部倾倒给听众。一来笨拙的嘴巴跟不上，二来意念在大脑里几乎是并行的，或者疾快更新的，所以说出来时会常常中途易辙。不管怎么样，让听众听起来很难受。这次上台时，我想了一个办法，首先告诉台下：“我的演讲将持续10分钟，我会说得特别慢。”这样给听众一个心理准备，同时也是对自己的暗示。当然演讲时也要时刻注意节奏，具体说就是控制气息和断句，这样抑扬顿挫自然而然就产生了。自己说得气很顺很轻松，相信观众的思路也能跟着我的节奏规律地前行。所以整体感受是，演讲过程轻松活跃，进度比计划的快很多，没有赶时间的感觉（可能是script长度适当）。</p>
<p>慢一些，有节奏一些，观众们能跟上我的思路了，加上这次主题比较有趣，演讲过程中同学们反应很好——预设的笑点，他们都会心笑了——这让我放得更加开，语气、身体移动更加自然。这个过程一直持续到演讲结束，最后同学们开始向我发问，我能很放松地思考和对话。从他们问题看来——并非是任务性或者刁难性的问题——他们对我的演讲内容非常感兴趣。最后裴杰甚至让我当场演示一个小工具，引得大家纷纷起身关注。我觉得这次是我目前为止最满意的一次公开讲演。</p>
<p>区别之前扑朔迷离的经历，可以发现最大的障碍和技巧都在于：内容和节奏。内容必须要有吸引力，这永远是第一条。同时组织表述内容时一定要简单。不要满脑子想复杂句式，不要念念不忘那些酷炫的词汇，准确达意才是最重要的。节奏一定要慢，给自己思考的时间，给听众理解的时间。同时不能光慢而没有节奏，这样会失去听众的耳朵。</p>
<p>路漫漫，其修远兮，我决心好好讲段子。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/img/english-speech.jpg" alt=""></p>
<p>今天英语沙龙，给大家演讲的主题是《Program Your Life》，主要是想让英语角非计算机专业的小伙伴转变“编程很苦逼”的看法——程序员还是可以很性感很萌的。同时告诉他们一些实用的编程技巧对解放生产力、自动化生活体验很有帮助。</p>]]>
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络模型的演化——《链接》读书笔记]]></title>
    <link href="http://yoursite.com/2015/10/30/linked/"/>
    <id>http://yoursite.com/2015/10/30/linked/</id>
    <published>2015-10-30T05:56:38.000Z</published>
    <updated>2015-11-01T04:38:02.000Z</updated>
    <content type="html"><![CDATA[<p>从咱们程序员口中听到“网络”一词，大家会不会立即联想到路由器、交换机这些东西呢？今天我想和大家说的网络，可不局限于计算机网络。事实上，我们周围存在着的网络远比想象中的多：好莱坞影星合作网络，化学反应中物质转化的网络，引用文献网络，经济网络等等。哦，当然还有蜘蛛网——一提到网络就会印入大脑的图像。可网络很复杂，不是一张蜘蛛网就能描述的。如何去描述网络一直是科学家们纠结的问题。现在让我们来看看人们是如何建立模型，一步步逼近真实网络，去描述世界。</p>
<a id="more"></a>
<p>七桥问题，即欧拉图的研究，开创了“图论”这门新的数学分支。欧拉图的贡献在于，它从实际问题中抽象出了模型，使得人们不再去研究路径寻找，而将注意力转移到对图的性质的研究。后来，一些著名的数学家，比如柯西、汉密尔顿等，为图论的发展贡献了很多力量。最后，蓬勃发展的图论渐渐分化出一个分支专门研究一种特殊的图——网络。这就是网络学的起源。</p>
<p>早期大家研究的网络都是确定的甚至是规则的。什么是规则的网络？请大家回忆中学时周一站在操场上开晨会，每个同学都只能与周围前后左右四个同学小声交流。每个同学就是网络的节点。如果两个同学之间能直接交流，他们之间就有一条链接。想象站在东南角的同学把信息传递给西北角的同学，那么信息最短要经过对角线上的几百个同学。</p>
<p>晨会的队形不是自然的队形，它是被政教处的指令所约束的。规则的网络也不是真实的网络，它充满着数学家为简化问题引入的约束。真实网络是复杂的，真实网络中的很多现象是利用规则网络这个简陋的模型没有办法解释的，比如“小世界”的现象。</p>
<p>有一个大学同学，由于某单位欺骗性招生，现在研究生阶段痛苦不堪。长痛不如短痛，她酝酿了一个大胆的计划：想着偷偷逃离原单位，申请去国外深造。但是她很快放弃了。因为她发现，国外大学的教授很可能认识原单位的导师，或者经过很少的几个人的介绍就能相互联系到，很快就能“抓住”她。学术圈相比于科学家分布的地理环境要小得多，这是一种典型的小世界模型。</p>
<p>在六度分离的“小世界”网络里，所有人之间隔着的至多六个人的链接。我想递一个消息给任意指定的地球居民，这个消息最多传递六次。同样还有网页间“十九度分离”，表明每两个网页之间的链接数不会超过十九个。你从白宫主页开始点链接，打开一个网页再点链接，这样重复不到十九次就能点进我的博客主页。网络奇迹般的变小了！？</p>
<p>为了解释“小世界”现象，科学家尝试在网络中引入随机性：用掷骰子的方式决定要不要在任意两个节点之间画上一道链接。再看我们的晨会队列，如果现在链接随机了，那么可能我没法和站在我周围的人有链接，却和隔着十几个人的同学之间进行飞鸽传书—。一个极端的例子是东南角的同学可以直接和西北角的同学之间拥有链接。因为引入了随机，这些都是概率事件，是可能发生的。由于这些可能性，随机的链接把节点之间的平均间隔变小了。</p>
<p>不过，如果世界仅仅是随机的，你和你小区的邻居应该与美国底特律八里街上的居民一样亲密。这明显是不符合我们体验的。同时一定有某种特殊的力量，同样爱好的小伙伴的交往会比不同爱好的同学之间的交往密切高很多。这股力量就是网络的聚团性。俗话说：物以类聚，人以群分。看看我们的晨会队列，现在大家都三五成群地和附近的人抱团聊天。团体间聊得热火朝天，却很少向外界透露消息。</p>
<p>团聚性模型破坏了六度分离的性质。因为大量的链接被用于增加团体内部结合的紧密度，势必会减少团体间的连通程度，这样会不会成为一个“大世界”呢？实验证明，只要团体间的随机链接没有完全消失，随机模型和团聚性模型是可以共存的，成为一个更加贴近真实网络的模型。</p>
<p>我们的网络模型越来越完美，然而，有一些特殊的网络现象困扰着我们。真实网络中，常常有一些节点，它的链接要比周围其它节点要多得多得多。比如说首都北京在交通网络中的地位，它是交通枢纽，几乎所有的高铁都会经过北京，而一些二线三线城市可能都没有高铁站。怎么去解释这些“枢纽节点”呢？</p>
<p>枢纽节点在网络中是怎样产生的呢？原因之一就是，网络是会生长的。之前讨论的网络模型都是静态的，一个网络被提出来，它的节点和链接就不会再变化。真实网络显然不是这样：互联网中一些过时的信息页面会被删除，一些人的逝世会导致社交网络中某些节点消失，与之相关的链接都会跟着消失。同时大量的节点和链接又会产生。网络在进行新陈代谢，是在生长的。</p>
<p>同时想象生长的过程是有偏好的。每个新节点产生后都想依附一个强有力的老节点。即使不是新节点，也都设法通过链接和强有力的节点扯上关系。偏好就是枢纽节点产生的第二个原因。虽然强有力的节点和偏好链接是鸡生蛋蛋生鸡的问题，但通过迭代，枢纽节点的产生几乎是必然的。</p>
<p>可是问题由来了：按照这个规则，那岂不是资历越老的节点越来越富有，而新节点几乎不可能超越老节点成为枢纽？看看真实世界，作为老牌枢纽节点的雅虎不是最终被新兴的谷歌抢去了江山。怎么去解释这种“新星效应”呢？网络科学家提出了节点的“适应度”。适应度通过主导枢纽节点的形成来主导一切。</p>
<p>这让我想到有人对于国产操作系统的相关评论。有些人不看好国产系统，一部分人觉得我们技术水平差，这类人我就不说什么了。第二类人认为国产系统没有前途是因为操作系统拼的是市场，拼生态圈。现在微软、苹果、Unix/Linux、Android一超多强，国产操作系统早已无地落足。这点我确实比较赞同。不过教我们操作系统的杨力祥老师不这么觉得，他认为只要技术够牛够创新，分一杯羹不是没有可能性，甚至还会火起来。如果将技术突破视作新生节点的适应度的话，从网络的观点看，还是有很大希望的。So，Good Luck!</p>
<p>从图论到随机网络，接着引入团聚性和生长性、偏好链接、适应度等一些列元素——这就是《链接》这本书中关于网络的起源、演化和本质的讨论。这本书让我陷入思考的地方有很多。</p>
<p>弱关系</p>
<p>对于网络中枢纽节点的研究，我知道了一个不常见的规律：幂律。先说我们常见的一个规律吧：钟型曲线。学术的说法叫做高斯分布，或者正态分布。这条曲线揭示了自然界的倾向：极端的情况出现较少，中间的情况占大多数。比如说中国成年男性的身高，80%分布在160~175之间，过矮或过高的人相对来说非常少。大自然似乎“满足大多数人的利益”，向往“中庸之道”，大部分人都很开心！</p>
<p>可是网络中的节点呢？我们观察它们的之间的链接分布，发现20%的节点掌握着80%的链接，甚至呈现比帕累托80/20更夸张的比率。事实上，节点的分布规律是呈幂律关系的。幂律分布的曲线不是均匀对称的钟型，而是从无穷大迅速下降并拖着长长尾巴的一条曲线。我们可以想象比尔盖茨站在靠近无穷大的头段，而我们普通人则是尾端。尾端所有人的财产之和，可能也没有办法和比尔盖茨一个人的财产相比。贫富差距之所以常常被描述为“鸿沟”，大概就是因为社会财产的分布接近幂律分布吧。</p>
<p>首先我觉得用网络的观点去看世界，我就觉得很新奇也很受用。</p>
<p>毕竟我们被还原论</p>
<p>在临界点附近，我们不能再把各个原子分开研究。相反，这些原子应当被视为行动一致的群体。原子被原子形成的盒子取代，每个盒子中的原子行为一致。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从咱们程序员口中听到“网络”一词，大家会不会立即联想到路由器、交换机这些东西呢？今天我想和大家说的网络，可不局限于计算机网络。事实上，我们周围存在着的网络远比想象中的多：好莱坞影星合作网络，化学反应中物质转化的网络，引用文献网络，经济网络等等。哦，当然还有蜘蛛网——一提到网络就会印入大脑的图像。可网络很复杂，不是一张蜘蛛网就能描述的。如何去描述网络一直是科学家们纠结的问题。现在让我们来看看人们是如何建立模型，一步步逼近真实网络，去描述世界。</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[作业的本质]]></title>
    <link href="http://yoursite.com/2015/10/29/the-nature-of-homework/"/>
    <id>http://yoursite.com/2015/10/29/the-nature-of-homework/</id>
    <published>2015-10-29T12:03:19.000Z</published>
    <updated>2015-11-01T04:32:25.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://i13.tietuku.com/c2cd1b67bce0cff1.jpg" alt=""></p>
<a id="more"></a>
<p>最近一直在订正作业。周一晚上计算机体系结构上了一堂习题课。说真的，上次听“习题课”这一叫法还是在中学。为什么要上习题课呢？一是因为课后作业错得太多，而且又没有一个100%的正确答案可以对照，所以需要老师帮着把答案确定一遍。二是由于体系结构的作业太难，同学们私下讨论不出结果，百度谷歌又搜不出像样的专业领域专业问题的解答，需要一个权威人士讲解，学习专业的思路。这里不得不说，书后习题出得真赞。以至于每次做作业，题目都看不懂。回想过去单纯的中学时光，我们学会的一项重要技能就是揣测题意，做到知己知彼（也许你没注意，但仔细想想很大可能你已经在运用了）。计算机体系结构书后习题具有独特的延伸性和启发性了，根本不知道它想问你什么。乍一看很多题目与课本前面的内容、上课的内容都没什么关系啊，别提猜出题目在考察什么知识点了。但神奇的是，经老师这么一讲解，就都和课堂上、书上的知识点结合起来了，让人时不时地恍然大悟。</p>
<p>上习题课的第三个原因，是因为考试中会有原题。这一点乍一听很关键啊！试想这样一个让人冷汗直冒的场景：你有一题作业没搞懂，考试遇到类似题，其他人都奋笔疾书，信心十足又沾沾自喜地在你前面交上试卷。你岂不是要悔地直跺脚？这时你突然想起国科大某位老师曾经说过的一句话：“你考试分数高，我不能说你这一门课学得好；同样你学得好，考试成绩也不一定高”。你不禁陷入了对一个大问题的沉思中：考试到底算什么？作为局内人，我也说不清楚考试算什么。好消息是在国科大，在研究生阶段，课程作业、考核这些形式上的东西与知识的夹沟，我觉得已经很窄了。</p>
<!--本科阶段的成绩那是相当重要：出国留学得看GPA，保研名额分配也大幅度地参考综合成绩排名。奖学金的申请与成绩也是息息相关。一个漂亮的成绩单在找工作时当然没有一点坏处。研究生阶段和本科阶段怎么说得有些差别吧？我身为局中人，其中差别我还真说不清。但是我知道，相对于本科生，对于研究生的考察，至少增添了科研能力这一标准。增加的标准势必会降低其它标准的权重。由于我们精力有限，我们应该相应地减少应试时间，去为提高自己研究生身份应有的能力。哪些是研究生应培养的能力，我说不准，我暂且用“实力”一词指代。-->
<p>说作业是形式，我自己有些过意不去。对于作业的本质，我也是在学生生涯中断断续续思考良久。学习的过程不只要输入，输出也是重要环节。比如看书、听课那只是输入部分，而输出往往会被我们忽视。输出是指用知识影响周围世界。我们把刚刚学到的知识分享出去影响别人，我认为这就是“教学相长”的内涵。我们用实践去改造世界，我认为这就是“知行合一”的内涵。当然实践知识有时是一件麻烦事：我学会了电路设计，我要实践，那我得花些时间和金钱去买些电子器件吧。而作业，就是一种模拟性质的实践：把你放在一个用文字建立起来的情景中，给你一切想要的，你只要集中精力去运用学会的知识解决问题就可以了。是不是很神奇呢？我想，这才是作业的本质。学习然后实践，最简单的实践就是解题看看。解错了、解不出来那就去听讲解，再一遍仔细研究学习内容，再实践。通过迭代，让知识隐性化为常识或者本能反应。回头看我们小学时的“课前预习、课堂认真听讲、复习笔记、写作业”的学习回路，真是蕴含着大智慧呢！其实小时候有很多这样的大智慧由于太朴素而没有被我们赞美，这是另外一码事了。</p>
<p>通过对作业的重新思考，我们还能抱怨什么或者有什么额外的期待呢？一份好的作业永远不会是负担，也不会让人怀疑它和成绩之间的暧昧关系——它一直忠贞于知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://i13.tietuku.com/c2cd1b67bce0cff1.jpg" alt=""></p>]]>
    
    </summary>
    
      <category term="元知识" scheme="http://yoursite.com/tags/%E5%85%83%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[记录一次OSX软件破解]]></title>
    <link href="http://yoursite.com/2015/10/10/hacking-osx-app/"/>
    <id>http://yoursite.com/2015/10/10/hacking-osx-app/</id>
    <published>2015-10-10T05:02:54.000Z</published>
    <updated>2015-10-14T05:56:08.000Z</updated>
    <content type="html"><![CDATA[<p>这不是一篇教你破解苹果软件的简明教程，而是一篇斗智斗勇的曲折故事。请支持正版！</p>
<a id="more"></a>
<h1 id="序章：惹错人了">序章：惹错人了</h1><p>听说精致的Mac和优雅的MarkDown很配。你知道Markdown也可以用来写作幻灯片吗？首先给大家推荐一个Mac平台上优雅的应用叫做DeckSet。售价29.99$，挺贵的，呵呵。</p>
<p>我真的是一个自由软件爱好者！我虽然穷我支持正版！但我同时是个愤青啊！AppStore慢也就算了，想注册个可以花钱的账号过程也太不友好了！关键是，安装完DeckSet你跟我说公式渲染要额外付费9.99$是几个意思？</p>
<p>而且我仔细观察软件的行为，发现它的公式解析使用的是MathJax——一款开源免费的程序。DeckSet从开源软件中免费获得了代码，转而将这些代码实现的功能通过收费的形式提供给消费者，太不人性了（不过这不构成侵权，因为MathJax遵循的Apache协议允许商业销售）。</p>
<p>如果你不付钱呢，它就给你这样弹警告：</p>
<p><img src="/img/extra-money.png" alt=""></p>
<p>给你这样(把你的公式给吞了，仔细看还有淡淡的影子):</p>
<p><img src="/img/no-formula.png" alt=""></p>
<p>不管怎么样，我想它是惹错人了。</p>
<h1 id="利其器">利其器</h1><p>我并不是一个职业黑客。我之前也没破解过软件。既然放了狠话，也只能硬着头皮上。看看我已经有啥技能和工具：掌握C语言，有过软件设计的些许经验。由于踩过无数坑，渐渐总结出了软件调试技巧。加上一些新手的运气和对奸商的憎恶——可以付之一搏了。</p>
<p>再看看手头工具有哪些呢？静态观察程序代码，那就得要反汇编器，我觉得otx就不错。动态观察程序运行，那就得要调试器，就用Xcode自带的gdb吧。编辑二进制文件，系统自带的vim就可以。都是一些没有图形界面的土装备，但够用就行，烦不了太多——我是新手我怕谁。</p>
<p>otx用homebrew就可以安装。前提是必须先安装好Xcode。</p>
<p>gdb据说是Xcode自带。不过之前我用homebrew大法安装了独立版本。受限于系统权限，gdb想调试一个程序并不容易。你得用证书把gdb签名，赋予它调试其它进程的权限。具体过程可以参考<a href="http://www.csdn123.com/html/topnews201408/43/8443.htm" target="_blank" rel="external">这个</a>。</p>
<h1 id="了解你的敌人">了解你的敌人</h1><p>为了破解一个软件，我们不得不先了解这个软件。为了了解我们的目标，我们得搜集它的各种信息。</p>
<p>搜集信息的第一个层面是你要知道敌人在哪？我是说你的知道软件的安装位置和目录结构。Mac系统上，软件被装在/Application/目录下。其中/Applications/XXX.app/Contents/MacOS/这个目录下就是程序的二进制文件——我们靶子！</p>
<p>搜集信息的第二个层面就是多用这个软件，对与一些提示要特别留意。比如第一幅图中那烦人的黄色警告条：”Buy formula support for $9.99”就变成了我的突破口。</p>
<p>首先我用下面命令对程序进行反汇编，汇编代码保存在deckset.asm文件里。</p>
<pre><code>otx Applications<span class="regexp">/Deckset.app/</span>Contents<span class="regexp">/MacOS/</span>Deckset &gt; deckset.asm
</code></pre><p>打开保存结果的文件，里面全是汇编代码和各种零零碎碎的信息。我是新手，我看不懂。我不管，先Ctrl+F查找”Buy formula support”。果然，这样这样函数，对某个值进行了判断，并跳转到输出”Buy formula support”。跟踪这一线索，不说能不能了解程序判断你是否是合法用户的机制，倒是眼前肯定闪过了不少能让你想入非非的词汇，比如：</p>
<ul>
<li>initWithMASProduct(MAS是不是maths?Product！)</li>
<li>RecieptVerification(Verification?验证什么？)</li>
<li>systemMACAddress(是不是用了MAC地址进行验证啊？)</li>
<li>purchaseFormulas</li>
</ul>
<p>这个时候一些软件设计的经验就派上用场啦！用猫的思维去思考的老鼠活得才自在，用老鼠思维去思考的猫才能抓到最多的老鼠。知道怎么拼软件才知道怎么拆软件。</p>
<p>这时google到了一个工具叫class-dump（听到dump就来劲！），可以从面相对象编程的OC二进制文件中提取类的信息。这就是搜集信息的第三个层面，程序代码中蕴含的信息。otx反汇编时其实已经包含零零碎碎的信息啦，只不过class-dump的信息是按面向对象的思想整理过的。</p>
<p>otx也好，class-dump也好，不管用什么工具，意识最重要。刚刚看过的那些想入非非的字符串的最后一条“purchaseFormulas”激发了我的灵感。我Ctrl+F用purchase一搜，得到了下图信息：左边是otx反汇编的代码，右边是class-dump的结果，可以验证这些信息两个工具都是可以提供的，只是class-dump更便于阅读）:</p>
<p><img src="/img/purchase.png" alt=""></p>
<p>看到这个函数名”purchasedAddOnWithIdentifier”，加上返回值类型是BOOL，以及一些想当然，可以说任务已经完成一大半了。明白了吗？这个函数很可能是用来验证用户是否购买过这个AddOn，如果买过就返回True，否则False。所以我们只要让这个函数一值返回True很可能就大功告成啦！</p>
<h1 id="准备毒药">准备毒药</h1><p>来，我们仔细看purchasedAddOnWithIdentifier代码！</p>
<p><img src="/img/purchase_code.png" alt=""></p>
<p>你真的仔细看了？我开玩笑的:P 我自己都看不懂！不需要看懂，我就是想让这个函数一直返回1而已。大神可能已经在用大脑编译一段实现这样功能代码然后直接用机器码填上了——这我可做不到，但我机灵着呐：我用C语言写一段一直返回1的函数，然后编译这段C代码，接着从里面提取这段机器码。</p>
<p>好，现在就开始做！写一段熟悉的C语言代码：</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>

<span class="function"><span class="keyword">int</span> <span class="title">freeman</span><span class="params">()</span>
</span>{
    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
    <span class="keyword">if</span> (freeman())
        <span class="built_in">printf</span>(<span class="string">"hello"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>编译完了在用otx反汇编，得到：</p>
<p><img src="/img/alway_true.png" alt=""></p>
<p>用图中高亮显示的8字节机器码替换掉purchasedAddOnWithIdentifier开头的代码，就可以让purchasedAddOnWithIdentifier函数永远返回1，也就是True啦。这8字节机器码就是我们的毒药，下面我们来看看怎么把毒药喂给程序。</p>
<h1 id="下毒">下毒</h1><p>明确任务，我们需要把图左边的8字节代码一一换成右边对应的代码。</p>
<p><img src="/img/paper.png" alt=""></p>
<p>但是还记得吗？我们上述操作都是建立在purchasedAddOnWithIdentifier是关键验证函数这个猜想上的，我可不想在可执行文件本身直接动手，而是选择在运行时内存镜像中进行动态hack。这里就用上了gdb和一些特殊的调试技巧。</p>
<pre><code>gdb deskset
&gt; b *<span class="number">0x00000001000c43b2</span>   <span class="preprocessor">#purchasedAddOnWithIdentifier函数开始地址</span>
&gt; r
</code></pre><p>然后随便摆弄一下程序，直到其“卡”在断点上。谢天谢地，程序真的停下来了！然后开始用gdb的<code>set</code>命令修改<code>0x1000c43b2~0x1000c43be</code>范围内内存单元的值。set完了，再用<code>disas 开始地址，+区间长度</code>命令反汇编这一段内存区域，检查是否正确。从下图可以看到，我们的代码和C语言hello程序中的freeman函数反汇编的结果是一样的。</p>
<p><img src="/img/set_disas.png" alt=""></p>
<p>然后 <code>continue</code> 运行。成功了！</p>
<p>清爽的界面再没有警告！购买菜单也灰掉了。</p>
<p><img src="/img/success.png" alt=""></p>
<p>最重要的是公式终于清楚地显示啦！</p>
<p><img src="/img/success2.png" alt=""></p>
<h1 id="稳固胜利果实">稳固胜利果实</h1><p>试验成功了，我们的毒已经注入了程序的内存空间。但是这个破解可不是永久的，每次重新打开程序，就得重复上述步骤进行破解。现在我们要把胜利的果实固定住。这可以通过修改程序二进制文件进行。用到的工具就是vim。</p>
<p>利用vim打开二进制程序看起来不是一个好主意——一片乱码啊！不过在vim中敲<code>:</code>然后在下面输入<code>%!xxd</code>回车后看到了可是另一番景象。通过搜索匹配到我们的目标代码，然后逐一替换，保存即可。</p>
<p><img src="/img/hex.png" alt=""></p>
<p>具体操作时有一些问题，比如说目标代码不好定位。这里提供一个小的脚本工具：<a href="http://reverse.put.as/wp-content/uploads/2011/02/offset1.3.pl_.gz" target="_blank" rel="external">offset</a>用来定位。</p>
<p>替换完成后别急着<code>wq</code>保存退出。而是先<code>%!xxd -r</code>重新转码然后再保存退出。</p>
<p>这样，我们就可以优雅地运行程序了。</p>
<p>哦，对了请支持正版！</p>
<h1 id="参考资料">参考资料</h1><ul>
<li><p><a href="https://reverse.put.as/wp-content/uploads/2011/02/beginners-tut-II.txt" target="_blank" rel="external">https://reverse.put.as/wp-content/uploads/2011/02/beginners-tut-II.txt</a></p>
</li>
<li><p><a href="http://kswizz.com/2011-01-16/hacking-mac-apps/" target="_blank" rel="external">http://kswizz.com/2011-01-16/hacking-mac-apps/</a></p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这不是一篇教你破解苹果软件的简明教程，而是一篇斗智斗勇的曲折故事。请支持正版！</p>]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[用QEMU来调试内核 -- 亲身体验篇]]></title>
    <link href="http://yoursite.com/2015/10/04/debug-kernel-with-qemu-2/"/>
    <id>http://yoursite.com/2015/10/04/debug-kernel-with-qemu-2/</id>
    <published>2015-10-04T05:37:39.000Z</published>
    <updated>2016-10-23T03:57:20.000Z</updated>
    <content type="html"><![CDATA[<p>本文记录了用QEMU构建最小Linux系统并进行调试的过程。</p>
<a id="more"></a>
<h2 id="愿景">愿景</h2><p>我在<a href="http://freemandealer.github.io/2015/08/27/debug-kernel-with-qemu/" target="_blank" rel="external">用QEMU来调试内核 – 亲身体验篇</a>中大致记录了邮件列表上和网上搜索到的内核调试方法，并没有完全进行验证。今天亲自实践了一番，发现：</p>
<ul>
<li>QEMU调试果然爽快</li>
<li>调试环境搭建过程中有很多细节需要注意</li>
</ul>
<p>先来看看有了QEMU内核调试环境后，我调试内核的大致步骤。</p>
<ul>
<li><p>修改内核，make编译（不用完整执行，生成bzImage就可以中断make）。如果工作在图形模式下，执行</p>
<pre><code>qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage \
-initrd initramfs-busybox-x86<span class="class">.cpio</span><span class="class">.gz</span>
</code></pre></li>
<li><p>如果工作在字符界面下，执行</p>
<pre><code>qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage \
-<span class="ruby">initrd initramfs-busybox-x86.cpio.gz \
</span>-<span class="ruby">append <span class="string">"console=ttyS0"</span></span>
</code></pre></li>
<li><p>运行GDB(这个GDB是要自己编译的，见<a href="http://freemandealer.github.io/2015/08/27/debug-kernel-with-qemu/" target="_blank" rel="external">上篇文章的末尾</a>)。</p>
<pre><code>gdb vmlinux
&gt; <span class="keyword">target</span> remote localhost:1234
</code></pre></li>
<li><p>进入弹出的QEMU窗口，<code>CTRL+ALT+2</code>进入QEMU控制台，输入<code>gdbserver</code>。</p>
</li>
<li><p>调试开始！</p>
</li>
</ul>
<p>再也不用像使用VMware那样等一万年去<code>make modules&amp;&amp;make install &amp;&amp;make modules_install</code>以及费尽心思去调教grub了。节省了大量时间，同时资源占用也少太多。一切都是整整齐齐的模样。</p>
<p>本文采取倒叙的描述方式，上面就是我们的目标啦。怎么才能实现呢？参考LFS，我们进行下面的步骤。</p>
<h2 id="为什么要构建自己的运行系统">为什么要构建自己的运行系统</h2><p>插一段话，解释什么是LFS。LFS是<a href="http://www.linuxfromscratch.org/lfs/view/stable/index.html" target="_blank" rel="external">Linux From Scratch</a>缩写，意思是利用网络上的开源代码，从头<strong>构建</strong>Linux<strong>发行版</strong>。“<strong>构建</strong>”这里指编译和安装，不是指设计程序和敲代码的过程。构建的目标Linux<strong>发行版</strong>，不是让你从头写Linux内核本身。Linux发行版有很多外延，比如CentOS、Ubuntu、Arch等等。我自个儿就琢磨着呗，我们做内核开发，不能老用别人的发行版：一来我们要分清什么是Linux的共性特征，什么是一些发行版加进去的个性特征；二来从头构建Linux发行版能加深我们对这个系统的理解。更重要的是，毕竟我们研究内核其实就是在溯源，我不希望在探求原理路途上有什么迷雾遮住自己的眼，而是喜欢“一切都在掌握之中”的良好感觉。</p>
<h2 id="环境搭建">环境搭建</h2><p>开始的内核编译我已经不想再说了。使用默认配置文件即可：</p>
<pre><code><span class="built_in">make</span> x86_64_defconfig
</code></pre><p>看最上面运行QEMU的那条命令，其实我们缺的就是initramfs-busybox-x86.cpio.gz文件——一个Initial RamDisk——开机时需要挂载的rootfs和一些二进制工具以及最重要的init。</p>
<p>有两种方式获得这个Initial RamDisk。一种方式是在内核编译前生成，另一种通过内核编译选项在内核编译后生成。</p>
<h3 id="方法一：编译前生成">方法一：编译前生成</h3><p>先用下面的命令下载并解压缩BusyBox:</p>
<pre><code>curl <span class="string">http:</span><span class="comment">//busybox.net/downloads/busybox-1.23.2.tar.bz2 | tar xjf -</span>
</code></pre><p>为BusyBox创建工作目录:</p>
<pre><code><span class="label">mkdir</span> -pv obj/<span class="keyword">busybox-x86
</span><span class="label">make</span> O<span class="label">=obj</span>/<span class="keyword">busybox-x86 </span>defconfig
</code></pre><p>使用menuconfig配置BusyBox:</p>
<pre><code><span class="label">make</span> O<span class="label">=obj</span>/<span class="keyword">busybox-x86 </span>menuconfig
</code></pre><p>选择静态链接:</p>
<pre><code>-&gt; <span class="keyword">Busybox </span>Settings
    -&gt; <span class="keyword">Build </span>Options
    [ ] <span class="keyword">Build </span><span class="keyword">BusyBox </span>as a static <span class="keyword">binary </span>(no shared libs)
</code></pre><p>编译、安装BusyBox:</p>
<pre><code><span class="keyword">cd</span> obj/busybox-x86
<span class="keyword">make</span> -j2
<span class="keyword">make</span> install
</code></pre><p>拷贝安装目录中的工具到initramfs目录中，这个文件夹就是日后的initramfs:</p>
<pre><code>mkdir -p initramfs/x86-busybox
cd initramfs/x86-busybox
mkdir -pv {bin,sbin,etc,<span class="keyword">proc</span>,sys,usr/{bin,sbin}}
cp -av obj/busybox-x86/_install/* ./
</code></pre><p>initramfs目录中没有init脚本，这可不行，我们的内核起来以后运行什么程序呢？我们手动创建一个：</p>
<pre><code><span class="comment">#!/bin/sh</span>

/bin/mount -t <span class="keyword">proc</span> none /<span class="keyword">proc</span>
/bin/mount -t sysfs sysfs /sys
echo '<span class="type">Enjoy</span> your new system!'
/bin/sh
</code></pre><p>生成initramfs:</p>
<pre><code><span class="comment">find</span> <span class="string">.</span> <span class="literal">-</span><span class="comment">print0</span> <span class="comment">|</span> <span class="comment">cpio</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">null</span> <span class="literal">-</span><span class="comment">ov</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">format=newc</span> <span class="comment">|</span> <span class="comment">gzip</span> <span class="literal">-</span><span class="comment">9</span> &gt; <span class="comment">initramfs</span><span class="literal">-</span><span class="comment">busybox</span><span class="literal">-</span><span class="comment">x86</span><span class="string">.</span><span class="comment">cpio</span><span class="string">.</span><span class="comment">gz</span>
</code></pre><p>得到initramfs了，任务结束了!看明白了吗？</p>
<p>同时这里给出生成initramfs的逆操作－－拆分initramfs:</p>
<pre><code>cpio -<span class="tag">i</span> -d -H newc -F initramfs_data<span class="class">.cpio</span> --no-absolute-filenames
</code></pre><blockquote>
<p>如果想直接使用硬盘而不是initramfs，这里提供一个思路：</p>
<pre><code><span class="tag">dd</span> <span class="keyword">if</span>=/dev/zero of=rootfs<span class="class">.img</span> bs=<span class="number">1</span>k count=<span class="number">400</span>
mkfs<span class="class">.ext2</span> ­<span class="tag">i</span> <span class="number">1024</span> ­F rootfs<span class="class">.img</span>
mount ­o loop rootfs<span class="class">.img</span> /mnt/rootfs
qemu-system-x86_64 -hda ~/kernel-lab/rootfs<span class="class">.img</span> \
-kernel ~/staging/arch/x86_64/boot/bzImage \
-append <span class="string">"root=/dev/hda console=ttyS0"</span>
-nographic
</code></pre></blockquote>
<h3 id="方法二：编译后生成">方法二：编译后生成</h3><p>通过内核编译前配置<code>CONFIG_INITRAMFS_SOURCE</code>选项到一个存在的gzipped的initramfs、或是一个准initramfs目录、或是如下格式指定initramfs结构的txt文件:</p>
<pre><code>dir /dev <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
nod /dev/console <span class="number">644</span> <span class="number">0</span> <span class="number">0</span> c <span class="number">5</span> <span class="number">1</span>
nod /dev/loop0 <span class="number">644</span> <span class="number">0</span> <span class="number">0</span> b <span class="number">7</span> <span class="number">0</span>
dir /bin <span class="number">755</span> <span class="number">1000</span> <span class="number">1000</span>
slink /bin/sh busybox <span class="number">777</span> <span class="number">0</span> <span class="number">0</span>
file /bin/busybox initramfs/busybox <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
dir /proc <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
dir /sys <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
dir /mnt <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
file /init initramfs/init.sh <span class="number">755</span> <span class="number">0</span> <span class="number">0</span>
</code></pre><h2 id="参考">参考</h2><p>如果你想弄清楚内核的初始化过程，这里有一份阅读列表：</p>
<p><a href="http://mgalgs.github.io/2012/03/23/how-to-build-a-custom-linux-kernel-for-qemu.html" target="_blank" rel="external">How to Build a Custom Linux Kernel for Qemu</a></p>
<p><a href="http://www.linuxfromscratch.org/lfs/view/stable/" target="_blank" rel="external">Linux From Scratch</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt" target="_blank" rel="external">Kernel Doc：Ramfs, Rootfs and Initramfs</a></p>
<p><a href="https://www.kernel.org/doc/Documentation/early-userspace/README" target="_blank" rel="external">Kernel Doc: Early Userspace Support</a></p>
<p><a href="http://free-electrons.com/docs/elfs/" target="_blank" rel="external">Embedded Linux From Scratch… in 40 minutes</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文记录了用QEMU构建最小Linux系统并进行调试的过程。</p>]]>
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/tags/Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[野长城]]></title>
    <link href="http://yoursite.com/2015/10/01/the-wild-great-wall/"/>
    <id>http://yoursite.com/2015/10/01/the-wild-great-wall/</id>
    <published>2015-10-01T09:07:59.000Z</published>
    <updated>2015-11-04T10:49:40.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://i11.tietuku.com/2acd988527e65ae4.jpg" alt=""></p>
<p>写一篇文章，纪录在国科大的见闻，给我的父母、姐姐和可能关心我近况的朋友们。</p>
<a id="more"></a>
<p>##1 遇见国科大<br>现在是报到的第二天，我在国科大的第一个早晨。昨天幸幸苦苦赶了一天路，但没想到起得出奇的早。吃完早饭才六点多，便忍不住逛了校园。自己真真实实地走了完整一圈，停在图书馆前仰头看，真是感动的无法言语。精心修剪的草坪加上宏伟的建筑，配上怀柔才有的蓝天——在现实里，还真是浮夸呀；这估计就是高考前幻想中大学校园，终于在我的研究生阶段遇见了。</p>
<p><img src="http://i11.tietuku.com/d095c57ba0c0eb15.jpg" alt=""></p>
<p>##2 怀柔<br>网上有人说怀柔是北京最后一片净土。是不是最后一片，我没有考证。但是在这里，我见到的星星比在之前呆过的任何地方都多。开学典礼上那个“脱口秀”马校长称赞这里是天然氧吧，我看并不过分。连续几天打开天气App，都是十几的PM2.5（不过截至到敲这段文字的时候，空气质量已经中度污染了）。不过我现在也不怎么关注什么App呢，直接看看周围的山色就知道今天能不能贪婪地呼吸空气了。</p>
<p><img src="http://i11.tietuku.com/f4180cb2a7da5049.png" alt=""></p>
<p>##3 爬野长城，并活着回来<br>室友们似乎开始进入了早睡早起的节奏了。现在是下午一点，一个个困得不行都在拉窗帘、锁门、睡午觉。楼道里遇见黄班长，兴奋地拉着我说要组队去爬野长城，希望叫上我们宿舍的伙伴们。</p>
<p>野长城的事情，不久前学校刚刚警告我们不要试图去爬。危险不说，上去会被抓，要拘留。我一想拘留就不用去上课了，所以就答应黄班长的邀请。毕竟第一次班级“组织活动”，我们宿舍就不参加，不是一个好开头。舍友张刚也是一个特别有责任感的同志，尽管鞋子没有干，也是困得不行，还是硬着头皮一同上路了。就这样，我的小米手环告诉我这一天我步行了20公里。</p>
<p>我没有去过真正的长城，看来我不是好汉。但是我去过野长城。我觉得野长城没什么不好，可能就是游人不多，入口的地方有可爱的大妈守着（大妈说反正你们不能从我这里过，不过前面还有一个口子可以上长城）。很多修行的人坐在古老的石道上参禅打坐，很安静。有一段石道长满杂草，很怀旧。</p>
<p><img src="/img/wild-wall.jpg" alt=""></p>
<p>##4 第一堂课<br>昨天校车刚进大门的时候，看到了气派的建筑群，就听到车里有同学尖叫说：好像国外学校！我想说，果壳大不仅是外表洋气，上起课来格调也是拽的不行。</p>
<p>第一堂课是数据挖掘，老师用英语上的，课程安排、作业什么的给人感觉就像从coursera里蹦出来的。美中不足的就是共有500个人选，但国科大最大的教室才300人（你们在干什么啊，讲台都要坐满了呀！）记得我六点半过去位子就没有了——上课时间是八点半。在写这篇文章时，我已经把这门课退了。</p>
<p><img src="http://i11.tietuku.com/582cfa7ff56d520d.jpg" alt=""></p>
<p>##5 国科大的老师<br>我这一个星期见到的院士比以往一生都多。因为我之前从来没有见过院士。而国科大的老师呢？可把我这个乡下孩子看傻眼了。</p>
<p>胡伟武老师，龙芯设计组组长。关于他的新闻，网上很多。我很喜欢上他的课，说得很有带入感，有技术背景喜欢发挥。更关键地是他一直和蔼地笑着讲课。加上他的课都是在晚上，让我回忆起大一晚上上马廷淮的C语言启蒙课的日子。</p>
<p>林惠民。听不懂啊听不懂啊听不懂啊。不仅不知道他在讲什么，关键是不知道他为什么讲这些。一查卧槽——中科院院士——怪不得跟不上他的思维境界。不管怎么样，写这篇文章时我已经把他的课退了。</p>
<p>杨力祥，操作系统老师，讲Linux内核的老师我都喜欢……他如果不吹牛的话。“我第一次赚大钱的时候”“买一个地球仪在办公室里转着看”“花了10年把计算机做到世界顶级”。</p>
<p>##6 释放能量<br>依山伴水，天然氧吧，跑跑步便是极好。健身房就在宿舍楼前，虽不精致却能激发荷尔蒙，一次4块也算便宜。操场就在窗外，踢踢球也很娱乐。在国科大呆一年身体如果虚弱了，那真是没救了。</p>
<p><img src="http://i11.tietuku.com/1cb1cfde387c0bb8.jpg" alt=""></p>
<p>##7 友好邻居爱串门<br>明天是国庆节:) </p>
<p>今天晚上可不能浪费。正巧遇见孟轲溜去二食堂就餐，我毫不犹豫地把他拽回一食堂。吃饭时说道上个星期摆脱他给我写的一个课程同步工具ucs出现了一些bug，吃完饭便拿了电脑去他宿舍单元找他解决问题。</p>
<p>推开门这货竟然坐在飘窗上谈吉他。飘窗上铺了毯子，放了一个颇有质感的大靠垫，也是很有孟博士该有的智慧和情调。然后我就一边听他弹琴，一边想办法让bug重现。大前研一在他的《一万小时天才理论》里曾经说过：如果路人辨认出了练习的曲子，那么他的练习方法就不正确。这样看来，孟轲是真的在练琴。</p>
<p>孟博士充满激情地调着代码，不时地说着冷笑话。我感觉很冷，我就开始玩我自己的电脑。突然想到前几天在群里聊“科学上网”认识的大神刘洪亮，约好有机会见面聊聊天来着，这不正好有空，还正好住在孟博士楼上，果断抱着电脑去串门，让孟轲一个人好好静一静，不要老分神讲冷笑话。</p>
<p>推开门一看，倒是他先认出了我：“这不是一个小时前上操作系统课上坐我旁边那哥们儿？”我的天，原来我要找的人坐我边上上了半个下午的课。刘洪亮东北辽宁人，不过我本科宿舍就有一哥们儿大庆的，我也不害怕。聊了几句，发现他果然是计算机网络方面的大神，随随便便就带我入门IPv6，把我的科学上网能力有带进步了一大截。他人有非常好，我随随便便就把他拉进我的粉丝群，并且拉着他帮我们一块儿做计算机网络小组作业。</p>
<p>回到孟轲宿舍，果不其然，他把bug都解决了。我非常感激，就把楼上刘洪亮刚刚教我的科学上网大法传授给了他。我们都很开心。</p>
<p>年轻人，就应该快乐地生活在一起，互相学习。学杂了才能学精。不然为什么要有大学呢？</p>
<p>##8 UCS上线!<br>今天是国庆节:)</p>
<p>也是ucs上线的大日子！昨天孟轲辛辛苦苦解决了所有已知bug，我不能藏着这个宝贝不分享，而是要让它发挥更大的作用。我做了一系列“最终”测试，重新整理了软件说明书，在11点20分向各大社交网络的群体广播了ucs“上线”的消息：</p>
<blockquote>
<p>国庆快乐!可是大家不要忘了写作业和学习！<br>推荐大家一个国科大课程材料同步工具UCS</p>
<p>懒得天天打开网页挨个下课件，所以求计算机学院孟轲同学帮我写了一份，热气腾腾，大家也试试吧：）</p>
<p>同时欢迎报告Bug，更欢迎大家贡献代码  <a href="https://github.com/tianxianbaobao/UCS" target="_blank" rel="external">https://github.com/tianxianbaobao/UCS</a></p>
</blockquote>
<p>消息一发送，收到了无数个赞。当然，用户反应的问题比赞多，更比想象中的多——这时我才意识到Beta测试是多么的重要。</p>
<p>计算所的同学群无疑是给我们支持最多的一个群体。小伙伴们早已不把自己当用户很多年，纷纷撸起袖子测试、watch、star、fork我们的项目，耐心细致地报告bug，甚至已经操刀为ucs增加新特性了。</p>
<p>其实我的github账号注册几年了，也用了很久了，可是作为我亲手初始化的项目，这是第一次受到怎么多（几十次，至少对于我来说是多的）访问。Issue、fork、branch这些功能，我原以为是可有可无的，是无聊的教课书才会涉及的，或是高手卖弄才学的，而现在它们正灵活地运用在实际项目中——虽然它就像麻雀那般小。</p>
<p>代码这些事大家一起玩真的很刺激！感谢孟轲感谢大家，并希望ucs能为大家带来些许的方便。</p>
<p>##9 对床风雨</p>
<p>##10 人文熏陶<br>如何提问</p>
<p>##11 离科学最近的地方</p>
<p>##12 红螺寺</p>
<p>##13 山顶小屋</p>
<p>##14 又一个好老师<br>科研，讲述ppt</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://i11.tietuku.com/2acd988527e65ae4.jpg" alt=""></p>
<p>写一篇文章，纪录在国科大的见闻，给我的父母、姐姐和可能关心我近况的朋友们。</p>]]>
    
    </summary>
    
      <category term="Life" scheme="http://yoursite.com/tags/Life/"/>
    
  </entry>
  
</feed>
